
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/device-communication.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2fdevice_2dcommunication_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_v1_2fdevice_2dcommunication_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_v1_2fdevice_2dcommunication_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2fdevice_2dcommunication_2eproto {
  static const ::uint32_t offsets[];
};
namespace handEngine {
namespace v1 {
class AggregateMessage;
struct AggregateMessageDefaultTypeInternal;
extern AggregateMessageDefaultTypeInternal _AggregateMessage_default_instance_;
class CommandPacket;
struct CommandPacketDefaultTypeInternal;
extern CommandPacketDefaultTypeInternal _CommandPacket_default_instance_;
class DeviceCommand;
struct DeviceCommandDefaultTypeInternal;
extern DeviceCommandDefaultTypeInternal _DeviceCommand_default_instance_;
class DeviceEvent;
struct DeviceEventDefaultTypeInternal;
extern DeviceEventDefaultTypeInternal _DeviceEvent_default_instance_;
class DeviceInformation;
struct DeviceInformationDefaultTypeInternal;
extern DeviceInformationDefaultTypeInternal _DeviceInformation_default_instance_;
class DeviceMessage;
struct DeviceMessageDefaultTypeInternal;
extern DeviceMessageDefaultTypeInternal _DeviceMessage_default_instance_;
class DeviceProperty;
struct DevicePropertyDefaultTypeInternal;
extern DevicePropertyDefaultTypeInternal _DeviceProperty_default_instance_;
class DfuData;
struct DfuDataDefaultTypeInternal;
extern DfuDataDefaultTypeInternal _DfuData_default_instance_;
class FirmwareData;
struct FirmwareDataDefaultTypeInternal;
extern FirmwareDataDefaultTypeInternal _FirmwareData_default_instance_;
class ImuData;
struct ImuDataDefaultTypeInternal;
extern ImuDataDefaultTypeInternal _ImuData_default_instance_;
class ManufacturingData;
struct ManufacturingDataDefaultTypeInternal;
extern ManufacturingDataDefaultTypeInternal _ManufacturingData_default_instance_;
class PeripheralState;
struct PeripheralStateDefaultTypeInternal;
extern PeripheralStateDefaultTypeInternal _PeripheralState_default_instance_;
class Product;
struct ProductDefaultTypeInternal;
extern ProductDefaultTypeInternal _Product_default_instance_;
class StretchSensorData;
struct StretchSensorDataDefaultTypeInternal;
extern StretchSensorDataDefaultTypeInternal _StretchSensorData_default_instance_;
class TimeData;
struct TimeDataDefaultTypeInternal;
extern TimeDataDefaultTypeInternal _TimeData_default_instance_;
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template <>
::handEngine::v1::AggregateMessage* Arena::CreateMaybeMessage<::handEngine::v1::AggregateMessage>(Arena*);
template <>
::handEngine::v1::CommandPacket* Arena::CreateMaybeMessage<::handEngine::v1::CommandPacket>(Arena*);
template <>
::handEngine::v1::DeviceCommand* Arena::CreateMaybeMessage<::handEngine::v1::DeviceCommand>(Arena*);
template <>
::handEngine::v1::DeviceEvent* Arena::CreateMaybeMessage<::handEngine::v1::DeviceEvent>(Arena*);
template <>
::handEngine::v1::DeviceInformation* Arena::CreateMaybeMessage<::handEngine::v1::DeviceInformation>(Arena*);
template <>
::handEngine::v1::DeviceMessage* Arena::CreateMaybeMessage<::handEngine::v1::DeviceMessage>(Arena*);
template <>
::handEngine::v1::DeviceProperty* Arena::CreateMaybeMessage<::handEngine::v1::DeviceProperty>(Arena*);
template <>
::handEngine::v1::DfuData* Arena::CreateMaybeMessage<::handEngine::v1::DfuData>(Arena*);
template <>
::handEngine::v1::FirmwareData* Arena::CreateMaybeMessage<::handEngine::v1::FirmwareData>(Arena*);
template <>
::handEngine::v1::ImuData* Arena::CreateMaybeMessage<::handEngine::v1::ImuData>(Arena*);
template <>
::handEngine::v1::ManufacturingData* Arena::CreateMaybeMessage<::handEngine::v1::ManufacturingData>(Arena*);
template <>
::handEngine::v1::PeripheralState* Arena::CreateMaybeMessage<::handEngine::v1::PeripheralState>(Arena*);
template <>
::handEngine::v1::Product* Arena::CreateMaybeMessage<::handEngine::v1::Product>(Arena*);
template <>
::handEngine::v1::StretchSensorData* Arena::CreateMaybeMessage<::handEngine::v1::StretchSensorData>(Arena*);
template <>
::handEngine::v1::TimeData* Arena::CreateMaybeMessage<::handEngine::v1::TimeData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace handEngine {
namespace v1 {
enum DeviceType : int {
  UNKNOWN_DEVICE_TYPE = 0,
  DONGLE = 1,
  GLOVE = 2,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = static_cast<DeviceType>(0);
constexpr DeviceType DeviceType_MAX = static_cast<DeviceType>(2);
constexpr int DeviceType_ARRAYSIZE = 2 + 1;
const std::string& DeviceType_Name(DeviceType value);
template <typename T>
const std::string& DeviceType_Name(T value) {
  static_assert(std::is_same<T, DeviceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceType_Name().");
  return DeviceType_Name(static_cast<DeviceType>(value));
}
const std::string& DeviceType_Name(DeviceType value);
bool DeviceType_Parse(absl::string_view name, DeviceType* value);
enum DeviceLocation : int {
  UNKNOWN_LOCATION = 0,
  LEFT_HAND = 1,
  RIGHT_HAND = 2,
  USB = 3,
  DeviceLocation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeviceLocation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeviceLocation_IsValid(int value);
constexpr DeviceLocation DeviceLocation_MIN = static_cast<DeviceLocation>(0);
constexpr DeviceLocation DeviceLocation_MAX = static_cast<DeviceLocation>(3);
constexpr int DeviceLocation_ARRAYSIZE = 3 + 1;
const std::string& DeviceLocation_Name(DeviceLocation value);
template <typename T>
const std::string& DeviceLocation_Name(T value) {
  static_assert(std::is_same<T, DeviceLocation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceLocation_Name().");
  return DeviceLocation_Name(static_cast<DeviceLocation>(value));
}
const std::string& DeviceLocation_Name(DeviceLocation value);
bool DeviceLocation_Parse(absl::string_view name, DeviceLocation* value);
enum ProductFamily : int {
  UNKNOWN_DEVICE_REVISION = 0,
  REV_E = 1,
  REV_F = 2,
  REV_G = 3,
  ProductFamily_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProductFamily_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProductFamily_IsValid(int value);
constexpr ProductFamily ProductFamily_MIN = static_cast<ProductFamily>(0);
constexpr ProductFamily ProductFamily_MAX = static_cast<ProductFamily>(3);
constexpr int ProductFamily_ARRAYSIZE = 3 + 1;
const std::string& ProductFamily_Name(ProductFamily value);
template <typename T>
const std::string& ProductFamily_Name(T value) {
  static_assert(std::is_same<T, ProductFamily>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProductFamily_Name().");
  return ProductFamily_Name(static_cast<ProductFamily>(value));
}
const std::string& ProductFamily_Name(ProductFamily value);
bool ProductFamily_Parse(absl::string_view name, ProductFamily* value);
enum PropertyType : int {
  DEVICE_SIZE = 0,
  COLOR = 1,
  MATERIAL = 2,
  PropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PropertyType_IsValid(int value);
constexpr PropertyType PropertyType_MIN = static_cast<PropertyType>(0);
constexpr PropertyType PropertyType_MAX = static_cast<PropertyType>(2);
constexpr int PropertyType_ARRAYSIZE = 2 + 1;
const std::string& PropertyType_Name(PropertyType value);
template <typename T>
const std::string& PropertyType_Name(T value) {
  static_assert(std::is_same<T, PropertyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PropertyType_Name().");
  return PropertyType_Name(static_cast<PropertyType>(value));
}
const std::string& PropertyType_Name(PropertyType value);
bool PropertyType_Parse(absl::string_view name, PropertyType* value);
enum CommandCode : int {
  UNKNOWN_DEVICE_COMMAND_CODE = 0,
  GET_FULL_DEVICE_INFO = 1,
  JAMSYNC_DEVICE = 2,
  SEND_TAKE_META_DATA = 3,
  START_RECORDING = 4,
  STOP_RECORDING = 5,
  TEST_ASIC = 6,
  TEST_FRAM = 7,
  UNLOCK_DEVICE = 8,
  PROGRAM_DEVICE_INFO = 9,
  PROGRAM_SERIAL_NUMBER = 10,
  SET_DEVICE_NAME = 11,
  DFU_START = 12,
  DFU_IN_PROGRESS = 13,
  DFU_FINISHED = 14,
  SET_TOKEN = 15,
  ACTIVATE_HAPTICS = 16,
  CUSTOM_COMMAND = 99,
  CommandCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommandCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommandCode_IsValid(int value);
constexpr CommandCode CommandCode_MIN = static_cast<CommandCode>(0);
constexpr CommandCode CommandCode_MAX = static_cast<CommandCode>(99);
constexpr int CommandCode_ARRAYSIZE = 99 + 1;
const std::string& CommandCode_Name(CommandCode value);
template <typename T>
const std::string& CommandCode_Name(T value) {
  static_assert(std::is_same<T, CommandCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CommandCode_Name().");
  return CommandCode_Name(static_cast<CommandCode>(value));
}
const std::string& CommandCode_Name(CommandCode value);
bool CommandCode_Parse(absl::string_view name, CommandCode* value);
enum Event : int {
  UNKNOWN_EVENT = 0,
  LOW_BATTERY = 1,
  DEAD_BATTERY = 2,
  CONNECTED = 3,
  DISCONNECTED = 4,
  SENSOR_FAULT = 5,
  TOKEN_REQUEST = 6,
  DFU_READY = 7,
  DEBUG_LOG = 99,
  Event_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Event_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Event_IsValid(int value);
constexpr Event Event_MIN = static_cast<Event>(0);
constexpr Event Event_MAX = static_cast<Event>(99);
constexpr int Event_ARRAYSIZE = 99 + 1;
const std::string& Event_Name(Event value);
template <typename T>
const std::string& Event_Name(T value) {
  static_assert(std::is_same<T, Event>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Event_Name().");
  return Event_Name(static_cast<Event>(value));
}
const std::string& Event_Name(Event value);
bool Event_Parse(absl::string_view name, Event* value);

// ===================================================================


// -------------------------------------------------------------------

class Product final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.Product) */ {
 public:
  inline Product() : Product(nullptr) {}
  ~Product() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Product(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Product(const Product& from);
  Product(Product&& from) noexcept
    : Product() {
    *this = ::std::move(from);
  }

  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  inline Product& operator=(Product&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Product& default_instance() {
    return *internal_default_instance();
  }
  static inline const Product* internal_default_instance() {
    return reinterpret_cast<const Product*>(
               &_Product_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Product& a, Product& b) {
    a.Swap(&b);
  }
  inline void Swap(Product* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Product* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Product* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Product>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Product& from);
  void MergeFrom(const Product& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Product* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.Product";
  }
  protected:
  explicit Product(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductCodeFieldNumber = 2,
    kProductFamilyFieldNumber = 1,
  };
  // optional string productCode = 2;
  bool has_productcode() const;
  void clear_productcode() ;
  const std::string& productcode() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productcode(Arg_&& arg, Args_... args);
  std::string* mutable_productcode();
  PROTOBUF_NODISCARD std::string* release_productcode();
  void set_allocated_productcode(std::string* ptr);

  private:
  const std::string& _internal_productcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productcode(
      const std::string& value);
  std::string* _internal_mutable_productcode();

  public:
  // .handEngine.v1.ProductFamily productFamily = 1;
  void clear_productfamily() ;
  ::handEngine::v1::ProductFamily productfamily() const;
  void set_productfamily(::handEngine::v1::ProductFamily value);

  private:
  ::handEngine::v1::ProductFamily _internal_productfamily() const;
  void _internal_set_productfamily(::handEngine::v1::ProductFamily value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.Product)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productcode_;
    int productfamily_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class DeviceProperty final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceProperty) */ {
 public:
  inline DeviceProperty() : DeviceProperty(nullptr) {}
  ~DeviceProperty() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceProperty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceProperty(const DeviceProperty& from);
  DeviceProperty(DeviceProperty&& from) noexcept
    : DeviceProperty() {
    *this = ::std::move(from);
  }

  inline DeviceProperty& operator=(const DeviceProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceProperty& operator=(DeviceProperty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceProperty& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceProperty* internal_default_instance() {
    return reinterpret_cast<const DeviceProperty*>(
               &_DeviceProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceProperty& a, DeviceProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceProperty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceProperty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceProperty>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceProperty& from);
  void MergeFrom(const DeviceProperty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceProperty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceProperty";
  }
  protected:
  explicit DeviceProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .handEngine.v1.PropertyType type = 1;
  void clear_type() ;
  ::handEngine::v1::PropertyType type() const;
  void set_type(::handEngine::v1::PropertyType value);

  private:
  ::handEngine::v1::PropertyType _internal_type() const;
  void _internal_set_type(::handEngine::v1::PropertyType value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceProperty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class FirmwareData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.FirmwareData) */ {
 public:
  inline FirmwareData() : FirmwareData(nullptr) {}
  ~FirmwareData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FirmwareData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirmwareData(const FirmwareData& from);
  FirmwareData(FirmwareData&& from) noexcept
    : FirmwareData() {
    *this = ::std::move(from);
  }

  inline FirmwareData& operator=(const FirmwareData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirmwareData& operator=(FirmwareData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FirmwareData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirmwareData* internal_default_instance() {
    return reinterpret_cast<const FirmwareData*>(
               &_FirmwareData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FirmwareData& a, FirmwareData& b) {
    a.Swap(&b);
  }
  inline void Swap(FirmwareData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirmwareData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FirmwareData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FirmwareData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FirmwareData& from);
  void MergeFrom(const FirmwareData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FirmwareData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.FirmwareData";
  }
  protected:
  explicit FirmwareData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartNameFieldNumber = 1,
    kMajorFieldNumber = 2,
    kMinorFieldNumber = 3,
    kBugfixFieldNumber = 4,
  };
  // string partName = 1;
  void clear_partname() ;
  const std::string& partname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partname(Arg_&& arg, Args_... args);
  std::string* mutable_partname();
  PROTOBUF_NODISCARD std::string* release_partname();
  void set_allocated_partname(std::string* ptr);

  private:
  const std::string& _internal_partname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partname(
      const std::string& value);
  std::string* _internal_mutable_partname();

  public:
  // uint32 major = 2;
  void clear_major() ;
  ::uint32_t major() const;
  void set_major(::uint32_t value);

  private:
  ::uint32_t _internal_major() const;
  void _internal_set_major(::uint32_t value);

  public:
  // uint32 minor = 3;
  void clear_minor() ;
  ::uint32_t minor() const;
  void set_minor(::uint32_t value);

  private:
  ::uint32_t _internal_minor() const;
  void _internal_set_minor(::uint32_t value);

  public:
  // uint32 bugfix = 4;
  void clear_bugfix() ;
  ::uint32_t bugfix() const;
  void set_bugfix(::uint32_t value);

  private:
  ::uint32_t _internal_bugfix() const;
  void _internal_set_bugfix(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.FirmwareData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partname_;
    ::uint32_t major_;
    ::uint32_t minor_;
    ::uint32_t bugfix_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class ManufacturingData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.ManufacturingData) */ {
 public:
  inline ManufacturingData() : ManufacturingData(nullptr) {}
  ~ManufacturingData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ManufacturingData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManufacturingData(const ManufacturingData& from);
  ManufacturingData(ManufacturingData&& from) noexcept
    : ManufacturingData() {
    *this = ::std::move(from);
  }

  inline ManufacturingData& operator=(const ManufacturingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManufacturingData& operator=(ManufacturingData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ManufacturingData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManufacturingData* internal_default_instance() {
    return reinterpret_cast<const ManufacturingData*>(
               &_ManufacturingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ManufacturingData& a, ManufacturingData& b) {
    a.Swap(&b);
  }
  inline void Swap(ManufacturingData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManufacturingData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManufacturingData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManufacturingData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ManufacturingData& from);
  void MergeFrom(const ManufacturingData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ManufacturingData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.ManufacturingData";
  }
  protected:
  explicit ManufacturingData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartNumberFieldNumber = 1,
    kRevisionFieldNumber = 2,
    kMonthOfManufactureFieldNumber = 3,
    kYearOfManufactureFieldNumber = 4,
    kBatchNumberFieldNumber = 5,
  };
  // string partNumber = 1;
  void clear_partnumber() ;
  const std::string& partnumber() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partnumber(Arg_&& arg, Args_... args);
  std::string* mutable_partnumber();
  PROTOBUF_NODISCARD std::string* release_partnumber();
  void set_allocated_partnumber(std::string* ptr);

  private:
  const std::string& _internal_partnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partnumber(
      const std::string& value);
  std::string* _internal_mutable_partnumber();

  public:
  // string revision = 2;
  void clear_revision() ;
  const std::string& revision() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_revision(Arg_&& arg, Args_... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* ptr);

  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(
      const std::string& value);
  std::string* _internal_mutable_revision();

  public:
  // uint32 monthOfManufacture = 3;
  void clear_monthofmanufacture() ;
  ::uint32_t monthofmanufacture() const;
  void set_monthofmanufacture(::uint32_t value);

  private:
  ::uint32_t _internal_monthofmanufacture() const;
  void _internal_set_monthofmanufacture(::uint32_t value);

  public:
  // uint32 yearOfManufacture = 4;
  void clear_yearofmanufacture() ;
  ::uint32_t yearofmanufacture() const;
  void set_yearofmanufacture(::uint32_t value);

  private:
  ::uint32_t _internal_yearofmanufacture() const;
  void _internal_set_yearofmanufacture(::uint32_t value);

  public:
  // uint32 batchNumber = 5;
  void clear_batchnumber() ;
  ::uint32_t batchnumber() const;
  void set_batchnumber(::uint32_t value);

  private:
  ::uint32_t _internal_batchnumber() const;
  void _internal_set_batchnumber(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.ManufacturingData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
    ::uint32_t monthofmanufacture_;
    ::uint32_t yearofmanufacture_;
    ::uint32_t batchnumber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class StretchSensorData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.StretchSensorData) */ {
 public:
  inline StretchSensorData() : StretchSensorData(nullptr) {}
  ~StretchSensorData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StretchSensorData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StretchSensorData(const StretchSensorData& from);
  StretchSensorData(StretchSensorData&& from) noexcept
    : StretchSensorData() {
    *this = ::std::move(from);
  }

  inline StretchSensorData& operator=(const StretchSensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StretchSensorData& operator=(StretchSensorData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StretchSensorData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StretchSensorData* internal_default_instance() {
    return reinterpret_cast<const StretchSensorData*>(
               &_StretchSensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StretchSensorData& a, StretchSensorData& b) {
    a.Swap(&b);
  }
  inline void Swap(StretchSensorData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StretchSensorData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StretchSensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StretchSensorData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StretchSensorData& from);
  void MergeFrom(const StretchSensorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StretchSensorData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.StretchSensorData";
  }
  protected:
  explicit StretchSensorData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThumbThumbsideFieldNumber = 1,
    kThumbMidFieldNumber = 2,
    kThumbPinkysideFieldNumber = 3,
    kDorsalThumbExtensionFieldNumber = 4,
    kIndexThumbsideFieldNumber = 5,
    kIndexMidFieldNumber = 6,
    kIndexPinkysideFieldNumber = 7,
    kMiddleThumbsideFieldNumber = 8,
    kMiddleMidFieldNumber = 9,
    kMiddlePinkysideFieldNumber = 10,
    kRingThumbsideFieldNumber = 11,
    kRingMidFieldNumber = 12,
    kRingPinkysideFieldNumber = 13,
    kPinkyThumbsideFieldNumber = 14,
    kPinkyMidFieldNumber = 15,
    kPinkyPinkysideFieldNumber = 16,
  };
  // optional uint32 thumbThumbside = 1;
  bool has_thumbthumbside() const;
  void clear_thumbthumbside() ;
  ::uint32_t thumbthumbside() const;
  void set_thumbthumbside(::uint32_t value);

  private:
  ::uint32_t _internal_thumbthumbside() const;
  void _internal_set_thumbthumbside(::uint32_t value);

  public:
  // optional uint32 thumbMid = 2;
  bool has_thumbmid() const;
  void clear_thumbmid() ;
  ::uint32_t thumbmid() const;
  void set_thumbmid(::uint32_t value);

  private:
  ::uint32_t _internal_thumbmid() const;
  void _internal_set_thumbmid(::uint32_t value);

  public:
  // optional uint32 thumbPinkyside = 3;
  bool has_thumbpinkyside() const;
  void clear_thumbpinkyside() ;
  ::uint32_t thumbpinkyside() const;
  void set_thumbpinkyside(::uint32_t value);

  private:
  ::uint32_t _internal_thumbpinkyside() const;
  void _internal_set_thumbpinkyside(::uint32_t value);

  public:
  // optional uint32 dorsalThumbExtension = 4;
  bool has_dorsalthumbextension() const;
  void clear_dorsalthumbextension() ;
  ::uint32_t dorsalthumbextension() const;
  void set_dorsalthumbextension(::uint32_t value);

  private:
  ::uint32_t _internal_dorsalthumbextension() const;
  void _internal_set_dorsalthumbextension(::uint32_t value);

  public:
  // optional uint32 indexThumbside = 5;
  bool has_indexthumbside() const;
  void clear_indexthumbside() ;
  ::uint32_t indexthumbside() const;
  void set_indexthumbside(::uint32_t value);

  private:
  ::uint32_t _internal_indexthumbside() const;
  void _internal_set_indexthumbside(::uint32_t value);

  public:
  // optional uint32 indexMid = 6;
  bool has_indexmid() const;
  void clear_indexmid() ;
  ::uint32_t indexmid() const;
  void set_indexmid(::uint32_t value);

  private:
  ::uint32_t _internal_indexmid() const;
  void _internal_set_indexmid(::uint32_t value);

  public:
  // optional uint32 indexPinkyside = 7;
  bool has_indexpinkyside() const;
  void clear_indexpinkyside() ;
  ::uint32_t indexpinkyside() const;
  void set_indexpinkyside(::uint32_t value);

  private:
  ::uint32_t _internal_indexpinkyside() const;
  void _internal_set_indexpinkyside(::uint32_t value);

  public:
  // optional uint32 middleThumbside = 8;
  bool has_middlethumbside() const;
  void clear_middlethumbside() ;
  ::uint32_t middlethumbside() const;
  void set_middlethumbside(::uint32_t value);

  private:
  ::uint32_t _internal_middlethumbside() const;
  void _internal_set_middlethumbside(::uint32_t value);

  public:
  // optional uint32 middleMid = 9;
  bool has_middlemid() const;
  void clear_middlemid() ;
  ::uint32_t middlemid() const;
  void set_middlemid(::uint32_t value);

  private:
  ::uint32_t _internal_middlemid() const;
  void _internal_set_middlemid(::uint32_t value);

  public:
  // optional uint32 middlePinkyside = 10;
  bool has_middlepinkyside() const;
  void clear_middlepinkyside() ;
  ::uint32_t middlepinkyside() const;
  void set_middlepinkyside(::uint32_t value);

  private:
  ::uint32_t _internal_middlepinkyside() const;
  void _internal_set_middlepinkyside(::uint32_t value);

  public:
  // optional uint32 ringThumbside = 11;
  bool has_ringthumbside() const;
  void clear_ringthumbside() ;
  ::uint32_t ringthumbside() const;
  void set_ringthumbside(::uint32_t value);

  private:
  ::uint32_t _internal_ringthumbside() const;
  void _internal_set_ringthumbside(::uint32_t value);

  public:
  // optional uint32 ringMid = 12;
  bool has_ringmid() const;
  void clear_ringmid() ;
  ::uint32_t ringmid() const;
  void set_ringmid(::uint32_t value);

  private:
  ::uint32_t _internal_ringmid() const;
  void _internal_set_ringmid(::uint32_t value);

  public:
  // optional uint32 ringPinkyside = 13;
  bool has_ringpinkyside() const;
  void clear_ringpinkyside() ;
  ::uint32_t ringpinkyside() const;
  void set_ringpinkyside(::uint32_t value);

  private:
  ::uint32_t _internal_ringpinkyside() const;
  void _internal_set_ringpinkyside(::uint32_t value);

  public:
  // optional uint32 pinkyThumbside = 14;
  bool has_pinkythumbside() const;
  void clear_pinkythumbside() ;
  ::uint32_t pinkythumbside() const;
  void set_pinkythumbside(::uint32_t value);

  private:
  ::uint32_t _internal_pinkythumbside() const;
  void _internal_set_pinkythumbside(::uint32_t value);

  public:
  // optional uint32 pinkyMid = 15;
  bool has_pinkymid() const;
  void clear_pinkymid() ;
  ::uint32_t pinkymid() const;
  void set_pinkymid(::uint32_t value);

  private:
  ::uint32_t _internal_pinkymid() const;
  void _internal_set_pinkymid(::uint32_t value);

  public:
  // optional uint32 pinkyPinkyside = 16;
  bool has_pinkypinkyside() const;
  void clear_pinkypinkyside() ;
  ::uint32_t pinkypinkyside() const;
  void set_pinkypinkyside(::uint32_t value);

  private:
  ::uint32_t _internal_pinkypinkyside() const;
  void _internal_set_pinkypinkyside(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.StretchSensorData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t thumbthumbside_;
    ::uint32_t thumbmid_;
    ::uint32_t thumbpinkyside_;
    ::uint32_t dorsalthumbextension_;
    ::uint32_t indexthumbside_;
    ::uint32_t indexmid_;
    ::uint32_t indexpinkyside_;
    ::uint32_t middlethumbside_;
    ::uint32_t middlemid_;
    ::uint32_t middlepinkyside_;
    ::uint32_t ringthumbside_;
    ::uint32_t ringmid_;
    ::uint32_t ringpinkyside_;
    ::uint32_t pinkythumbside_;
    ::uint32_t pinkymid_;
    ::uint32_t pinkypinkyside_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class DeviceInformation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceInformation) */ {
 public:
  inline DeviceInformation() : DeviceInformation(nullptr) {}
  ~DeviceInformation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInformation(const DeviceInformation& from);
  DeviceInformation(DeviceInformation&& from) noexcept
    : DeviceInformation() {
    *this = ::std::move(from);
  }

  inline DeviceInformation& operator=(const DeviceInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInformation& operator=(DeviceInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInformation* internal_default_instance() {
    return reinterpret_cast<const DeviceInformation*>(
               &_DeviceInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeviceInformation& a, DeviceInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInformation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInformation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceInformation& from);
  void MergeFrom(const DeviceInformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceInformation";
  }
  protected:
  explicit DeviceInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturingDataFieldNumber = 6,
    kPropertiesFieldNumber = 7,
    kNameFieldNumber = 5,
    kProductFieldNumber = 2,
    kSizeFieldNumber = 3,
    kFirmwareDataFieldNumber = 8,
    kBaseCapacitancesFieldNumber = 9,
    kSensorSensitivityFieldNumber = 10,
    kDeviceTypeFieldNumber = 1,
    kLocationFieldNumber = 4,
  };
  // repeated .handEngine.v1.ManufacturingData manufacturingData = 6;
  int manufacturingdata_size() const;
  private:
  int _internal_manufacturingdata_size() const;

  public:
  void clear_manufacturingdata() ;
  ::handEngine::v1::ManufacturingData* mutable_manufacturingdata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::ManufacturingData >*
      mutable_manufacturingdata();
  private:
  const ::handEngine::v1::ManufacturingData& _internal_manufacturingdata(int index) const;
  ::handEngine::v1::ManufacturingData* _internal_add_manufacturingdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::ManufacturingData>& _internal_manufacturingdata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::ManufacturingData>* _internal_mutable_manufacturingdata();
  public:
  const ::handEngine::v1::ManufacturingData& manufacturingdata(int index) const;
  ::handEngine::v1::ManufacturingData* add_manufacturingdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::ManufacturingData >&
      manufacturingdata() const;
  // repeated .handEngine.v1.DeviceProperty properties = 7;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  ::handEngine::v1::DeviceProperty* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceProperty >*
      mutable_properties();
  private:
  const ::handEngine::v1::DeviceProperty& _internal_properties(int index) const;
  ::handEngine::v1::DeviceProperty* _internal_add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceProperty>& _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceProperty>* _internal_mutable_properties();
  public:
  const ::handEngine::v1::DeviceProperty& properties(int index) const;
  ::handEngine::v1::DeviceProperty* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceProperty >&
      properties() const;
  // optional string name = 5;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .handEngine.v1.Product product = 2;
  bool has_product() const;
  void clear_product() ;
  const ::handEngine::v1::Product& product() const;
  PROTOBUF_NODISCARD ::handEngine::v1::Product* release_product();
  ::handEngine::v1::Product* mutable_product();
  void set_allocated_product(::handEngine::v1::Product* product);
  private:
  const ::handEngine::v1::Product& _internal_product() const;
  ::handEngine::v1::Product* _internal_mutable_product();
  public:
  void unsafe_arena_set_allocated_product(
      ::handEngine::v1::Product* product);
  ::handEngine::v1::Product* unsafe_arena_release_product();
  // optional .handEngine.v1.DeviceProperty size = 3;
  bool has_size() const;
  void clear_size() ;
  const ::handEngine::v1::DeviceProperty& size() const;
  PROTOBUF_NODISCARD ::handEngine::v1::DeviceProperty* release_size();
  ::handEngine::v1::DeviceProperty* mutable_size();
  void set_allocated_size(::handEngine::v1::DeviceProperty* size);
  private:
  const ::handEngine::v1::DeviceProperty& _internal_size() const;
  ::handEngine::v1::DeviceProperty* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::handEngine::v1::DeviceProperty* size);
  ::handEngine::v1::DeviceProperty* unsafe_arena_release_size();
  // optional .handEngine.v1.FirmwareData firmwareData = 8;
  bool has_firmwaredata() const;
  void clear_firmwaredata() ;
  const ::handEngine::v1::FirmwareData& firmwaredata() const;
  PROTOBUF_NODISCARD ::handEngine::v1::FirmwareData* release_firmwaredata();
  ::handEngine::v1::FirmwareData* mutable_firmwaredata();
  void set_allocated_firmwaredata(::handEngine::v1::FirmwareData* firmwaredata);
  private:
  const ::handEngine::v1::FirmwareData& _internal_firmwaredata() const;
  ::handEngine::v1::FirmwareData* _internal_mutable_firmwaredata();
  public:
  void unsafe_arena_set_allocated_firmwaredata(
      ::handEngine::v1::FirmwareData* firmwaredata);
  ::handEngine::v1::FirmwareData* unsafe_arena_release_firmwaredata();
  // optional .handEngine.v1.StretchSensorData baseCapacitances = 9;
  bool has_basecapacitances() const;
  void clear_basecapacitances() ;
  const ::handEngine::v1::StretchSensorData& basecapacitances() const;
  PROTOBUF_NODISCARD ::handEngine::v1::StretchSensorData* release_basecapacitances();
  ::handEngine::v1::StretchSensorData* mutable_basecapacitances();
  void set_allocated_basecapacitances(::handEngine::v1::StretchSensorData* basecapacitances);
  private:
  const ::handEngine::v1::StretchSensorData& _internal_basecapacitances() const;
  ::handEngine::v1::StretchSensorData* _internal_mutable_basecapacitances();
  public:
  void unsafe_arena_set_allocated_basecapacitances(
      ::handEngine::v1::StretchSensorData* basecapacitances);
  ::handEngine::v1::StretchSensorData* unsafe_arena_release_basecapacitances();
  // optional .handEngine.v1.StretchSensorData sensorSensitivity = 10;
  bool has_sensorsensitivity() const;
  void clear_sensorsensitivity() ;
  const ::handEngine::v1::StretchSensorData& sensorsensitivity() const;
  PROTOBUF_NODISCARD ::handEngine::v1::StretchSensorData* release_sensorsensitivity();
  ::handEngine::v1::StretchSensorData* mutable_sensorsensitivity();
  void set_allocated_sensorsensitivity(::handEngine::v1::StretchSensorData* sensorsensitivity);
  private:
  const ::handEngine::v1::StretchSensorData& _internal_sensorsensitivity() const;
  ::handEngine::v1::StretchSensorData* _internal_mutable_sensorsensitivity();
  public:
  void unsafe_arena_set_allocated_sensorsensitivity(
      ::handEngine::v1::StretchSensorData* sensorsensitivity);
  ::handEngine::v1::StretchSensorData* unsafe_arena_release_sensorsensitivity();
  // optional .handEngine.v1.DeviceType deviceType = 1;
  bool has_devicetype() const;
  void clear_devicetype() ;
  ::handEngine::v1::DeviceType devicetype() const;
  void set_devicetype(::handEngine::v1::DeviceType value);

  private:
  ::handEngine::v1::DeviceType _internal_devicetype() const;
  void _internal_set_devicetype(::handEngine::v1::DeviceType value);

  public:
  // optional .handEngine.v1.DeviceLocation location = 4;
  bool has_location() const;
  void clear_location() ;
  ::handEngine::v1::DeviceLocation location() const;
  void set_location(::handEngine::v1::DeviceLocation value);

  private:
  ::handEngine::v1::DeviceLocation _internal_location() const;
  void _internal_set_location(::handEngine::v1::DeviceLocation value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::ManufacturingData > manufacturingdata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceProperty > properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::handEngine::v1::Product* product_;
    ::handEngine::v1::DeviceProperty* size_;
    ::handEngine::v1::FirmwareData* firmwaredata_;
    ::handEngine::v1::StretchSensorData* basecapacitances_;
    ::handEngine::v1::StretchSensorData* sensorsensitivity_;
    int devicetype_;
    int location_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class ImuData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.ImuData) */ {
 public:
  inline ImuData() : ImuData(nullptr) {}
  ~ImuData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ImuData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuData(const ImuData& from);
  ImuData(ImuData&& from) noexcept
    : ImuData() {
    *this = ::std::move(from);
  }

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuData& operator=(ImuData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ImuData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuData* internal_default_instance() {
    return reinterpret_cast<const ImuData*>(
               &_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ImuData& a, ImuData& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImuData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImuData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImuData& from);
  void MergeFrom(const ImuData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImuData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.ImuData";
  }
  protected:
  explicit ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelXFieldNumber = 1,
    kAccelYFieldNumber = 2,
    kAccelZFieldNumber = 3,
    kGyroXFieldNumber = 4,
    kGyroYFieldNumber = 5,
    kGyroZFieldNumber = 6,
    kMagXFieldNumber = 7,
    kMagYFieldNumber = 8,
    kMagZFieldNumber = 9,
    kTemperatureFieldNumber = 10,
  };
  // optional uint32 accelX = 1;
  bool has_accelx() const;
  void clear_accelx() ;
  ::uint32_t accelx() const;
  void set_accelx(::uint32_t value);

  private:
  ::uint32_t _internal_accelx() const;
  void _internal_set_accelx(::uint32_t value);

  public:
  // optional uint32 accelY = 2;
  bool has_accely() const;
  void clear_accely() ;
  ::uint32_t accely() const;
  void set_accely(::uint32_t value);

  private:
  ::uint32_t _internal_accely() const;
  void _internal_set_accely(::uint32_t value);

  public:
  // optional uint32 accelZ = 3;
  bool has_accelz() const;
  void clear_accelz() ;
  ::uint32_t accelz() const;
  void set_accelz(::uint32_t value);

  private:
  ::uint32_t _internal_accelz() const;
  void _internal_set_accelz(::uint32_t value);

  public:
  // optional uint32 gyroX = 4;
  bool has_gyrox() const;
  void clear_gyrox() ;
  ::uint32_t gyrox() const;
  void set_gyrox(::uint32_t value);

  private:
  ::uint32_t _internal_gyrox() const;
  void _internal_set_gyrox(::uint32_t value);

  public:
  // optional uint32 gyroY = 5;
  bool has_gyroy() const;
  void clear_gyroy() ;
  ::uint32_t gyroy() const;
  void set_gyroy(::uint32_t value);

  private:
  ::uint32_t _internal_gyroy() const;
  void _internal_set_gyroy(::uint32_t value);

  public:
  // optional uint32 gyroZ = 6;
  bool has_gyroz() const;
  void clear_gyroz() ;
  ::uint32_t gyroz() const;
  void set_gyroz(::uint32_t value);

  private:
  ::uint32_t _internal_gyroz() const;
  void _internal_set_gyroz(::uint32_t value);

  public:
  // optional uint32 magX = 7;
  bool has_magx() const;
  void clear_magx() ;
  ::uint32_t magx() const;
  void set_magx(::uint32_t value);

  private:
  ::uint32_t _internal_magx() const;
  void _internal_set_magx(::uint32_t value);

  public:
  // optional uint32 magY = 8;
  bool has_magy() const;
  void clear_magy() ;
  ::uint32_t magy() const;
  void set_magy(::uint32_t value);

  private:
  ::uint32_t _internal_magy() const;
  void _internal_set_magy(::uint32_t value);

  public:
  // optional uint32 magZ = 9;
  bool has_magz() const;
  void clear_magz() ;
  ::uint32_t magz() const;
  void set_magz(::uint32_t value);

  private:
  ::uint32_t _internal_magz() const;
  void _internal_set_magz(::uint32_t value);

  public:
  // optional uint32 temperature = 10;
  bool has_temperature() const;
  void clear_temperature() ;
  ::uint32_t temperature() const;
  void set_temperature(::uint32_t value);

  private:
  ::uint32_t _internal_temperature() const;
  void _internal_set_temperature(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.ImuData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t accelx_;
    ::uint32_t accely_;
    ::uint32_t accelz_;
    ::uint32_t gyrox_;
    ::uint32_t gyroy_;
    ::uint32_t gyroz_;
    ::uint32_t magx_;
    ::uint32_t magy_;
    ::uint32_t magz_;
    ::uint32_t temperature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class TimeData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.TimeData) */ {
 public:
  inline TimeData() : TimeData(nullptr) {}
  ~TimeData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeData(const TimeData& from);
  TimeData(TimeData&& from) noexcept
    : TimeData() {
    *this = ::std::move(from);
  }

  inline TimeData& operator=(const TimeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeData& operator=(TimeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeData* internal_default_instance() {
    return reinterpret_cast<const TimeData*>(
               &_TimeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TimeData& a, TimeData& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimeData& from);
  void MergeFrom(const TimeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.TimeData";
  }
  protected:
  explicit TimeData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInternalMsTimeFieldNumber = 1,
    kTimeCodeFieldNumber = 2,
  };
  // uint32 internalMsTime = 1;
  void clear_internalmstime() ;
  ::uint32_t internalmstime() const;
  void set_internalmstime(::uint32_t value);

  private:
  ::uint32_t _internal_internalmstime() const;
  void _internal_set_internalmstime(::uint32_t value);

  public:
  // uint32 timeCode = 2;
  void clear_timecode() ;
  ::uint32_t timecode() const;
  void set_timecode(::uint32_t value);

  private:
  ::uint32_t _internal_timecode() const;
  void _internal_set_timecode(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.TimeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t internalmstime_;
    ::uint32_t timecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class PeripheralState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.PeripheralState) */ {
 public:
  inline PeripheralState() : PeripheralState(nullptr) {}
  ~PeripheralState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PeripheralState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeripheralState(const PeripheralState& from);
  PeripheralState(PeripheralState&& from) noexcept
    : PeripheralState() {
    *this = ::std::move(from);
  }

  inline PeripheralState& operator=(const PeripheralState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeripheralState& operator=(PeripheralState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PeripheralState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeripheralState* internal_default_instance() {
    return reinterpret_cast<const PeripheralState*>(
               &_PeripheralState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PeripheralState& a, PeripheralState& b) {
    a.Swap(&b);
  }
  inline void Swap(PeripheralState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeripheralState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeripheralState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeripheralState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PeripheralState& from);
  void MergeFrom(const PeripheralState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeripheralState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.PeripheralState";
  }
  protected:
  explicit PeripheralState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryLevelFieldNumber = 1,
    kTimeSinceLastJamsyncFieldNumber = 2,
    kSdCardPresenceFieldNumber = 3,
    kSdCardRecordingFieldNumber = 4,
  };
  // uint32 batteryLevel = 1;
  void clear_batterylevel() ;
  ::uint32_t batterylevel() const;
  void set_batterylevel(::uint32_t value);

  private:
  ::uint32_t _internal_batterylevel() const;
  void _internal_set_batterylevel(::uint32_t value);

  public:
  // uint32 timeSinceLastJamsync = 2;
  void clear_timesincelastjamsync() ;
  ::uint32_t timesincelastjamsync() const;
  void set_timesincelastjamsync(::uint32_t value);

  private:
  ::uint32_t _internal_timesincelastjamsync() const;
  void _internal_set_timesincelastjamsync(::uint32_t value);

  public:
  // optional bool sdCardPresence = 3;
  bool has_sdcardpresence() const;
  void clear_sdcardpresence() ;
  bool sdcardpresence() const;
  void set_sdcardpresence(bool value);

  private:
  bool _internal_sdcardpresence() const;
  void _internal_set_sdcardpresence(bool value);

  public:
  // optional bool sdCardRecording = 4;
  bool has_sdcardrecording() const;
  void clear_sdcardrecording() ;
  bool sdcardrecording() const;
  void set_sdcardrecording(bool value);

  private:
  bool _internal_sdcardrecording() const;
  void _internal_set_sdcardrecording(bool value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.PeripheralState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t batterylevel_;
    ::uint32_t timesincelastjamsync_;
    bool sdcardpresence_;
    bool sdcardrecording_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class CommandPacket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.CommandPacket) */ {
 public:
  inline CommandPacket() : CommandPacket(nullptr) {}
  ~CommandPacket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandPacket(const CommandPacket& from);
  CommandPacket(CommandPacket&& from) noexcept
    : CommandPacket() {
    *this = ::std::move(from);
  }

  inline CommandPacket& operator=(const CommandPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPacket& operator=(CommandPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPacket* internal_default_instance() {
    return reinterpret_cast<const CommandPacket*>(
               &_CommandPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommandPacket& a, CommandPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandPacket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandPacket& from);
  void MergeFrom(const CommandPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.CommandPacket";
  }
  protected:
  explicit CommandPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kCommandUidFieldNumber = 1,
    kCommandCodeFieldNumber = 2,
  };
  // optional string payload = 3;
  bool has_payload() const;
  void clear_payload() ;
  const std::string& payload() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* ptr);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint32 commandUid = 1;
  void clear_commanduid() ;
  ::uint32_t commanduid() const;
  void set_commanduid(::uint32_t value);

  private:
  ::uint32_t _internal_commanduid() const;
  void _internal_set_commanduid(::uint32_t value);

  public:
  // .handEngine.v1.CommandCode commandCode = 2;
  void clear_commandcode() ;
  ::handEngine::v1::CommandCode commandcode() const;
  void set_commandcode(::handEngine::v1::CommandCode value);

  private:
  ::handEngine::v1::CommandCode _internal_commandcode() const;
  void _internal_set_commandcode(::handEngine::v1::CommandCode value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.CommandPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::uint32_t commanduid_;
    int commandcode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class DeviceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceEvent) */ {
 public:
  inline DeviceEvent() : DeviceEvent(nullptr) {}
  ~DeviceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceEvent(const DeviceEvent& from);
  DeviceEvent(DeviceEvent&& from) noexcept
    : DeviceEvent() {
    *this = ::std::move(from);
  }

  inline DeviceEvent& operator=(const DeviceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceEvent& operator=(DeviceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceEvent* internal_default_instance() {
    return reinterpret_cast<const DeviceEvent*>(
               &_DeviceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeviceEvent& a, DeviceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceEvent& from);
  void MergeFrom(const DeviceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceEvent";
  }
  protected:
  explicit DeviceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kEventFieldNumber = 1,
  };
  // string payload = 2;
  void clear_payload() ;
  const std::string& payload() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* ptr);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // .handEngine.v1.Event event = 1;
  void clear_event() ;
  ::handEngine::v1::Event event() const;
  void set_event(::handEngine::v1::Event value);

  private:
  ::handEngine::v1::Event _internal_event() const;
  void _internal_set_event(::handEngine::v1::Event value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class DfuData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DfuData) */ {
 public:
  inline DfuData() : DfuData(nullptr) {}
  ~DfuData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DfuData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DfuData(const DfuData& from);
  DfuData(DfuData&& from) noexcept
    : DfuData() {
    *this = ::std::move(from);
  }

  inline DfuData& operator=(const DfuData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DfuData& operator=(DfuData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DfuData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DfuData* internal_default_instance() {
    return reinterpret_cast<const DfuData*>(
               &_DfuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DfuData& a, DfuData& b) {
    a.Swap(&b);
  }
  inline void Swap(DfuData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DfuData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DfuData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DfuData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DfuData& from);
  void MergeFrom(const DfuData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DfuData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DfuData";
  }
  protected:
  explicit DfuData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kDfuUidFieldNumber = 1,
  };
  // optional string payload = 2;
  bool has_payload() const;
  void clear_payload() ;
  const std::string& payload() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* ptr);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint32 dfuUid = 1;
  void clear_dfuuid() ;
  ::uint32_t dfuuid() const;
  void set_dfuuid(::uint32_t value);

  private:
  ::uint32_t _internal_dfuuid() const;
  void _internal_set_dfuuid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.DfuData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::uint32_t dfuuid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class DeviceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceMessage) */ {
 public:
  inline DeviceMessage() : DeviceMessage(nullptr) {}
  ~DeviceMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMessage(const DeviceMessage& from);
  DeviceMessage(DeviceMessage&& from) noexcept
    : DeviceMessage() {
    *this = ::std::move(from);
  }

  inline DeviceMessage& operator=(const DeviceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMessage& operator=(DeviceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMessage* internal_default_instance() {
    return reinterpret_cast<const DeviceMessage*>(
               &_DeviceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeviceMessage& a, DeviceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceMessage& from);
  void MergeFrom(const DeviceMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceMessage";
  }
  protected:
  explicit DeviceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialNumberFieldNumber = 1,
    kDeviceInformationFieldNumber = 3,
    kStretchSensorDataFieldNumber = 4,
    kImuDataFieldNumber = 5,
    kTimeDataFieldNumber = 6,
    kPeripheralStateFieldNumber = 7,
    kCommandResponseFieldNumber = 8,
    kDeviceEventFieldNumber = 9,
    kDfuDataFieldNumber = 10,
    kPacketCounterFieldNumber = 2,
  };
  // string serialNumber = 1;
  void clear_serialnumber() ;
  const std::string& serialnumber() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serialnumber(Arg_&& arg, Args_... args);
  std::string* mutable_serialnumber();
  PROTOBUF_NODISCARD std::string* release_serialnumber();
  void set_allocated_serialnumber(std::string* ptr);

  private:
  const std::string& _internal_serialnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialnumber(
      const std::string& value);
  std::string* _internal_mutable_serialnumber();

  public:
  // .handEngine.v1.DeviceInformation deviceInformation = 3;
  bool has_deviceinformation() const;
  void clear_deviceinformation() ;
  const ::handEngine::v1::DeviceInformation& deviceinformation() const;
  PROTOBUF_NODISCARD ::handEngine::v1::DeviceInformation* release_deviceinformation();
  ::handEngine::v1::DeviceInformation* mutable_deviceinformation();
  void set_allocated_deviceinformation(::handEngine::v1::DeviceInformation* deviceinformation);
  private:
  const ::handEngine::v1::DeviceInformation& _internal_deviceinformation() const;
  ::handEngine::v1::DeviceInformation* _internal_mutable_deviceinformation();
  public:
  void unsafe_arena_set_allocated_deviceinformation(
      ::handEngine::v1::DeviceInformation* deviceinformation);
  ::handEngine::v1::DeviceInformation* unsafe_arena_release_deviceinformation();
  // optional .handEngine.v1.StretchSensorData stretchSensorData = 4;
  bool has_stretchsensordata() const;
  void clear_stretchsensordata() ;
  const ::handEngine::v1::StretchSensorData& stretchsensordata() const;
  PROTOBUF_NODISCARD ::handEngine::v1::StretchSensorData* release_stretchsensordata();
  ::handEngine::v1::StretchSensorData* mutable_stretchsensordata();
  void set_allocated_stretchsensordata(::handEngine::v1::StretchSensorData* stretchsensordata);
  private:
  const ::handEngine::v1::StretchSensorData& _internal_stretchsensordata() const;
  ::handEngine::v1::StretchSensorData* _internal_mutable_stretchsensordata();
  public:
  void unsafe_arena_set_allocated_stretchsensordata(
      ::handEngine::v1::StretchSensorData* stretchsensordata);
  ::handEngine::v1::StretchSensorData* unsafe_arena_release_stretchsensordata();
  // optional .handEngine.v1.ImuData imuData = 5;
  bool has_imudata() const;
  void clear_imudata() ;
  const ::handEngine::v1::ImuData& imudata() const;
  PROTOBUF_NODISCARD ::handEngine::v1::ImuData* release_imudata();
  ::handEngine::v1::ImuData* mutable_imudata();
  void set_allocated_imudata(::handEngine::v1::ImuData* imudata);
  private:
  const ::handEngine::v1::ImuData& _internal_imudata() const;
  ::handEngine::v1::ImuData* _internal_mutable_imudata();
  public:
  void unsafe_arena_set_allocated_imudata(
      ::handEngine::v1::ImuData* imudata);
  ::handEngine::v1::ImuData* unsafe_arena_release_imudata();
  // optional .handEngine.v1.TimeData timeData = 6;
  bool has_timedata() const;
  void clear_timedata() ;
  const ::handEngine::v1::TimeData& timedata() const;
  PROTOBUF_NODISCARD ::handEngine::v1::TimeData* release_timedata();
  ::handEngine::v1::TimeData* mutable_timedata();
  void set_allocated_timedata(::handEngine::v1::TimeData* timedata);
  private:
  const ::handEngine::v1::TimeData& _internal_timedata() const;
  ::handEngine::v1::TimeData* _internal_mutable_timedata();
  public:
  void unsafe_arena_set_allocated_timedata(
      ::handEngine::v1::TimeData* timedata);
  ::handEngine::v1::TimeData* unsafe_arena_release_timedata();
  // optional .handEngine.v1.PeripheralState peripheralState = 7;
  bool has_peripheralstate() const;
  void clear_peripheralstate() ;
  const ::handEngine::v1::PeripheralState& peripheralstate() const;
  PROTOBUF_NODISCARD ::handEngine::v1::PeripheralState* release_peripheralstate();
  ::handEngine::v1::PeripheralState* mutable_peripheralstate();
  void set_allocated_peripheralstate(::handEngine::v1::PeripheralState* peripheralstate);
  private:
  const ::handEngine::v1::PeripheralState& _internal_peripheralstate() const;
  ::handEngine::v1::PeripheralState* _internal_mutable_peripheralstate();
  public:
  void unsafe_arena_set_allocated_peripheralstate(
      ::handEngine::v1::PeripheralState* peripheralstate);
  ::handEngine::v1::PeripheralState* unsafe_arena_release_peripheralstate();
  // optional .handEngine.v1.CommandPacket commandResponse = 8;
  bool has_commandresponse() const;
  void clear_commandresponse() ;
  const ::handEngine::v1::CommandPacket& commandresponse() const;
  PROTOBUF_NODISCARD ::handEngine::v1::CommandPacket* release_commandresponse();
  ::handEngine::v1::CommandPacket* mutable_commandresponse();
  void set_allocated_commandresponse(::handEngine::v1::CommandPacket* commandresponse);
  private:
  const ::handEngine::v1::CommandPacket& _internal_commandresponse() const;
  ::handEngine::v1::CommandPacket* _internal_mutable_commandresponse();
  public:
  void unsafe_arena_set_allocated_commandresponse(
      ::handEngine::v1::CommandPacket* commandresponse);
  ::handEngine::v1::CommandPacket* unsafe_arena_release_commandresponse();
  // optional .handEngine.v1.DeviceEvent deviceEvent = 9;
  bool has_deviceevent() const;
  void clear_deviceevent() ;
  const ::handEngine::v1::DeviceEvent& deviceevent() const;
  PROTOBUF_NODISCARD ::handEngine::v1::DeviceEvent* release_deviceevent();
  ::handEngine::v1::DeviceEvent* mutable_deviceevent();
  void set_allocated_deviceevent(::handEngine::v1::DeviceEvent* deviceevent);
  private:
  const ::handEngine::v1::DeviceEvent& _internal_deviceevent() const;
  ::handEngine::v1::DeviceEvent* _internal_mutable_deviceevent();
  public:
  void unsafe_arena_set_allocated_deviceevent(
      ::handEngine::v1::DeviceEvent* deviceevent);
  ::handEngine::v1::DeviceEvent* unsafe_arena_release_deviceevent();
  // optional .handEngine.v1.DfuData dfuData = 10;
  bool has_dfudata() const;
  void clear_dfudata() ;
  const ::handEngine::v1::DfuData& dfudata() const;
  PROTOBUF_NODISCARD ::handEngine::v1::DfuData* release_dfudata();
  ::handEngine::v1::DfuData* mutable_dfudata();
  void set_allocated_dfudata(::handEngine::v1::DfuData* dfudata);
  private:
  const ::handEngine::v1::DfuData& _internal_dfudata() const;
  ::handEngine::v1::DfuData* _internal_mutable_dfudata();
  public:
  void unsafe_arena_set_allocated_dfudata(
      ::handEngine::v1::DfuData* dfudata);
  ::handEngine::v1::DfuData* unsafe_arena_release_dfudata();
  // uint32 packetCounter = 2;
  void clear_packetcounter() ;
  ::uint32_t packetcounter() const;
  void set_packetcounter(::uint32_t value);

  private:
  ::uint32_t _internal_packetcounter() const;
  void _internal_set_packetcounter(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialnumber_;
    ::handEngine::v1::DeviceInformation* deviceinformation_;
    ::handEngine::v1::StretchSensorData* stretchsensordata_;
    ::handEngine::v1::ImuData* imudata_;
    ::handEngine::v1::TimeData* timedata_;
    ::handEngine::v1::PeripheralState* peripheralstate_;
    ::handEngine::v1::CommandPacket* commandresponse_;
    ::handEngine::v1::DeviceEvent* deviceevent_;
    ::handEngine::v1::DfuData* dfudata_;
    ::uint32_t packetcounter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class AggregateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.AggregateMessage) */ {
 public:
  inline AggregateMessage() : AggregateMessage(nullptr) {}
  ~AggregateMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateMessage(const AggregateMessage& from);
  AggregateMessage(AggregateMessage&& from) noexcept
    : AggregateMessage() {
    *this = ::std::move(from);
  }

  inline AggregateMessage& operator=(const AggregateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateMessage& operator=(AggregateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AggregateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateMessage* internal_default_instance() {
    return reinterpret_cast<const AggregateMessage*>(
               &_AggregateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AggregateMessage& a, AggregateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AggregateMessage& from);
  void MergeFrom(const AggregateMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.AggregateMessage";
  }
  protected:
  explicit AggregateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceMessageFieldNumber = 1,
  };
  // repeated .handEngine.v1.DeviceMessage deviceMessage = 1;
  int devicemessage_size() const;
  private:
  int _internal_devicemessage_size() const;

  public:
  void clear_devicemessage() ;
  ::handEngine::v1::DeviceMessage* mutable_devicemessage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceMessage >*
      mutable_devicemessage();
  private:
  const ::handEngine::v1::DeviceMessage& _internal_devicemessage(int index) const;
  ::handEngine::v1::DeviceMessage* _internal_add_devicemessage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceMessage>& _internal_devicemessage() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceMessage>* _internal_mutable_devicemessage();
  public:
  const ::handEngine::v1::DeviceMessage& devicemessage(int index) const;
  ::handEngine::v1::DeviceMessage* add_devicemessage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceMessage >&
      devicemessage() const;
  // @@protoc_insertion_point(class_scope:handEngine.v1.AggregateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceMessage > devicemessage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};// -------------------------------------------------------------------

class DeviceCommand final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceCommand) */ {
 public:
  inline DeviceCommand() : DeviceCommand(nullptr) {}
  ~DeviceCommand() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceCommand(const DeviceCommand& from);
  DeviceCommand(DeviceCommand&& from) noexcept
    : DeviceCommand() {
    *this = ::std::move(from);
  }

  inline DeviceCommand& operator=(const DeviceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceCommand& operator=(DeviceCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceCommand* internal_default_instance() {
    return reinterpret_cast<const DeviceCommand*>(
               &_DeviceCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeviceCommand& a, DeviceCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceCommand* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceCommand& from);
  void MergeFrom(const DeviceCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceCommand";
  }
  protected:
  explicit DeviceCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetDeviceFieldNumber = 1,
    kCommandPacketFieldNumber = 2,
    kDfuDataFieldNumber = 3,
  };
  // string targetDevice = 1;
  void clear_targetdevice() ;
  const std::string& targetdevice() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_targetdevice(Arg_&& arg, Args_... args);
  std::string* mutable_targetdevice();
  PROTOBUF_NODISCARD std::string* release_targetdevice();
  void set_allocated_targetdevice(std::string* ptr);

  private:
  const std::string& _internal_targetdevice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetdevice(
      const std::string& value);
  std::string* _internal_mutable_targetdevice();

  public:
  // .handEngine.v1.CommandPacket commandPacket = 2;
  bool has_commandpacket() const;
  void clear_commandpacket() ;
  const ::handEngine::v1::CommandPacket& commandpacket() const;
  PROTOBUF_NODISCARD ::handEngine::v1::CommandPacket* release_commandpacket();
  ::handEngine::v1::CommandPacket* mutable_commandpacket();
  void set_allocated_commandpacket(::handEngine::v1::CommandPacket* commandpacket);
  private:
  const ::handEngine::v1::CommandPacket& _internal_commandpacket() const;
  ::handEngine::v1::CommandPacket* _internal_mutable_commandpacket();
  public:
  void unsafe_arena_set_allocated_commandpacket(
      ::handEngine::v1::CommandPacket* commandpacket);
  ::handEngine::v1::CommandPacket* unsafe_arena_release_commandpacket();
  // optional .handEngine.v1.DfuData dfuData = 3;
  bool has_dfudata() const;
  void clear_dfudata() ;
  const ::handEngine::v1::DfuData& dfudata() const;
  PROTOBUF_NODISCARD ::handEngine::v1::DfuData* release_dfudata();
  ::handEngine::v1::DfuData* mutable_dfudata();
  void set_allocated_dfudata(::handEngine::v1::DfuData* dfudata);
  private:
  const ::handEngine::v1::DfuData& _internal_dfudata() const;
  ::handEngine::v1::DfuData* _internal_mutable_dfudata();
  public:
  void unsafe_arena_set_allocated_dfudata(
      ::handEngine::v1::DfuData* dfudata);
  ::handEngine::v1::DfuData* unsafe_arena_release_dfudata();
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetdevice_;
    ::handEngine::v1::CommandPacket* commandpacket_;
    ::handEngine::v1::DfuData* dfudata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fdevice_2dcommunication_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Product

// .handEngine.v1.ProductFamily productFamily = 1;
inline void Product::clear_productfamily() {
  _impl_.productfamily_ = 0;
}
inline ::handEngine::v1::ProductFamily Product::productfamily() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.Product.productFamily)
  return _internal_productfamily();
}
inline void Product::set_productfamily(::handEngine::v1::ProductFamily value) {
   _internal_set_productfamily(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.Product.productFamily)
}
inline ::handEngine::v1::ProductFamily Product::_internal_productfamily() const {
  return static_cast<::handEngine::v1::ProductFamily>(_impl_.productfamily_);
}
inline void Product::_internal_set_productfamily(::handEngine::v1::ProductFamily value) {
  ;
  _impl_.productfamily_ = value;
}

// optional string productCode = 2;
inline bool Product::has_productcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Product::clear_productcode() {
  _impl_.productcode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Product::productcode() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.Product.productCode)
  return _internal_productcode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Product::set_productcode(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productcode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.Product.productCode)
}
inline std::string* Product::mutable_productcode() {
  std::string* _s = _internal_mutable_productcode();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.Product.productCode)
  return _s;
}
inline const std::string& Product::_internal_productcode() const {
  return _impl_.productcode_.Get();
}
inline void Product::_internal_set_productcode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.productcode_.Set(value, GetArenaForAllocation());
}
inline std::string* Product::_internal_mutable_productcode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productcode_.Mutable( GetArenaForAllocation());
}
inline std::string* Product::release_productcode() {
  // @@protoc_insertion_point(field_release:handEngine.v1.Product.productCode)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.productcode_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Product::set_allocated_productcode(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productcode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productcode_.IsDefault()) {
          _impl_.productcode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.Product.productCode)
}

// -------------------------------------------------------------------

// DeviceProperty

// .handEngine.v1.PropertyType type = 1;
inline void DeviceProperty::clear_type() {
  _impl_.type_ = 0;
}
inline ::handEngine::v1::PropertyType DeviceProperty::type() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceProperty.type)
  return _internal_type();
}
inline void DeviceProperty::set_type(::handEngine::v1::PropertyType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceProperty.type)
}
inline ::handEngine::v1::PropertyType DeviceProperty::_internal_type() const {
  return static_cast<::handEngine::v1::PropertyType>(_impl_.type_);
}
inline void DeviceProperty::_internal_set_type(::handEngine::v1::PropertyType value) {
  ;
  _impl_.type_ = value;
}

// string value = 2;
inline void DeviceProperty::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& DeviceProperty::value() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceProperty.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceProperty::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceProperty.value)
}
inline std::string* DeviceProperty::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceProperty.value)
  return _s;
}
inline const std::string& DeviceProperty::_internal_value() const {
  return _impl_.value_.Get();
}
inline void DeviceProperty::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceProperty::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceProperty::release_value() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceProperty.value)
  return _impl_.value_.Release();
}
inline void DeviceProperty::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceProperty.value)
}

// -------------------------------------------------------------------

// FirmwareData

// string partName = 1;
inline void FirmwareData::clear_partname() {
  _impl_.partname_.ClearToEmpty();
}
inline const std::string& FirmwareData::partname() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.FirmwareData.partName)
  return _internal_partname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FirmwareData::set_partname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.partname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.FirmwareData.partName)
}
inline std::string* FirmwareData::mutable_partname() {
  std::string* _s = _internal_mutable_partname();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.FirmwareData.partName)
  return _s;
}
inline const std::string& FirmwareData::_internal_partname() const {
  return _impl_.partname_.Get();
}
inline void FirmwareData::_internal_set_partname(const std::string& value) {
  ;


  _impl_.partname_.Set(value, GetArenaForAllocation());
}
inline std::string* FirmwareData::_internal_mutable_partname() {
  ;
  return _impl_.partname_.Mutable( GetArenaForAllocation());
}
inline std::string* FirmwareData::release_partname() {
  // @@protoc_insertion_point(field_release:handEngine.v1.FirmwareData.partName)
  return _impl_.partname_.Release();
}
inline void FirmwareData::set_allocated_partname(std::string* value) {
  _impl_.partname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partname_.IsDefault()) {
          _impl_.partname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.FirmwareData.partName)
}

// uint32 major = 2;
inline void FirmwareData::clear_major() {
  _impl_.major_ = 0u;
}
inline ::uint32_t FirmwareData::major() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.FirmwareData.major)
  return _internal_major();
}
inline void FirmwareData::set_major(::uint32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.FirmwareData.major)
}
inline ::uint32_t FirmwareData::_internal_major() const {
  return _impl_.major_;
}
inline void FirmwareData::_internal_set_major(::uint32_t value) {
  ;
  _impl_.major_ = value;
}

// uint32 minor = 3;
inline void FirmwareData::clear_minor() {
  _impl_.minor_ = 0u;
}
inline ::uint32_t FirmwareData::minor() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.FirmwareData.minor)
  return _internal_minor();
}
inline void FirmwareData::set_minor(::uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.FirmwareData.minor)
}
inline ::uint32_t FirmwareData::_internal_minor() const {
  return _impl_.minor_;
}
inline void FirmwareData::_internal_set_minor(::uint32_t value) {
  ;
  _impl_.minor_ = value;
}

// uint32 bugfix = 4;
inline void FirmwareData::clear_bugfix() {
  _impl_.bugfix_ = 0u;
}
inline ::uint32_t FirmwareData::bugfix() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.FirmwareData.bugfix)
  return _internal_bugfix();
}
inline void FirmwareData::set_bugfix(::uint32_t value) {
  _internal_set_bugfix(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.FirmwareData.bugfix)
}
inline ::uint32_t FirmwareData::_internal_bugfix() const {
  return _impl_.bugfix_;
}
inline void FirmwareData::_internal_set_bugfix(::uint32_t value) {
  ;
  _impl_.bugfix_ = value;
}

// -------------------------------------------------------------------

// ManufacturingData

// string partNumber = 1;
inline void ManufacturingData::clear_partnumber() {
  _impl_.partnumber_.ClearToEmpty();
}
inline const std::string& ManufacturingData::partnumber() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ManufacturingData.partNumber)
  return _internal_partnumber();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ManufacturingData::set_partnumber(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.partnumber_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.ManufacturingData.partNumber)
}
inline std::string* ManufacturingData::mutable_partnumber() {
  std::string* _s = _internal_mutable_partnumber();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.ManufacturingData.partNumber)
  return _s;
}
inline const std::string& ManufacturingData::_internal_partnumber() const {
  return _impl_.partnumber_.Get();
}
inline void ManufacturingData::_internal_set_partnumber(const std::string& value) {
  ;


  _impl_.partnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* ManufacturingData::_internal_mutable_partnumber() {
  ;
  return _impl_.partnumber_.Mutable( GetArenaForAllocation());
}
inline std::string* ManufacturingData::release_partnumber() {
  // @@protoc_insertion_point(field_release:handEngine.v1.ManufacturingData.partNumber)
  return _impl_.partnumber_.Release();
}
inline void ManufacturingData::set_allocated_partnumber(std::string* value) {
  _impl_.partnumber_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partnumber_.IsDefault()) {
          _impl_.partnumber_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.ManufacturingData.partNumber)
}

// string revision = 2;
inline void ManufacturingData::clear_revision() {
  _impl_.revision_.ClearToEmpty();
}
inline const std::string& ManufacturingData::revision() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ManufacturingData.revision)
  return _internal_revision();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ManufacturingData::set_revision(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.revision_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.ManufacturingData.revision)
}
inline std::string* ManufacturingData::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.ManufacturingData.revision)
  return _s;
}
inline const std::string& ManufacturingData::_internal_revision() const {
  return _impl_.revision_.Get();
}
inline void ManufacturingData::_internal_set_revision(const std::string& value) {
  ;


  _impl_.revision_.Set(value, GetArenaForAllocation());
}
inline std::string* ManufacturingData::_internal_mutable_revision() {
  ;
  return _impl_.revision_.Mutable( GetArenaForAllocation());
}
inline std::string* ManufacturingData::release_revision() {
  // @@protoc_insertion_point(field_release:handEngine.v1.ManufacturingData.revision)
  return _impl_.revision_.Release();
}
inline void ManufacturingData::set_allocated_revision(std::string* value) {
  _impl_.revision_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.revision_.IsDefault()) {
          _impl_.revision_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.ManufacturingData.revision)
}

// uint32 monthOfManufacture = 3;
inline void ManufacturingData::clear_monthofmanufacture() {
  _impl_.monthofmanufacture_ = 0u;
}
inline ::uint32_t ManufacturingData::monthofmanufacture() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ManufacturingData.monthOfManufacture)
  return _internal_monthofmanufacture();
}
inline void ManufacturingData::set_monthofmanufacture(::uint32_t value) {
  _internal_set_monthofmanufacture(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ManufacturingData.monthOfManufacture)
}
inline ::uint32_t ManufacturingData::_internal_monthofmanufacture() const {
  return _impl_.monthofmanufacture_;
}
inline void ManufacturingData::_internal_set_monthofmanufacture(::uint32_t value) {
  ;
  _impl_.monthofmanufacture_ = value;
}

// uint32 yearOfManufacture = 4;
inline void ManufacturingData::clear_yearofmanufacture() {
  _impl_.yearofmanufacture_ = 0u;
}
inline ::uint32_t ManufacturingData::yearofmanufacture() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ManufacturingData.yearOfManufacture)
  return _internal_yearofmanufacture();
}
inline void ManufacturingData::set_yearofmanufacture(::uint32_t value) {
  _internal_set_yearofmanufacture(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ManufacturingData.yearOfManufacture)
}
inline ::uint32_t ManufacturingData::_internal_yearofmanufacture() const {
  return _impl_.yearofmanufacture_;
}
inline void ManufacturingData::_internal_set_yearofmanufacture(::uint32_t value) {
  ;
  _impl_.yearofmanufacture_ = value;
}

// uint32 batchNumber = 5;
inline void ManufacturingData::clear_batchnumber() {
  _impl_.batchnumber_ = 0u;
}
inline ::uint32_t ManufacturingData::batchnumber() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ManufacturingData.batchNumber)
  return _internal_batchnumber();
}
inline void ManufacturingData::set_batchnumber(::uint32_t value) {
  _internal_set_batchnumber(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ManufacturingData.batchNumber)
}
inline ::uint32_t ManufacturingData::_internal_batchnumber() const {
  return _impl_.batchnumber_;
}
inline void ManufacturingData::_internal_set_batchnumber(::uint32_t value) {
  ;
  _impl_.batchnumber_ = value;
}

// -------------------------------------------------------------------

// StretchSensorData

// optional uint32 thumbThumbside = 1;
inline bool StretchSensorData::has_thumbthumbside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StretchSensorData::clear_thumbthumbside() {
  _impl_.thumbthumbside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t StretchSensorData::thumbthumbside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.thumbThumbside)
  return _internal_thumbthumbside();
}
inline void StretchSensorData::set_thumbthumbside(::uint32_t value) {
  _internal_set_thumbthumbside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.thumbThumbside)
}
inline ::uint32_t StretchSensorData::_internal_thumbthumbside() const {
  return _impl_.thumbthumbside_;
}
inline void StretchSensorData::_internal_set_thumbthumbside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.thumbthumbside_ = value;
}

// optional uint32 thumbMid = 2;
inline bool StretchSensorData::has_thumbmid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StretchSensorData::clear_thumbmid() {
  _impl_.thumbmid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t StretchSensorData::thumbmid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.thumbMid)
  return _internal_thumbmid();
}
inline void StretchSensorData::set_thumbmid(::uint32_t value) {
  _internal_set_thumbmid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.thumbMid)
}
inline ::uint32_t StretchSensorData::_internal_thumbmid() const {
  return _impl_.thumbmid_;
}
inline void StretchSensorData::_internal_set_thumbmid(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.thumbmid_ = value;
}

// optional uint32 thumbPinkyside = 3;
inline bool StretchSensorData::has_thumbpinkyside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StretchSensorData::clear_thumbpinkyside() {
  _impl_.thumbpinkyside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t StretchSensorData::thumbpinkyside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.thumbPinkyside)
  return _internal_thumbpinkyside();
}
inline void StretchSensorData::set_thumbpinkyside(::uint32_t value) {
  _internal_set_thumbpinkyside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.thumbPinkyside)
}
inline ::uint32_t StretchSensorData::_internal_thumbpinkyside() const {
  return _impl_.thumbpinkyside_;
}
inline void StretchSensorData::_internal_set_thumbpinkyside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.thumbpinkyside_ = value;
}

// optional uint32 dorsalThumbExtension = 4;
inline bool StretchSensorData::has_dorsalthumbextension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StretchSensorData::clear_dorsalthumbextension() {
  _impl_.dorsalthumbextension_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t StretchSensorData::dorsalthumbextension() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.dorsalThumbExtension)
  return _internal_dorsalthumbextension();
}
inline void StretchSensorData::set_dorsalthumbextension(::uint32_t value) {
  _internal_set_dorsalthumbextension(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.dorsalThumbExtension)
}
inline ::uint32_t StretchSensorData::_internal_dorsalthumbextension() const {
  return _impl_.dorsalthumbextension_;
}
inline void StretchSensorData::_internal_set_dorsalthumbextension(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.dorsalthumbextension_ = value;
}

// optional uint32 indexThumbside = 5;
inline bool StretchSensorData::has_indexthumbside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StretchSensorData::clear_indexthumbside() {
  _impl_.indexthumbside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t StretchSensorData::indexthumbside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.indexThumbside)
  return _internal_indexthumbside();
}
inline void StretchSensorData::set_indexthumbside(::uint32_t value) {
  _internal_set_indexthumbside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.indexThumbside)
}
inline ::uint32_t StretchSensorData::_internal_indexthumbside() const {
  return _impl_.indexthumbside_;
}
inline void StretchSensorData::_internal_set_indexthumbside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.indexthumbside_ = value;
}

// optional uint32 indexMid = 6;
inline bool StretchSensorData::has_indexmid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StretchSensorData::clear_indexmid() {
  _impl_.indexmid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t StretchSensorData::indexmid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.indexMid)
  return _internal_indexmid();
}
inline void StretchSensorData::set_indexmid(::uint32_t value) {
  _internal_set_indexmid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.indexMid)
}
inline ::uint32_t StretchSensorData::_internal_indexmid() const {
  return _impl_.indexmid_;
}
inline void StretchSensorData::_internal_set_indexmid(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.indexmid_ = value;
}

// optional uint32 indexPinkyside = 7;
inline bool StretchSensorData::has_indexpinkyside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StretchSensorData::clear_indexpinkyside() {
  _impl_.indexpinkyside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t StretchSensorData::indexpinkyside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.indexPinkyside)
  return _internal_indexpinkyside();
}
inline void StretchSensorData::set_indexpinkyside(::uint32_t value) {
  _internal_set_indexpinkyside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.indexPinkyside)
}
inline ::uint32_t StretchSensorData::_internal_indexpinkyside() const {
  return _impl_.indexpinkyside_;
}
inline void StretchSensorData::_internal_set_indexpinkyside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.indexpinkyside_ = value;
}

// optional uint32 middleThumbside = 8;
inline bool StretchSensorData::has_middlethumbside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void StretchSensorData::clear_middlethumbside() {
  _impl_.middlethumbside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t StretchSensorData::middlethumbside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.middleThumbside)
  return _internal_middlethumbside();
}
inline void StretchSensorData::set_middlethumbside(::uint32_t value) {
  _internal_set_middlethumbside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.middleThumbside)
}
inline ::uint32_t StretchSensorData::_internal_middlethumbside() const {
  return _impl_.middlethumbside_;
}
inline void StretchSensorData::_internal_set_middlethumbside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.middlethumbside_ = value;
}

// optional uint32 middleMid = 9;
inline bool StretchSensorData::has_middlemid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void StretchSensorData::clear_middlemid() {
  _impl_.middlemid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t StretchSensorData::middlemid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.middleMid)
  return _internal_middlemid();
}
inline void StretchSensorData::set_middlemid(::uint32_t value) {
  _internal_set_middlemid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.middleMid)
}
inline ::uint32_t StretchSensorData::_internal_middlemid() const {
  return _impl_.middlemid_;
}
inline void StretchSensorData::_internal_set_middlemid(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.middlemid_ = value;
}

// optional uint32 middlePinkyside = 10;
inline bool StretchSensorData::has_middlepinkyside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void StretchSensorData::clear_middlepinkyside() {
  _impl_.middlepinkyside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t StretchSensorData::middlepinkyside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.middlePinkyside)
  return _internal_middlepinkyside();
}
inline void StretchSensorData::set_middlepinkyside(::uint32_t value) {
  _internal_set_middlepinkyside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.middlePinkyside)
}
inline ::uint32_t StretchSensorData::_internal_middlepinkyside() const {
  return _impl_.middlepinkyside_;
}
inline void StretchSensorData::_internal_set_middlepinkyside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.middlepinkyside_ = value;
}

// optional uint32 ringThumbside = 11;
inline bool StretchSensorData::has_ringthumbside() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void StretchSensorData::clear_ringthumbside() {
  _impl_.ringthumbside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t StretchSensorData::ringthumbside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.ringThumbside)
  return _internal_ringthumbside();
}
inline void StretchSensorData::set_ringthumbside(::uint32_t value) {
  _internal_set_ringthumbside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.ringThumbside)
}
inline ::uint32_t StretchSensorData::_internal_ringthumbside() const {
  return _impl_.ringthumbside_;
}
inline void StretchSensorData::_internal_set_ringthumbside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ringthumbside_ = value;
}

// optional uint32 ringMid = 12;
inline bool StretchSensorData::has_ringmid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void StretchSensorData::clear_ringmid() {
  _impl_.ringmid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint32_t StretchSensorData::ringmid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.ringMid)
  return _internal_ringmid();
}
inline void StretchSensorData::set_ringmid(::uint32_t value) {
  _internal_set_ringmid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.ringMid)
}
inline ::uint32_t StretchSensorData::_internal_ringmid() const {
  return _impl_.ringmid_;
}
inline void StretchSensorData::_internal_set_ringmid(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.ringmid_ = value;
}

// optional uint32 ringPinkyside = 13;
inline bool StretchSensorData::has_ringpinkyside() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void StretchSensorData::clear_ringpinkyside() {
  _impl_.ringpinkyside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint32_t StretchSensorData::ringpinkyside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.ringPinkyside)
  return _internal_ringpinkyside();
}
inline void StretchSensorData::set_ringpinkyside(::uint32_t value) {
  _internal_set_ringpinkyside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.ringPinkyside)
}
inline ::uint32_t StretchSensorData::_internal_ringpinkyside() const {
  return _impl_.ringpinkyside_;
}
inline void StretchSensorData::_internal_set_ringpinkyside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.ringpinkyside_ = value;
}

// optional uint32 pinkyThumbside = 14;
inline bool StretchSensorData::has_pinkythumbside() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void StretchSensorData::clear_pinkythumbside() {
  _impl_.pinkythumbside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t StretchSensorData::pinkythumbside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.pinkyThumbside)
  return _internal_pinkythumbside();
}
inline void StretchSensorData::set_pinkythumbside(::uint32_t value) {
  _internal_set_pinkythumbside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.pinkyThumbside)
}
inline ::uint32_t StretchSensorData::_internal_pinkythumbside() const {
  return _impl_.pinkythumbside_;
}
inline void StretchSensorData::_internal_set_pinkythumbside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.pinkythumbside_ = value;
}

// optional uint32 pinkyMid = 15;
inline bool StretchSensorData::has_pinkymid() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void StretchSensorData::clear_pinkymid() {
  _impl_.pinkymid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t StretchSensorData::pinkymid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.pinkyMid)
  return _internal_pinkymid();
}
inline void StretchSensorData::set_pinkymid(::uint32_t value) {
  _internal_set_pinkymid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.pinkyMid)
}
inline ::uint32_t StretchSensorData::_internal_pinkymid() const {
  return _impl_.pinkymid_;
}
inline void StretchSensorData::_internal_set_pinkymid(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.pinkymid_ = value;
}

// optional uint32 pinkyPinkyside = 16;
inline bool StretchSensorData::has_pinkypinkyside() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void StretchSensorData::clear_pinkypinkyside() {
  _impl_.pinkypinkyside_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint32_t StretchSensorData::pinkypinkyside() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StretchSensorData.pinkyPinkyside)
  return _internal_pinkypinkyside();
}
inline void StretchSensorData::set_pinkypinkyside(::uint32_t value) {
  _internal_set_pinkypinkyside(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StretchSensorData.pinkyPinkyside)
}
inline ::uint32_t StretchSensorData::_internal_pinkypinkyside() const {
  return _impl_.pinkypinkyside_;
}
inline void StretchSensorData::_internal_set_pinkypinkyside(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.pinkypinkyside_ = value;
}

// -------------------------------------------------------------------

// DeviceInformation

// optional .handEngine.v1.DeviceType deviceType = 1;
inline bool DeviceInformation::has_devicetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void DeviceInformation::clear_devicetype() {
  _impl_.devicetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::handEngine::v1::DeviceType DeviceInformation::devicetype() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.deviceType)
  return _internal_devicetype();
}
inline void DeviceInformation::set_devicetype(::handEngine::v1::DeviceType value) {
   _internal_set_devicetype(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceInformation.deviceType)
}
inline ::handEngine::v1::DeviceType DeviceInformation::_internal_devicetype() const {
  return static_cast<::handEngine::v1::DeviceType>(_impl_.devicetype_);
}
inline void DeviceInformation::_internal_set_devicetype(::handEngine::v1::DeviceType value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.devicetype_ = value;
}

// optional .handEngine.v1.Product product = 2;
inline bool DeviceInformation::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void DeviceInformation::clear_product() {
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::handEngine::v1::Product& DeviceInformation::_internal_product() const {
  const ::handEngine::v1::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::Product&>(
      ::handEngine::v1::_Product_default_instance_);
}
inline const ::handEngine::v1::Product& DeviceInformation::product() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.product)
  return _internal_product();
}
inline void DeviceInformation::unsafe_arena_set_allocated_product(
    ::handEngine::v1::Product* product) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = product;
  if (product) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceInformation.product)
}
inline ::handEngine::v1::Product* DeviceInformation::release_product() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::Product* DeviceInformation::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceInformation.product)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::handEngine::v1::Product* DeviceInformation::_internal_mutable_product() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::Product>(GetArenaForAllocation());
    _impl_.product_ = p;
  }
  return _impl_.product_;
}
inline ::handEngine::v1::Product* DeviceInformation::mutable_product() {
  ::handEngine::v1::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.product)
  return _msg;
}
inline void DeviceInformation::set_allocated_product(::handEngine::v1::Product* product) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.product_;
  }
  if (product) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(product);
    if (message_arena != submessage_arena) {
      product = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, product, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.product_ = product;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceInformation.product)
}

// optional .handEngine.v1.DeviceProperty size = 3;
inline bool DeviceInformation::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.size_ != nullptr);
  return value;
}
inline void DeviceInformation::clear_size() {
  if (_impl_.size_ != nullptr) _impl_.size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::handEngine::v1::DeviceProperty& DeviceInformation::_internal_size() const {
  const ::handEngine::v1::DeviceProperty* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::DeviceProperty&>(
      ::handEngine::v1::_DeviceProperty_default_instance_);
}
inline const ::handEngine::v1::DeviceProperty& DeviceInformation::size() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.size)
  return _internal_size();
}
inline void DeviceInformation::unsafe_arena_set_allocated_size(
    ::handEngine::v1::DeviceProperty* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceInformation.size)
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::release_size() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::handEngine::v1::DeviceProperty* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceInformation.size)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::handEngine::v1::DeviceProperty* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::_internal_mutable_size() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::DeviceProperty>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::mutable_size() {
  ::handEngine::v1::DeviceProperty* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.size)
  return _msg;
}
inline void DeviceInformation::set_allocated_size(::handEngine::v1::DeviceProperty* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceInformation.size)
}

// optional .handEngine.v1.DeviceLocation location = 4;
inline bool DeviceInformation::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void DeviceInformation::clear_location() {
  _impl_.location_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::handEngine::v1::DeviceLocation DeviceInformation::location() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.location)
  return _internal_location();
}
inline void DeviceInformation::set_location(::handEngine::v1::DeviceLocation value) {
   _internal_set_location(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceInformation.location)
}
inline ::handEngine::v1::DeviceLocation DeviceInformation::_internal_location() const {
  return static_cast<::handEngine::v1::DeviceLocation>(_impl_.location_);
}
inline void DeviceInformation::_internal_set_location(::handEngine::v1::DeviceLocation value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.location_ = value;
}

// optional string name = 5;
inline bool DeviceInformation::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DeviceInformation::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInformation::name() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceInformation::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceInformation.name)
}
inline std::string* DeviceInformation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.name)
  return _s;
}
inline const std::string& DeviceInformation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeviceInformation::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInformation::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceInformation::release_name() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceInformation.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DeviceInformation::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceInformation.name)
}

// repeated .handEngine.v1.ManufacturingData manufacturingData = 6;
inline int DeviceInformation::_internal_manufacturingdata_size() const {
  return _impl_.manufacturingdata_.size();
}
inline int DeviceInformation::manufacturingdata_size() const {
  return _internal_manufacturingdata_size();
}
inline void DeviceInformation::clear_manufacturingdata() {
  _internal_mutable_manufacturingdata()->Clear();
}
inline ::handEngine::v1::ManufacturingData* DeviceInformation::mutable_manufacturingdata(int index) {
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.manufacturingData)
  return _internal_mutable_manufacturingdata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::ManufacturingData >*
DeviceInformation::mutable_manufacturingdata() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.DeviceInformation.manufacturingData)
  return _internal_mutable_manufacturingdata();
}
inline const ::handEngine::v1::ManufacturingData& DeviceInformation::_internal_manufacturingdata(int index) const {
  return _internal_manufacturingdata().Get(index);
}
inline const ::handEngine::v1::ManufacturingData& DeviceInformation::manufacturingdata(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.manufacturingData)
  return _internal_manufacturingdata(index);
}
inline ::handEngine::v1::ManufacturingData* DeviceInformation::_internal_add_manufacturingdata() {
  return _internal_mutable_manufacturingdata()->Add();
}
inline ::handEngine::v1::ManufacturingData* DeviceInformation::add_manufacturingdata() {
  ::handEngine::v1::ManufacturingData* _add = _internal_add_manufacturingdata();
  // @@protoc_insertion_point(field_add:handEngine.v1.DeviceInformation.manufacturingData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::ManufacturingData >&
DeviceInformation::manufacturingdata() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.DeviceInformation.manufacturingData)
  return _internal_manufacturingdata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::ManufacturingData>&
DeviceInformation::_internal_manufacturingdata() const {
  return _impl_.manufacturingdata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::ManufacturingData>*
DeviceInformation::_internal_mutable_manufacturingdata() {
  return &_impl_.manufacturingdata_;
}

// repeated .handEngine.v1.DeviceProperty properties = 7;
inline int DeviceInformation::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int DeviceInformation::properties_size() const {
  return _internal_properties_size();
}
inline void DeviceInformation::clear_properties() {
  _internal_mutable_properties()->Clear();
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.properties)
  return _internal_mutable_properties()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceProperty >*
DeviceInformation::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.DeviceInformation.properties)
  return _internal_mutable_properties();
}
inline const ::handEngine::v1::DeviceProperty& DeviceInformation::_internal_properties(int index) const {
  return _internal_properties().Get(index);
}
inline const ::handEngine::v1::DeviceProperty& DeviceInformation::properties(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.properties)
  return _internal_properties(index);
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::_internal_add_properties() {
  return _internal_mutable_properties()->Add();
}
inline ::handEngine::v1::DeviceProperty* DeviceInformation::add_properties() {
  ::handEngine::v1::DeviceProperty* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:handEngine.v1.DeviceInformation.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceProperty >&
DeviceInformation::properties() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.DeviceInformation.properties)
  return _internal_properties();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceProperty>&
DeviceInformation::_internal_properties() const {
  return _impl_.properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceProperty>*
DeviceInformation::_internal_mutable_properties() {
  return &_impl_.properties_;
}

// optional .handEngine.v1.FirmwareData firmwareData = 8;
inline bool DeviceInformation::has_firmwaredata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.firmwaredata_ != nullptr);
  return value;
}
inline void DeviceInformation::clear_firmwaredata() {
  if (_impl_.firmwaredata_ != nullptr) _impl_.firmwaredata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::handEngine::v1::FirmwareData& DeviceInformation::_internal_firmwaredata() const {
  const ::handEngine::v1::FirmwareData* p = _impl_.firmwaredata_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::FirmwareData&>(
      ::handEngine::v1::_FirmwareData_default_instance_);
}
inline const ::handEngine::v1::FirmwareData& DeviceInformation::firmwaredata() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.firmwareData)
  return _internal_firmwaredata();
}
inline void DeviceInformation::unsafe_arena_set_allocated_firmwaredata(
    ::handEngine::v1::FirmwareData* firmwaredata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.firmwaredata_);
  }
  _impl_.firmwaredata_ = firmwaredata;
  if (firmwaredata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceInformation.firmwareData)
}
inline ::handEngine::v1::FirmwareData* DeviceInformation::release_firmwaredata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::handEngine::v1::FirmwareData* temp = _impl_.firmwaredata_;
  _impl_.firmwaredata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::FirmwareData* DeviceInformation::unsafe_arena_release_firmwaredata() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceInformation.firmwareData)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::handEngine::v1::FirmwareData* temp = _impl_.firmwaredata_;
  _impl_.firmwaredata_ = nullptr;
  return temp;
}
inline ::handEngine::v1::FirmwareData* DeviceInformation::_internal_mutable_firmwaredata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.firmwaredata_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::FirmwareData>(GetArenaForAllocation());
    _impl_.firmwaredata_ = p;
  }
  return _impl_.firmwaredata_;
}
inline ::handEngine::v1::FirmwareData* DeviceInformation::mutable_firmwaredata() {
  ::handEngine::v1::FirmwareData* _msg = _internal_mutable_firmwaredata();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.firmwareData)
  return _msg;
}
inline void DeviceInformation::set_allocated_firmwaredata(::handEngine::v1::FirmwareData* firmwaredata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.firmwaredata_;
  }
  if (firmwaredata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(firmwaredata);
    if (message_arena != submessage_arena) {
      firmwaredata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, firmwaredata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.firmwaredata_ = firmwaredata;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceInformation.firmwareData)
}

// optional .handEngine.v1.StretchSensorData baseCapacitances = 9;
inline bool DeviceInformation::has_basecapacitances() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.basecapacitances_ != nullptr);
  return value;
}
inline void DeviceInformation::clear_basecapacitances() {
  if (_impl_.basecapacitances_ != nullptr) _impl_.basecapacitances_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::handEngine::v1::StretchSensorData& DeviceInformation::_internal_basecapacitances() const {
  const ::handEngine::v1::StretchSensorData* p = _impl_.basecapacitances_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::StretchSensorData&>(
      ::handEngine::v1::_StretchSensorData_default_instance_);
}
inline const ::handEngine::v1::StretchSensorData& DeviceInformation::basecapacitances() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.baseCapacitances)
  return _internal_basecapacitances();
}
inline void DeviceInformation::unsafe_arena_set_allocated_basecapacitances(
    ::handEngine::v1::StretchSensorData* basecapacitances) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.basecapacitances_);
  }
  _impl_.basecapacitances_ = basecapacitances;
  if (basecapacitances) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceInformation.baseCapacitances)
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::release_basecapacitances() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::handEngine::v1::StretchSensorData* temp = _impl_.basecapacitances_;
  _impl_.basecapacitances_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::unsafe_arena_release_basecapacitances() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceInformation.baseCapacitances)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::handEngine::v1::StretchSensorData* temp = _impl_.basecapacitances_;
  _impl_.basecapacitances_ = nullptr;
  return temp;
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::_internal_mutable_basecapacitances() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.basecapacitances_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::StretchSensorData>(GetArenaForAllocation());
    _impl_.basecapacitances_ = p;
  }
  return _impl_.basecapacitances_;
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::mutable_basecapacitances() {
  ::handEngine::v1::StretchSensorData* _msg = _internal_mutable_basecapacitances();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.baseCapacitances)
  return _msg;
}
inline void DeviceInformation::set_allocated_basecapacitances(::handEngine::v1::StretchSensorData* basecapacitances) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.basecapacitances_;
  }
  if (basecapacitances) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basecapacitances);
    if (message_arena != submessage_arena) {
      basecapacitances = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basecapacitances, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.basecapacitances_ = basecapacitances;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceInformation.baseCapacitances)
}

// optional .handEngine.v1.StretchSensorData sensorSensitivity = 10;
inline bool DeviceInformation::has_sensorsensitivity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensorsensitivity_ != nullptr);
  return value;
}
inline void DeviceInformation::clear_sensorsensitivity() {
  if (_impl_.sensorsensitivity_ != nullptr) _impl_.sensorsensitivity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::handEngine::v1::StretchSensorData& DeviceInformation::_internal_sensorsensitivity() const {
  const ::handEngine::v1::StretchSensorData* p = _impl_.sensorsensitivity_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::StretchSensorData&>(
      ::handEngine::v1::_StretchSensorData_default_instance_);
}
inline const ::handEngine::v1::StretchSensorData& DeviceInformation::sensorsensitivity() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceInformation.sensorSensitivity)
  return _internal_sensorsensitivity();
}
inline void DeviceInformation::unsafe_arena_set_allocated_sensorsensitivity(
    ::handEngine::v1::StretchSensorData* sensorsensitivity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sensorsensitivity_);
  }
  _impl_.sensorsensitivity_ = sensorsensitivity;
  if (sensorsensitivity) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceInformation.sensorSensitivity)
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::release_sensorsensitivity() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::handEngine::v1::StretchSensorData* temp = _impl_.sensorsensitivity_;
  _impl_.sensorsensitivity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::unsafe_arena_release_sensorsensitivity() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceInformation.sensorSensitivity)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::handEngine::v1::StretchSensorData* temp = _impl_.sensorsensitivity_;
  _impl_.sensorsensitivity_ = nullptr;
  return temp;
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::_internal_mutable_sensorsensitivity() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.sensorsensitivity_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::StretchSensorData>(GetArenaForAllocation());
    _impl_.sensorsensitivity_ = p;
  }
  return _impl_.sensorsensitivity_;
}
inline ::handEngine::v1::StretchSensorData* DeviceInformation::mutable_sensorsensitivity() {
  ::handEngine::v1::StretchSensorData* _msg = _internal_mutable_sensorsensitivity();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceInformation.sensorSensitivity)
  return _msg;
}
inline void DeviceInformation::set_allocated_sensorsensitivity(::handEngine::v1::StretchSensorData* sensorsensitivity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sensorsensitivity_;
  }
  if (sensorsensitivity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sensorsensitivity);
    if (message_arena != submessage_arena) {
      sensorsensitivity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensorsensitivity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sensorsensitivity_ = sensorsensitivity;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceInformation.sensorSensitivity)
}

// -------------------------------------------------------------------

// ImuData

// optional uint32 accelX = 1;
inline bool ImuData::has_accelx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ImuData::clear_accelx() {
  _impl_.accelx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ImuData::accelx() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.accelX)
  return _internal_accelx();
}
inline void ImuData::set_accelx(::uint32_t value) {
  _internal_set_accelx(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.accelX)
}
inline ::uint32_t ImuData::_internal_accelx() const {
  return _impl_.accelx_;
}
inline void ImuData::_internal_set_accelx(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accelx_ = value;
}

// optional uint32 accelY = 2;
inline bool ImuData::has_accely() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ImuData::clear_accely() {
  _impl_.accely_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ImuData::accely() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.accelY)
  return _internal_accely();
}
inline void ImuData::set_accely(::uint32_t value) {
  _internal_set_accely(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.accelY)
}
inline ::uint32_t ImuData::_internal_accely() const {
  return _impl_.accely_;
}
inline void ImuData::_internal_set_accely(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.accely_ = value;
}

// optional uint32 accelZ = 3;
inline bool ImuData::has_accelz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ImuData::clear_accelz() {
  _impl_.accelz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ImuData::accelz() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.accelZ)
  return _internal_accelz();
}
inline void ImuData::set_accelz(::uint32_t value) {
  _internal_set_accelz(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.accelZ)
}
inline ::uint32_t ImuData::_internal_accelz() const {
  return _impl_.accelz_;
}
inline void ImuData::_internal_set_accelz(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.accelz_ = value;
}

// optional uint32 gyroX = 4;
inline bool ImuData::has_gyrox() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ImuData::clear_gyrox() {
  _impl_.gyrox_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ImuData::gyrox() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.gyroX)
  return _internal_gyrox();
}
inline void ImuData::set_gyrox(::uint32_t value) {
  _internal_set_gyrox(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.gyroX)
}
inline ::uint32_t ImuData::_internal_gyrox() const {
  return _impl_.gyrox_;
}
inline void ImuData::_internal_set_gyrox(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.gyrox_ = value;
}

// optional uint32 gyroY = 5;
inline bool ImuData::has_gyroy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ImuData::clear_gyroy() {
  _impl_.gyroy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t ImuData::gyroy() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.gyroY)
  return _internal_gyroy();
}
inline void ImuData::set_gyroy(::uint32_t value) {
  _internal_set_gyroy(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.gyroY)
}
inline ::uint32_t ImuData::_internal_gyroy() const {
  return _impl_.gyroy_;
}
inline void ImuData::_internal_set_gyroy(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.gyroy_ = value;
}

// optional uint32 gyroZ = 6;
inline bool ImuData::has_gyroz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ImuData::clear_gyroz() {
  _impl_.gyroz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t ImuData::gyroz() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.gyroZ)
  return _internal_gyroz();
}
inline void ImuData::set_gyroz(::uint32_t value) {
  _internal_set_gyroz(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.gyroZ)
}
inline ::uint32_t ImuData::_internal_gyroz() const {
  return _impl_.gyroz_;
}
inline void ImuData::_internal_set_gyroz(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.gyroz_ = value;
}

// optional uint32 magX = 7;
inline bool ImuData::has_magx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ImuData::clear_magx() {
  _impl_.magx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t ImuData::magx() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.magX)
  return _internal_magx();
}
inline void ImuData::set_magx(::uint32_t value) {
  _internal_set_magx(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.magX)
}
inline ::uint32_t ImuData::_internal_magx() const {
  return _impl_.magx_;
}
inline void ImuData::_internal_set_magx(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.magx_ = value;
}

// optional uint32 magY = 8;
inline bool ImuData::has_magy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ImuData::clear_magy() {
  _impl_.magy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t ImuData::magy() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.magY)
  return _internal_magy();
}
inline void ImuData::set_magy(::uint32_t value) {
  _internal_set_magy(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.magY)
}
inline ::uint32_t ImuData::_internal_magy() const {
  return _impl_.magy_;
}
inline void ImuData::_internal_set_magy(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.magy_ = value;
}

// optional uint32 magZ = 9;
inline bool ImuData::has_magz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ImuData::clear_magz() {
  _impl_.magz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t ImuData::magz() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.magZ)
  return _internal_magz();
}
inline void ImuData::set_magz(::uint32_t value) {
  _internal_set_magz(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.magZ)
}
inline ::uint32_t ImuData::_internal_magz() const {
  return _impl_.magz_;
}
inline void ImuData::_internal_set_magz(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.magz_ = value;
}

// optional uint32 temperature = 10;
inline bool ImuData::has_temperature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ImuData::clear_temperature() {
  _impl_.temperature_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t ImuData::temperature() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ImuData.temperature)
  return _internal_temperature();
}
inline void ImuData::set_temperature(::uint32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ImuData.temperature)
}
inline ::uint32_t ImuData::_internal_temperature() const {
  return _impl_.temperature_;
}
inline void ImuData::_internal_set_temperature(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.temperature_ = value;
}

// -------------------------------------------------------------------

// TimeData

// uint32 internalMsTime = 1;
inline void TimeData::clear_internalmstime() {
  _impl_.internalmstime_ = 0u;
}
inline ::uint32_t TimeData::internalmstime() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeData.internalMsTime)
  return _internal_internalmstime();
}
inline void TimeData::set_internalmstime(::uint32_t value) {
  _internal_set_internalmstime(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeData.internalMsTime)
}
inline ::uint32_t TimeData::_internal_internalmstime() const {
  return _impl_.internalmstime_;
}
inline void TimeData::_internal_set_internalmstime(::uint32_t value) {
  ;
  _impl_.internalmstime_ = value;
}

// uint32 timeCode = 2;
inline void TimeData::clear_timecode() {
  _impl_.timecode_ = 0u;
}
inline ::uint32_t TimeData::timecode() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeData.timeCode)
  return _internal_timecode();
}
inline void TimeData::set_timecode(::uint32_t value) {
  _internal_set_timecode(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeData.timeCode)
}
inline ::uint32_t TimeData::_internal_timecode() const {
  return _impl_.timecode_;
}
inline void TimeData::_internal_set_timecode(::uint32_t value) {
  ;
  _impl_.timecode_ = value;
}

// -------------------------------------------------------------------

// PeripheralState

// uint32 batteryLevel = 1;
inline void PeripheralState::clear_batterylevel() {
  _impl_.batterylevel_ = 0u;
}
inline ::uint32_t PeripheralState::batterylevel() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PeripheralState.batteryLevel)
  return _internal_batterylevel();
}
inline void PeripheralState::set_batterylevel(::uint32_t value) {
  _internal_set_batterylevel(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.PeripheralState.batteryLevel)
}
inline ::uint32_t PeripheralState::_internal_batterylevel() const {
  return _impl_.batterylevel_;
}
inline void PeripheralState::_internal_set_batterylevel(::uint32_t value) {
  ;
  _impl_.batterylevel_ = value;
}

// uint32 timeSinceLastJamsync = 2;
inline void PeripheralState::clear_timesincelastjamsync() {
  _impl_.timesincelastjamsync_ = 0u;
}
inline ::uint32_t PeripheralState::timesincelastjamsync() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PeripheralState.timeSinceLastJamsync)
  return _internal_timesincelastjamsync();
}
inline void PeripheralState::set_timesincelastjamsync(::uint32_t value) {
  _internal_set_timesincelastjamsync(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.PeripheralState.timeSinceLastJamsync)
}
inline ::uint32_t PeripheralState::_internal_timesincelastjamsync() const {
  return _impl_.timesincelastjamsync_;
}
inline void PeripheralState::_internal_set_timesincelastjamsync(::uint32_t value) {
  ;
  _impl_.timesincelastjamsync_ = value;
}

// optional bool sdCardPresence = 3;
inline bool PeripheralState::has_sdcardpresence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PeripheralState::clear_sdcardpresence() {
  _impl_.sdcardpresence_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PeripheralState::sdcardpresence() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PeripheralState.sdCardPresence)
  return _internal_sdcardpresence();
}
inline void PeripheralState::set_sdcardpresence(bool value) {
  _internal_set_sdcardpresence(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.PeripheralState.sdCardPresence)
}
inline bool PeripheralState::_internal_sdcardpresence() const {
  return _impl_.sdcardpresence_;
}
inline void PeripheralState::_internal_set_sdcardpresence(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sdcardpresence_ = value;
}

// optional bool sdCardRecording = 4;
inline bool PeripheralState::has_sdcardrecording() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PeripheralState::clear_sdcardrecording() {
  _impl_.sdcardrecording_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PeripheralState::sdcardrecording() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PeripheralState.sdCardRecording)
  return _internal_sdcardrecording();
}
inline void PeripheralState::set_sdcardrecording(bool value) {
  _internal_set_sdcardrecording(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.PeripheralState.sdCardRecording)
}
inline bool PeripheralState::_internal_sdcardrecording() const {
  return _impl_.sdcardrecording_;
}
inline void PeripheralState::_internal_set_sdcardrecording(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sdcardrecording_ = value;
}

// -------------------------------------------------------------------

// CommandPacket

// uint32 commandUid = 1;
inline void CommandPacket::clear_commanduid() {
  _impl_.commanduid_ = 0u;
}
inline ::uint32_t CommandPacket::commanduid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.CommandPacket.commandUid)
  return _internal_commanduid();
}
inline void CommandPacket::set_commanduid(::uint32_t value) {
  _internal_set_commanduid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.CommandPacket.commandUid)
}
inline ::uint32_t CommandPacket::_internal_commanduid() const {
  return _impl_.commanduid_;
}
inline void CommandPacket::_internal_set_commanduid(::uint32_t value) {
  ;
  _impl_.commanduid_ = value;
}

// .handEngine.v1.CommandCode commandCode = 2;
inline void CommandPacket::clear_commandcode() {
  _impl_.commandcode_ = 0;
}
inline ::handEngine::v1::CommandCode CommandPacket::commandcode() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.CommandPacket.commandCode)
  return _internal_commandcode();
}
inline void CommandPacket::set_commandcode(::handEngine::v1::CommandCode value) {
   _internal_set_commandcode(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.CommandPacket.commandCode)
}
inline ::handEngine::v1::CommandCode CommandPacket::_internal_commandcode() const {
  return static_cast<::handEngine::v1::CommandCode>(_impl_.commandcode_);
}
inline void CommandPacket::_internal_set_commandcode(::handEngine::v1::CommandCode value) {
  ;
  _impl_.commandcode_ = value;
}

// optional string payload = 3;
inline bool CommandPacket::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandPacket::clear_payload() {
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPacket::payload() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.CommandPacket.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandPacket::set_payload(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.CommandPacket.payload)
}
inline std::string* CommandPacket::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.CommandPacket.payload)
  return _s;
}
inline const std::string& CommandPacket::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void CommandPacket::_internal_set_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* CommandPacket::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable( GetArenaForAllocation());
}
inline std::string* CommandPacket::release_payload() {
  // @@protoc_insertion_point(field_release:handEngine.v1.CommandPacket.payload)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.payload_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandPacket::set_allocated_payload(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.CommandPacket.payload)
}

// -------------------------------------------------------------------

// DeviceEvent

// .handEngine.v1.Event event = 1;
inline void DeviceEvent::clear_event() {
  _impl_.event_ = 0;
}
inline ::handEngine::v1::Event DeviceEvent::event() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceEvent.event)
  return _internal_event();
}
inline void DeviceEvent::set_event(::handEngine::v1::Event value) {
   _internal_set_event(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceEvent.event)
}
inline ::handEngine::v1::Event DeviceEvent::_internal_event() const {
  return static_cast<::handEngine::v1::Event>(_impl_.event_);
}
inline void DeviceEvent::_internal_set_event(::handEngine::v1::Event value) {
  ;
  _impl_.event_ = value;
}

// string payload = 2;
inline void DeviceEvent::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& DeviceEvent::payload() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceEvent.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceEvent::set_payload(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payload_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceEvent.payload)
}
inline std::string* DeviceEvent::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceEvent.payload)
  return _s;
}
inline const std::string& DeviceEvent::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void DeviceEvent::_internal_set_payload(const std::string& value) {
  ;


  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceEvent::_internal_mutable_payload() {
  ;
  return _impl_.payload_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceEvent::release_payload() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceEvent.payload)
  return _impl_.payload_.Release();
}
inline void DeviceEvent::set_allocated_payload(std::string* value) {
  _impl_.payload_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceEvent.payload)
}

// -------------------------------------------------------------------

// DfuData

// uint32 dfuUid = 1;
inline void DfuData::clear_dfuuid() {
  _impl_.dfuuid_ = 0u;
}
inline ::uint32_t DfuData::dfuuid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DfuData.dfuUid)
  return _internal_dfuuid();
}
inline void DfuData::set_dfuuid(::uint32_t value) {
  _internal_set_dfuuid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DfuData.dfuUid)
}
inline ::uint32_t DfuData::_internal_dfuuid() const {
  return _impl_.dfuuid_;
}
inline void DfuData::_internal_set_dfuuid(::uint32_t value) {
  ;
  _impl_.dfuuid_ = value;
}

// optional string payload = 2;
inline bool DfuData::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DfuData::clear_payload() {
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DfuData::payload() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DfuData.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DfuData::set_payload(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DfuData.payload)
}
inline std::string* DfuData::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DfuData.payload)
  return _s;
}
inline const std::string& DfuData::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void DfuData::_internal_set_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* DfuData::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable( GetArenaForAllocation());
}
inline std::string* DfuData::release_payload() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DfuData.payload)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.payload_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DfuData::set_allocated_payload(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DfuData.payload)
}

// -------------------------------------------------------------------

// DeviceMessage

// string serialNumber = 1;
inline void DeviceMessage::clear_serialnumber() {
  _impl_.serialnumber_.ClearToEmpty();
}
inline const std::string& DeviceMessage::serialnumber() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.serialNumber)
  return _internal_serialnumber();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceMessage::set_serialnumber(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.serialnumber_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceMessage.serialNumber)
}
inline std::string* DeviceMessage::mutable_serialnumber() {
  std::string* _s = _internal_mutable_serialnumber();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.serialNumber)
  return _s;
}
inline const std::string& DeviceMessage::_internal_serialnumber() const {
  return _impl_.serialnumber_.Get();
}
inline void DeviceMessage::_internal_set_serialnumber(const std::string& value) {
  ;


  _impl_.serialnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMessage::_internal_mutable_serialnumber() {
  ;
  return _impl_.serialnumber_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceMessage::release_serialnumber() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.serialNumber)
  return _impl_.serialnumber_.Release();
}
inline void DeviceMessage::set_allocated_serialnumber(std::string* value) {
  _impl_.serialnumber_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serialnumber_.IsDefault()) {
          _impl_.serialnumber_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.serialNumber)
}

// uint32 packetCounter = 2;
inline void DeviceMessage::clear_packetcounter() {
  _impl_.packetcounter_ = 0u;
}
inline ::uint32_t DeviceMessage::packetcounter() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.packetCounter)
  return _internal_packetcounter();
}
inline void DeviceMessage::set_packetcounter(::uint32_t value) {
  _internal_set_packetcounter(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceMessage.packetCounter)
}
inline ::uint32_t DeviceMessage::_internal_packetcounter() const {
  return _impl_.packetcounter_;
}
inline void DeviceMessage::_internal_set_packetcounter(::uint32_t value) {
  ;
  _impl_.packetcounter_ = value;
}

// .handEngine.v1.DeviceInformation deviceInformation = 3;
inline bool DeviceMessage::has_deviceinformation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deviceinformation_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_deviceinformation() {
  if (_impl_.deviceinformation_ != nullptr) _impl_.deviceinformation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::handEngine::v1::DeviceInformation& DeviceMessage::_internal_deviceinformation() const {
  const ::handEngine::v1::DeviceInformation* p = _impl_.deviceinformation_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::DeviceInformation&>(
      ::handEngine::v1::_DeviceInformation_default_instance_);
}
inline const ::handEngine::v1::DeviceInformation& DeviceMessage::deviceinformation() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.deviceInformation)
  return _internal_deviceinformation();
}
inline void DeviceMessage::unsafe_arena_set_allocated_deviceinformation(
    ::handEngine::v1::DeviceInformation* deviceinformation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceinformation_);
  }
  _impl_.deviceinformation_ = deviceinformation;
  if (deviceinformation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.deviceInformation)
}
inline ::handEngine::v1::DeviceInformation* DeviceMessage::release_deviceinformation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::DeviceInformation* temp = _impl_.deviceinformation_;
  _impl_.deviceinformation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::DeviceInformation* DeviceMessage::unsafe_arena_release_deviceinformation() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.deviceInformation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::DeviceInformation* temp = _impl_.deviceinformation_;
  _impl_.deviceinformation_ = nullptr;
  return temp;
}
inline ::handEngine::v1::DeviceInformation* DeviceMessage::_internal_mutable_deviceinformation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deviceinformation_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::DeviceInformation>(GetArenaForAllocation());
    _impl_.deviceinformation_ = p;
  }
  return _impl_.deviceinformation_;
}
inline ::handEngine::v1::DeviceInformation* DeviceMessage::mutable_deviceinformation() {
  ::handEngine::v1::DeviceInformation* _msg = _internal_mutable_deviceinformation();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.deviceInformation)
  return _msg;
}
inline void DeviceMessage::set_allocated_deviceinformation(::handEngine::v1::DeviceInformation* deviceinformation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deviceinformation_;
  }
  if (deviceinformation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deviceinformation);
    if (message_arena != submessage_arena) {
      deviceinformation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceinformation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deviceinformation_ = deviceinformation;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.deviceInformation)
}

// optional .handEngine.v1.StretchSensorData stretchSensorData = 4;
inline bool DeviceMessage::has_stretchsensordata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stretchsensordata_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_stretchsensordata() {
  if (_impl_.stretchsensordata_ != nullptr) _impl_.stretchsensordata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::handEngine::v1::StretchSensorData& DeviceMessage::_internal_stretchsensordata() const {
  const ::handEngine::v1::StretchSensorData* p = _impl_.stretchsensordata_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::StretchSensorData&>(
      ::handEngine::v1::_StretchSensorData_default_instance_);
}
inline const ::handEngine::v1::StretchSensorData& DeviceMessage::stretchsensordata() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.stretchSensorData)
  return _internal_stretchsensordata();
}
inline void DeviceMessage::unsafe_arena_set_allocated_stretchsensordata(
    ::handEngine::v1::StretchSensorData* stretchsensordata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stretchsensordata_);
  }
  _impl_.stretchsensordata_ = stretchsensordata;
  if (stretchsensordata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.stretchSensorData)
}
inline ::handEngine::v1::StretchSensorData* DeviceMessage::release_stretchsensordata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::StretchSensorData* temp = _impl_.stretchsensordata_;
  _impl_.stretchsensordata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::StretchSensorData* DeviceMessage::unsafe_arena_release_stretchsensordata() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.stretchSensorData)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::StretchSensorData* temp = _impl_.stretchsensordata_;
  _impl_.stretchsensordata_ = nullptr;
  return temp;
}
inline ::handEngine::v1::StretchSensorData* DeviceMessage::_internal_mutable_stretchsensordata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stretchsensordata_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::StretchSensorData>(GetArenaForAllocation());
    _impl_.stretchsensordata_ = p;
  }
  return _impl_.stretchsensordata_;
}
inline ::handEngine::v1::StretchSensorData* DeviceMessage::mutable_stretchsensordata() {
  ::handEngine::v1::StretchSensorData* _msg = _internal_mutable_stretchsensordata();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.stretchSensorData)
  return _msg;
}
inline void DeviceMessage::set_allocated_stretchsensordata(::handEngine::v1::StretchSensorData* stretchsensordata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stretchsensordata_;
  }
  if (stretchsensordata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stretchsensordata);
    if (message_arena != submessage_arena) {
      stretchsensordata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stretchsensordata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stretchsensordata_ = stretchsensordata;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.stretchSensorData)
}

// optional .handEngine.v1.ImuData imuData = 5;
inline bool DeviceMessage::has_imudata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.imudata_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_imudata() {
  if (_impl_.imudata_ != nullptr) _impl_.imudata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::handEngine::v1::ImuData& DeviceMessage::_internal_imudata() const {
  const ::handEngine::v1::ImuData* p = _impl_.imudata_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::ImuData&>(
      ::handEngine::v1::_ImuData_default_instance_);
}
inline const ::handEngine::v1::ImuData& DeviceMessage::imudata() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.imuData)
  return _internal_imudata();
}
inline void DeviceMessage::unsafe_arena_set_allocated_imudata(
    ::handEngine::v1::ImuData* imudata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.imudata_);
  }
  _impl_.imudata_ = imudata;
  if (imudata) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.imuData)
}
inline ::handEngine::v1::ImuData* DeviceMessage::release_imudata() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::handEngine::v1::ImuData* temp = _impl_.imudata_;
  _impl_.imudata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::ImuData* DeviceMessage::unsafe_arena_release_imudata() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.imuData)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::handEngine::v1::ImuData* temp = _impl_.imudata_;
  _impl_.imudata_ = nullptr;
  return temp;
}
inline ::handEngine::v1::ImuData* DeviceMessage::_internal_mutable_imudata() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.imudata_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::ImuData>(GetArenaForAllocation());
    _impl_.imudata_ = p;
  }
  return _impl_.imudata_;
}
inline ::handEngine::v1::ImuData* DeviceMessage::mutable_imudata() {
  ::handEngine::v1::ImuData* _msg = _internal_mutable_imudata();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.imuData)
  return _msg;
}
inline void DeviceMessage::set_allocated_imudata(::handEngine::v1::ImuData* imudata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.imudata_;
  }
  if (imudata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(imudata);
    if (message_arena != submessage_arena) {
      imudata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imudata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.imudata_ = imudata;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.imuData)
}

// optional .handEngine.v1.TimeData timeData = 6;
inline bool DeviceMessage::has_timedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timedata_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_timedata() {
  if (_impl_.timedata_ != nullptr) _impl_.timedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::handEngine::v1::TimeData& DeviceMessage::_internal_timedata() const {
  const ::handEngine::v1::TimeData* p = _impl_.timedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::TimeData&>(
      ::handEngine::v1::_TimeData_default_instance_);
}
inline const ::handEngine::v1::TimeData& DeviceMessage::timedata() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.timeData)
  return _internal_timedata();
}
inline void DeviceMessage::unsafe_arena_set_allocated_timedata(
    ::handEngine::v1::TimeData* timedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timedata_);
  }
  _impl_.timedata_ = timedata;
  if (timedata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.timeData)
}
inline ::handEngine::v1::TimeData* DeviceMessage::release_timedata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::handEngine::v1::TimeData* temp = _impl_.timedata_;
  _impl_.timedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::TimeData* DeviceMessage::unsafe_arena_release_timedata() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.timeData)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::handEngine::v1::TimeData* temp = _impl_.timedata_;
  _impl_.timedata_ = nullptr;
  return temp;
}
inline ::handEngine::v1::TimeData* DeviceMessage::_internal_mutable_timedata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.timedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::TimeData>(GetArenaForAllocation());
    _impl_.timedata_ = p;
  }
  return _impl_.timedata_;
}
inline ::handEngine::v1::TimeData* DeviceMessage::mutable_timedata() {
  ::handEngine::v1::TimeData* _msg = _internal_mutable_timedata();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.timeData)
  return _msg;
}
inline void DeviceMessage::set_allocated_timedata(::handEngine::v1::TimeData* timedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timedata_;
  }
  if (timedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timedata);
    if (message_arena != submessage_arena) {
      timedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.timedata_ = timedata;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.timeData)
}

// optional .handEngine.v1.PeripheralState peripheralState = 7;
inline bool DeviceMessage::has_peripheralstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.peripheralstate_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_peripheralstate() {
  if (_impl_.peripheralstate_ != nullptr) _impl_.peripheralstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::handEngine::v1::PeripheralState& DeviceMessage::_internal_peripheralstate() const {
  const ::handEngine::v1::PeripheralState* p = _impl_.peripheralstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::PeripheralState&>(
      ::handEngine::v1::_PeripheralState_default_instance_);
}
inline const ::handEngine::v1::PeripheralState& DeviceMessage::peripheralstate() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.peripheralState)
  return _internal_peripheralstate();
}
inline void DeviceMessage::unsafe_arena_set_allocated_peripheralstate(
    ::handEngine::v1::PeripheralState* peripheralstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peripheralstate_);
  }
  _impl_.peripheralstate_ = peripheralstate;
  if (peripheralstate) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.peripheralState)
}
inline ::handEngine::v1::PeripheralState* DeviceMessage::release_peripheralstate() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::handEngine::v1::PeripheralState* temp = _impl_.peripheralstate_;
  _impl_.peripheralstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::PeripheralState* DeviceMessage::unsafe_arena_release_peripheralstate() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.peripheralState)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::handEngine::v1::PeripheralState* temp = _impl_.peripheralstate_;
  _impl_.peripheralstate_ = nullptr;
  return temp;
}
inline ::handEngine::v1::PeripheralState* DeviceMessage::_internal_mutable_peripheralstate() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.peripheralstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::PeripheralState>(GetArenaForAllocation());
    _impl_.peripheralstate_ = p;
  }
  return _impl_.peripheralstate_;
}
inline ::handEngine::v1::PeripheralState* DeviceMessage::mutable_peripheralstate() {
  ::handEngine::v1::PeripheralState* _msg = _internal_mutable_peripheralstate();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.peripheralState)
  return _msg;
}
inline void DeviceMessage::set_allocated_peripheralstate(::handEngine::v1::PeripheralState* peripheralstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.peripheralstate_;
  }
  if (peripheralstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peripheralstate);
    if (message_arena != submessage_arena) {
      peripheralstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peripheralstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.peripheralstate_ = peripheralstate;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.peripheralState)
}

// optional .handEngine.v1.CommandPacket commandResponse = 8;
inline bool DeviceMessage::has_commandresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commandresponse_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_commandresponse() {
  if (_impl_.commandresponse_ != nullptr) _impl_.commandresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::handEngine::v1::CommandPacket& DeviceMessage::_internal_commandresponse() const {
  const ::handEngine::v1::CommandPacket* p = _impl_.commandresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::CommandPacket&>(
      ::handEngine::v1::_CommandPacket_default_instance_);
}
inline const ::handEngine::v1::CommandPacket& DeviceMessage::commandresponse() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.commandResponse)
  return _internal_commandresponse();
}
inline void DeviceMessage::unsafe_arena_set_allocated_commandresponse(
    ::handEngine::v1::CommandPacket* commandresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commandresponse_);
  }
  _impl_.commandresponse_ = commandresponse;
  if (commandresponse) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.commandResponse)
}
inline ::handEngine::v1::CommandPacket* DeviceMessage::release_commandresponse() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::handEngine::v1::CommandPacket* temp = _impl_.commandresponse_;
  _impl_.commandresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::CommandPacket* DeviceMessage::unsafe_arena_release_commandresponse() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.commandResponse)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::handEngine::v1::CommandPacket* temp = _impl_.commandresponse_;
  _impl_.commandresponse_ = nullptr;
  return temp;
}
inline ::handEngine::v1::CommandPacket* DeviceMessage::_internal_mutable_commandresponse() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.commandresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::CommandPacket>(GetArenaForAllocation());
    _impl_.commandresponse_ = p;
  }
  return _impl_.commandresponse_;
}
inline ::handEngine::v1::CommandPacket* DeviceMessage::mutable_commandresponse() {
  ::handEngine::v1::CommandPacket* _msg = _internal_mutable_commandresponse();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.commandResponse)
  return _msg;
}
inline void DeviceMessage::set_allocated_commandresponse(::handEngine::v1::CommandPacket* commandresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.commandresponse_;
  }
  if (commandresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commandresponse);
    if (message_arena != submessage_arena) {
      commandresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commandresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.commandresponse_ = commandresponse;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.commandResponse)
}

// optional .handEngine.v1.DeviceEvent deviceEvent = 9;
inline bool DeviceMessage::has_deviceevent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deviceevent_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_deviceevent() {
  if (_impl_.deviceevent_ != nullptr) _impl_.deviceevent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::handEngine::v1::DeviceEvent& DeviceMessage::_internal_deviceevent() const {
  const ::handEngine::v1::DeviceEvent* p = _impl_.deviceevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::DeviceEvent&>(
      ::handEngine::v1::_DeviceEvent_default_instance_);
}
inline const ::handEngine::v1::DeviceEvent& DeviceMessage::deviceevent() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.deviceEvent)
  return _internal_deviceevent();
}
inline void DeviceMessage::unsafe_arena_set_allocated_deviceevent(
    ::handEngine::v1::DeviceEvent* deviceevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceevent_);
  }
  _impl_.deviceevent_ = deviceevent;
  if (deviceevent) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.deviceEvent)
}
inline ::handEngine::v1::DeviceEvent* DeviceMessage::release_deviceevent() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::handEngine::v1::DeviceEvent* temp = _impl_.deviceevent_;
  _impl_.deviceevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::DeviceEvent* DeviceMessage::unsafe_arena_release_deviceevent() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.deviceEvent)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::handEngine::v1::DeviceEvent* temp = _impl_.deviceevent_;
  _impl_.deviceevent_ = nullptr;
  return temp;
}
inline ::handEngine::v1::DeviceEvent* DeviceMessage::_internal_mutable_deviceevent() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.deviceevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::DeviceEvent>(GetArenaForAllocation());
    _impl_.deviceevent_ = p;
  }
  return _impl_.deviceevent_;
}
inline ::handEngine::v1::DeviceEvent* DeviceMessage::mutable_deviceevent() {
  ::handEngine::v1::DeviceEvent* _msg = _internal_mutable_deviceevent();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.deviceEvent)
  return _msg;
}
inline void DeviceMessage::set_allocated_deviceevent(::handEngine::v1::DeviceEvent* deviceevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deviceevent_;
  }
  if (deviceevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deviceevent);
    if (message_arena != submessage_arena) {
      deviceevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceevent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.deviceevent_ = deviceevent;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.deviceEvent)
}

// optional .handEngine.v1.DfuData dfuData = 10;
inline bool DeviceMessage::has_dfudata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dfudata_ != nullptr);
  return value;
}
inline void DeviceMessage::clear_dfudata() {
  if (_impl_.dfudata_ != nullptr) _impl_.dfudata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::handEngine::v1::DfuData& DeviceMessage::_internal_dfudata() const {
  const ::handEngine::v1::DfuData* p = _impl_.dfudata_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::DfuData&>(
      ::handEngine::v1::_DfuData_default_instance_);
}
inline const ::handEngine::v1::DfuData& DeviceMessage::dfudata() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceMessage.dfuData)
  return _internal_dfudata();
}
inline void DeviceMessage::unsafe_arena_set_allocated_dfudata(
    ::handEngine::v1::DfuData* dfudata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dfudata_);
  }
  _impl_.dfudata_ = dfudata;
  if (dfudata) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceMessage.dfuData)
}
inline ::handEngine::v1::DfuData* DeviceMessage::release_dfudata() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::handEngine::v1::DfuData* temp = _impl_.dfudata_;
  _impl_.dfudata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::DfuData* DeviceMessage::unsafe_arena_release_dfudata() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceMessage.dfuData)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::handEngine::v1::DfuData* temp = _impl_.dfudata_;
  _impl_.dfudata_ = nullptr;
  return temp;
}
inline ::handEngine::v1::DfuData* DeviceMessage::_internal_mutable_dfudata() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.dfudata_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::DfuData>(GetArenaForAllocation());
    _impl_.dfudata_ = p;
  }
  return _impl_.dfudata_;
}
inline ::handEngine::v1::DfuData* DeviceMessage::mutable_dfudata() {
  ::handEngine::v1::DfuData* _msg = _internal_mutable_dfudata();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceMessage.dfuData)
  return _msg;
}
inline void DeviceMessage::set_allocated_dfudata(::handEngine::v1::DfuData* dfudata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dfudata_;
  }
  if (dfudata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dfudata);
    if (message_arena != submessage_arena) {
      dfudata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dfudata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.dfudata_ = dfudata;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceMessage.dfuData)
}

// -------------------------------------------------------------------

// AggregateMessage

// repeated .handEngine.v1.DeviceMessage deviceMessage = 1;
inline int AggregateMessage::_internal_devicemessage_size() const {
  return _impl_.devicemessage_.size();
}
inline int AggregateMessage::devicemessage_size() const {
  return _internal_devicemessage_size();
}
inline void AggregateMessage::clear_devicemessage() {
  _internal_mutable_devicemessage()->Clear();
}
inline ::handEngine::v1::DeviceMessage* AggregateMessage::mutable_devicemessage(int index) {
  // @@protoc_insertion_point(field_mutable:handEngine.v1.AggregateMessage.deviceMessage)
  return _internal_mutable_devicemessage()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceMessage >*
AggregateMessage::mutable_devicemessage() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.AggregateMessage.deviceMessage)
  return _internal_mutable_devicemessage();
}
inline const ::handEngine::v1::DeviceMessage& AggregateMessage::_internal_devicemessage(int index) const {
  return _internal_devicemessage().Get(index);
}
inline const ::handEngine::v1::DeviceMessage& AggregateMessage::devicemessage(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.AggregateMessage.deviceMessage)
  return _internal_devicemessage(index);
}
inline ::handEngine::v1::DeviceMessage* AggregateMessage::_internal_add_devicemessage() {
  return _internal_mutable_devicemessage()->Add();
}
inline ::handEngine::v1::DeviceMessage* AggregateMessage::add_devicemessage() {
  ::handEngine::v1::DeviceMessage* _add = _internal_add_devicemessage();
  // @@protoc_insertion_point(field_add:handEngine.v1.AggregateMessage.deviceMessage)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceMessage >&
AggregateMessage::devicemessage() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.AggregateMessage.deviceMessage)
  return _internal_devicemessage();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceMessage>&
AggregateMessage::_internal_devicemessage() const {
  return _impl_.devicemessage_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceMessage>*
AggregateMessage::_internal_mutable_devicemessage() {
  return &_impl_.devicemessage_;
}

// -------------------------------------------------------------------

// DeviceCommand

// string targetDevice = 1;
inline void DeviceCommand::clear_targetdevice() {
  _impl_.targetdevice_.ClearToEmpty();
}
inline const std::string& DeviceCommand::targetdevice() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceCommand.targetDevice)
  return _internal_targetdevice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceCommand::set_targetdevice(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.targetdevice_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceCommand.targetDevice)
}
inline std::string* DeviceCommand::mutable_targetdevice() {
  std::string* _s = _internal_mutable_targetdevice();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceCommand.targetDevice)
  return _s;
}
inline const std::string& DeviceCommand::_internal_targetdevice() const {
  return _impl_.targetdevice_.Get();
}
inline void DeviceCommand::_internal_set_targetdevice(const std::string& value) {
  ;


  _impl_.targetdevice_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceCommand::_internal_mutable_targetdevice() {
  ;
  return _impl_.targetdevice_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceCommand::release_targetdevice() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceCommand.targetDevice)
  return _impl_.targetdevice_.Release();
}
inline void DeviceCommand::set_allocated_targetdevice(std::string* value) {
  _impl_.targetdevice_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.targetdevice_.IsDefault()) {
          _impl_.targetdevice_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceCommand.targetDevice)
}

// .handEngine.v1.CommandPacket commandPacket = 2;
inline bool DeviceCommand::has_commandpacket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commandpacket_ != nullptr);
  return value;
}
inline void DeviceCommand::clear_commandpacket() {
  if (_impl_.commandpacket_ != nullptr) _impl_.commandpacket_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::handEngine::v1::CommandPacket& DeviceCommand::_internal_commandpacket() const {
  const ::handEngine::v1::CommandPacket* p = _impl_.commandpacket_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::CommandPacket&>(
      ::handEngine::v1::_CommandPacket_default_instance_);
}
inline const ::handEngine::v1::CommandPacket& DeviceCommand::commandpacket() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceCommand.commandPacket)
  return _internal_commandpacket();
}
inline void DeviceCommand::unsafe_arena_set_allocated_commandpacket(
    ::handEngine::v1::CommandPacket* commandpacket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commandpacket_);
  }
  _impl_.commandpacket_ = commandpacket;
  if (commandpacket) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceCommand.commandPacket)
}
inline ::handEngine::v1::CommandPacket* DeviceCommand::release_commandpacket() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::CommandPacket* temp = _impl_.commandpacket_;
  _impl_.commandpacket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::CommandPacket* DeviceCommand::unsafe_arena_release_commandpacket() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceCommand.commandPacket)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::CommandPacket* temp = _impl_.commandpacket_;
  _impl_.commandpacket_ = nullptr;
  return temp;
}
inline ::handEngine::v1::CommandPacket* DeviceCommand::_internal_mutable_commandpacket() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.commandpacket_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::CommandPacket>(GetArenaForAllocation());
    _impl_.commandpacket_ = p;
  }
  return _impl_.commandpacket_;
}
inline ::handEngine::v1::CommandPacket* DeviceCommand::mutable_commandpacket() {
  ::handEngine::v1::CommandPacket* _msg = _internal_mutable_commandpacket();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceCommand.commandPacket)
  return _msg;
}
inline void DeviceCommand::set_allocated_commandpacket(::handEngine::v1::CommandPacket* commandpacket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.commandpacket_;
  }
  if (commandpacket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commandpacket);
    if (message_arena != submessage_arena) {
      commandpacket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commandpacket, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.commandpacket_ = commandpacket;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceCommand.commandPacket)
}

// optional .handEngine.v1.DfuData dfuData = 3;
inline bool DeviceCommand::has_dfudata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dfudata_ != nullptr);
  return value;
}
inline void DeviceCommand::clear_dfudata() {
  if (_impl_.dfudata_ != nullptr) _impl_.dfudata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::handEngine::v1::DfuData& DeviceCommand::_internal_dfudata() const {
  const ::handEngine::v1::DfuData* p = _impl_.dfudata_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::DfuData&>(
      ::handEngine::v1::_DfuData_default_instance_);
}
inline const ::handEngine::v1::DfuData& DeviceCommand::dfudata() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceCommand.dfuData)
  return _internal_dfudata();
}
inline void DeviceCommand::unsafe_arena_set_allocated_dfudata(
    ::handEngine::v1::DfuData* dfudata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dfudata_);
  }
  _impl_.dfudata_ = dfudata;
  if (dfudata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceCommand.dfuData)
}
inline ::handEngine::v1::DfuData* DeviceCommand::release_dfudata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::DfuData* temp = _impl_.dfudata_;
  _impl_.dfudata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::DfuData* DeviceCommand::unsafe_arena_release_dfudata() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceCommand.dfuData)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::DfuData* temp = _impl_.dfudata_;
  _impl_.dfudata_ = nullptr;
  return temp;
}
inline ::handEngine::v1::DfuData* DeviceCommand::_internal_mutable_dfudata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dfudata_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::DfuData>(GetArenaForAllocation());
    _impl_.dfudata_ = p;
  }
  return _impl_.dfudata_;
}
inline ::handEngine::v1::DfuData* DeviceCommand::mutable_dfudata() {
  ::handEngine::v1::DfuData* _msg = _internal_mutable_dfudata();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceCommand.dfuData)
  return _msg;
}
inline void DeviceCommand::set_allocated_dfudata(::handEngine::v1::DfuData* dfudata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dfudata_;
  }
  if (dfudata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dfudata);
    if (message_arena != submessage_arena) {
      dfudata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dfudata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dfudata_ = dfudata;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceCommand.dfuData)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::handEngine::v1::DeviceType> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::DeviceLocation> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::ProductFamily> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::PropertyType> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::CommandCode> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::Event> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_v1_2fdevice_2dcommunication_2eproto_2epb_2eh


