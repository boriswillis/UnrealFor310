
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: v1/performer.proto
// Original file comments:
// *
// Performer RPCs
//
// Remote control Hand Engine's performers.
#ifndef GRPC_v1_2fperformer_2eproto__INCLUDED
#define GRPC_v1_2fperformer_2eproto__INCLUDED

#include "v1/performer.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace handEngine {
namespace v1 {

// *
// Service for interacting with performers. Can list / create / remove
// performers, as well as assigning a source device to each.
//
// Performers with an assigned source can be express calibrated in order to
// normalise the visualised finger positions for the connected glove.
//
// ### Expected usage flow ###
//
// #### First time usage ####
//
// To get a performer setup and a glove device source assigned to the performer:
//
// 1. Open a connection with [GetPerformersStream()](#getperformersstream) and close this once you have
//    received the list of performers (in [PerformerNameListResponse](#performernamelistresponse)).
//
// 2. [AddPerformer()](#addperformer) (optional) (if performer doesn't exist in
//    [PerformerNameListResponse](#performernamelistresponse) then create it).
//
// 3. Ensure the glove and dongle are plugged into the computer USB port and are paired.
//
// 4. Use [DeviceService.GetGloveStream()](#getglovestream) to get a realtime list of source device IDs.
//    The reported list will change as USB dongles are inserted / pulled out of the
//    computer.
//
// 4. [SetPerformerGlove({sourceId, gloveId,profileMeta})](#setperformerglove) (if performer
//    is in [PerformerNameListResponse](#performernamelistresponse), for the profileMeta object value, use their
//    `performerId` and provide the desired glove handedness).
//
class PerformerService final {
 public:
  static constexpr char const* service_full_name() {
    return "handEngine.v1.PerformerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // * Gets a stream of performers, regardless of whether or not they have
    // been added to the stage. 
    std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::PerformerNameListResponse>> GetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::PerformerNameListResponse>>(GetPerformersStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::PerformerNameListResponse>> AsyncGetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::PerformerNameListResponse>>(AsyncGetPerformersStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::PerformerNameListResponse>> PrepareAsyncGetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::PerformerNameListResponse>>(PrepareAsyncGetPerformersStreamRaw(context, request, cq));
    }
    // * Adds a new performer to Hand Engine. 
    virtual ::grpc::Status AddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::handEngine::v1::AddPerformerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::AddPerformerResponse>> AsyncAddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::AddPerformerResponse>>(AsyncAddPerformerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::AddPerformerResponse>> PrepareAsyncAddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::AddPerformerResponse>>(PrepareAsyncAddPerformerRaw(context, request, cq));
    }
    // * Removes a performer from Hand Engine. 
    virtual ::grpc::Status RemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncRemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncRemovePerformerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncRemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncRemovePerformerRaw(context, request, cq));
    }
    // * Add or remove performer from the stage by providing the ID of the performer
    // and whether or not the performer should be staged. E.g.
    // `{performedId: 0, isStaged: true}` 
    virtual ::grpc::Status SetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncSetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncSetStagePerformerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncSetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetStagePerformerRaw(context, request, cq));
    }
    // * Assigns the source glove device to a given performer. 
    virtual ::grpc::Status SetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncSetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncSetPerformerGloveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncSetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetPerformerGloveRaw(context, request, cq));
    }
    // * Unassign a source glove device from a given performer. 
    virtual ::grpc::Status RemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncRemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncRemovePerformerGloveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncRemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncRemovePerformerGloveRaw(context, request, cq));
    }
    // * Get a stream of the performer's glove device status changes, updated periodically
    // (usually as the battery level changes).  
    std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::GloveInformationResponse>> GetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::GloveInformationResponse>>(GetGloveStatusStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::GloveInformationResponse>> AsyncGetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::GloveInformationResponse>>(AsyncGetGloveStatusStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::GloveInformationResponse>> PrepareAsyncGetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::GloveInformationResponse>>(PrepareAsyncGetGloveStatusStreamRaw(context, request, cq));
    }
    // * Start/stop express calibration. Provide `{status: 1}` to start express
    // calibration, provide `{status: 0}` to stop. The recommended duration for
    // express calibration is 20 seconds, with a 3 second countdown presented to
    // the user prior to calibration start. If you select a handedness value for a
    // disconnected glove device, you will not receive a `GloveInformationResponse`
    // until that device is connected.
    virtual ::grpc::Status SetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncSetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncSetExpressCaptureStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncSetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetExpressCaptureStatusRaw(context, request, cq));
    }
    // * Starts a smart calibration
    // Takes the performer id and the handedness of the target glove to be calibrated
    // Returns a stream containing information on each of the calibration poses,
    // and a percentile number indicating the user's progress with the current pose
    std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::SmartCalibrationResponse>> SmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::SmartCalibrationResponse>>(SmartCalibrateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::SmartCalibrationResponse>> AsyncSmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::SmartCalibrationResponse>>(AsyncSmartCalibrateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::SmartCalibrationResponse>> PrepareAsyncSmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::SmartCalibrationResponse>>(PrepareAsyncSmartCalibrateRaw(context, request, cq));
    }
    // * Capture the current glove data as a Smart Pose 
    virtual ::grpc::Status CaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncCaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncCaptureSmartPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncCaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncCaptureSmartPoseRaw(context, request, cq));
    }
    // * Manually trigger a train from current calibration configuration 
    virtual ::grpc::Status Train(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncTrain(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncTrainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncTrain(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncTrainRaw(context, request, cq));
    }
    // * Gets a stream of performers which have been configured and ready to stream 
    std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::DeviceDataResponse>> GetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::DeviceDataResponse>>(GetGlovesConnectedToProfilesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::DeviceDataResponse>> AsyncGetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::DeviceDataResponse>>(AsyncGetGlovesConnectedToProfilesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::DeviceDataResponse>> PrepareAsyncGetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::DeviceDataResponse>>(PrepareAsyncGetGlovesConnectedToProfilesRaw(context, request, cq));
    }
    // * Opens a stream of haptic data
    // Takes a profileMeta of the the performer to output haptic stimulation and the desired HapticPattern
    // Returns a stream response including the status and a message
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>> CreateHapticStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>>(CreateHapticStreamRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>> AsyncCreateHapticStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>>(AsyncCreateHapticStreamRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>> PrepareAsyncCreateHapticStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>>(PrepareAsyncCreateHapticStreamRaw(context, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // * Gets a stream of performers, regardless of whether or not they have
      // been added to the stage. 
      virtual void GetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ClientReadReactor< ::handEngine::v1::PerformerNameListResponse>* reactor) = 0;
      // * Adds a new performer to Hand Engine. 
      virtual void AddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest* request, ::handEngine::v1::AddPerformerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest* request, ::handEngine::v1::AddPerformerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Removes a performer from Hand Engine. 
      virtual void RemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Add or remove performer from the stage by providing the ID of the performer
      // and whether or not the performer should be staged. E.g.
      // `{performedId: 0, isStaged: true}` 
      virtual void SetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Assigns the source glove device to a given performer. 
      virtual void SetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Unassign a source glove device from a given performer. 
      virtual void RemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Get a stream of the performer's glove device status changes, updated periodically
      // (usually as the battery level changes).  
      virtual void GetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::grpc::ClientReadReactor< ::handEngine::v1::GloveInformationResponse>* reactor) = 0;
      // * Start/stop express calibration. Provide `{status: 1}` to start express
      // calibration, provide `{status: 0}` to stop. The recommended duration for
      // express calibration is 20 seconds, with a 3 second countdown presented to
      // the user prior to calibration start. If you select a handedness value for a
      // disconnected glove device, you will not receive a `GloveInformationResponse`
      // until that device is connected.
      virtual void SetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Starts a smart calibration
      // Takes the performer id and the handedness of the target glove to be calibrated
      // Returns a stream containing information on each of the calibration poses,
      // and a percentile number indicating the user's progress with the current pose
      virtual void SmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::grpc::ClientReadReactor< ::handEngine::v1::SmartCalibrationResponse>* reactor) = 0;
      // * Capture the current glove data as a Smart Pose 
      virtual void CaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Manually trigger a train from current calibration configuration 
      virtual void Train(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Train(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // * Gets a stream of performers which have been configured and ready to stream 
      virtual void GetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ClientReadReactor< ::handEngine::v1::DeviceDataResponse>* reactor) = 0;
      // * Opens a stream of haptic data
      // Takes a profileMeta of the the performer to output haptic stimulation and the desired HapticPattern
      // Returns a stream response including the status and a message
      virtual void CreateHapticStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::handEngine::v1::HapticsInputRequest,::handEngine::v1::HapticsStatusResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::handEngine::v1::PerformerNameListResponse>* GetPerformersStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::PerformerNameListResponse>* AsyncGetPerformersStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::PerformerNameListResponse>* PrepareAsyncGetPerformersStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::AddPerformerResponse>* AsyncAddPerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::AddPerformerResponse>* PrepareAsyncAddPerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncRemovePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncRemovePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncSetStagePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncSetStagePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncSetPerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncSetPerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncRemovePerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncRemovePerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::handEngine::v1::GloveInformationResponse>* GetGloveStatusStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::GloveInformationResponse>* AsyncGetGloveStatusStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::GloveInformationResponse>* PrepareAsyncGetGloveStatusStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncSetExpressCaptureStatusRaw(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncSetExpressCaptureStatusRaw(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::handEngine::v1::SmartCalibrationResponse>* SmartCalibrateRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::SmartCalibrationResponse>* AsyncSmartCalibrateRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::SmartCalibrationResponse>* PrepareAsyncSmartCalibrateRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncCaptureSmartPoseRaw(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncCaptureSmartPoseRaw(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncTrainRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncTrainRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::handEngine::v1::DeviceDataResponse>* GetGlovesConnectedToProfilesRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::DeviceDataResponse>* AsyncGetGlovesConnectedToProfilesRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::DeviceDataResponse>* PrepareAsyncGetGlovesConnectedToProfilesRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* CreateHapticStreamRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* AsyncCreateHapticStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* PrepareAsyncCreateHapticStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::PerformerNameListResponse>> GetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::PerformerNameListResponse>>(GetPerformersStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::PerformerNameListResponse>> AsyncGetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::PerformerNameListResponse>>(AsyncGetPerformersStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::PerformerNameListResponse>> PrepareAsyncGetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::PerformerNameListResponse>>(PrepareAsyncGetPerformersStreamRaw(context, request, cq));
    }
    ::grpc::Status AddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::handEngine::v1::AddPerformerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::AddPerformerResponse>> AsyncAddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::AddPerformerResponse>>(AsyncAddPerformerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::AddPerformerResponse>> PrepareAsyncAddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::AddPerformerResponse>>(PrepareAsyncAddPerformerRaw(context, request, cq));
    }
    ::grpc::Status RemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncRemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncRemovePerformerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncRemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncRemovePerformerRaw(context, request, cq));
    }
    ::grpc::Status SetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncSetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncSetStagePerformerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncSetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetStagePerformerRaw(context, request, cq));
    }
    ::grpc::Status SetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncSetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncSetPerformerGloveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncSetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetPerformerGloveRaw(context, request, cq));
    }
    ::grpc::Status RemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncRemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncRemovePerformerGloveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncRemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncRemovePerformerGloveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::GloveInformationResponse>> GetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::GloveInformationResponse>>(GetGloveStatusStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::GloveInformationResponse>> AsyncGetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::GloveInformationResponse>>(AsyncGetGloveStatusStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::GloveInformationResponse>> PrepareAsyncGetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::GloveInformationResponse>>(PrepareAsyncGetGloveStatusStreamRaw(context, request, cq));
    }
    ::grpc::Status SetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncSetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncSetExpressCaptureStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncSetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetExpressCaptureStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::SmartCalibrationResponse>> SmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::SmartCalibrationResponse>>(SmartCalibrateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::SmartCalibrationResponse>> AsyncSmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::SmartCalibrationResponse>>(AsyncSmartCalibrateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::SmartCalibrationResponse>> PrepareAsyncSmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::SmartCalibrationResponse>>(PrepareAsyncSmartCalibrateRaw(context, request, cq));
    }
    ::grpc::Status CaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncCaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncCaptureSmartPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncCaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncCaptureSmartPoseRaw(context, request, cq));
    }
    ::grpc::Status Train(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncTrain(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncTrainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncTrain(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncTrainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::DeviceDataResponse>> GetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::DeviceDataResponse>>(GetGlovesConnectedToProfilesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::DeviceDataResponse>> AsyncGetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::DeviceDataResponse>>(AsyncGetGlovesConnectedToProfilesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::DeviceDataResponse>> PrepareAsyncGetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::DeviceDataResponse>>(PrepareAsyncGetGlovesConnectedToProfilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>> CreateHapticStream(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>>(CreateHapticStreamRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>> AsyncCreateHapticStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>>(AsyncCreateHapticStreamRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>> PrepareAsyncCreateHapticStream(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>>(PrepareAsyncCreateHapticStreamRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetPerformersStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ClientReadReactor< ::handEngine::v1::PerformerNameListResponse>* reactor) override;
      void AddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest* request, ::handEngine::v1::AddPerformerResponse* response, std::function<void(::grpc::Status)>) override;
      void AddPerformer(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest* request, ::handEngine::v1::AddPerformerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void RemovePerformer(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void SetStagePerformer(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void RemovePerformerGlove(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGloveStatusStream(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::grpc::ClientReadReactor< ::handEngine::v1::GloveInformationResponse>* reactor) override;
      void SetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void SetExpressCaptureStatus(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SmartCalibrate(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::grpc::ClientReadReactor< ::handEngine::v1::SmartCalibrationResponse>* reactor) override;
      void CaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void CaptureSmartPose(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Train(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void Train(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGlovesConnectedToProfiles(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ClientReadReactor< ::handEngine::v1::DeviceDataResponse>* reactor) override;
      void CreateHapticStream(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::handEngine::v1::HapticsInputRequest,::handEngine::v1::HapticsStatusResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::handEngine::v1::PerformerNameListResponse>* GetPerformersStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::PerformerNameListResponse>* AsyncGetPerformersStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::PerformerNameListResponse>* PrepareAsyncGetPerformersStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::AddPerformerResponse>* AsyncAddPerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::AddPerformerResponse>* PrepareAsyncAddPerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::AddPerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncRemovePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncRemovePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::RemovePerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncSetStagePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncSetStagePerformerRaw(::grpc::ClientContext* context, const ::handEngine::v1::StagePerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncSetPerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncSetPerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncRemovePerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncRemovePerformerGloveRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::handEngine::v1::GloveInformationResponse>* GetGloveStatusStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::GloveInformationResponse>* AsyncGetGloveStatusStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::GloveInformationResponse>* PrepareAsyncGetGloveStatusStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncSetExpressCaptureStatusRaw(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncSetExpressCaptureStatusRaw(::grpc::ClientContext* context, const ::handEngine::v1::ExpressCaptureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::handEngine::v1::SmartCalibrationResponse>* SmartCalibrateRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::SmartCalibrationResponse>* AsyncSmartCalibrateRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::SmartCalibrationResponse>* PrepareAsyncSmartCalibrateRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncCaptureSmartPoseRaw(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncCaptureSmartPoseRaw(::grpc::ClientContext* context, const ::handEngine::v1::CaptureSmartPoseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncTrainRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncTrainRaw(::grpc::ClientContext* context, const ::handEngine::v1::ProfileMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::handEngine::v1::DeviceDataResponse>* GetGlovesConnectedToProfilesRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::DeviceDataResponse>* AsyncGetGlovesConnectedToProfilesRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::DeviceDataResponse>* PrepareAsyncGetGlovesConnectedToProfilesRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* CreateHapticStreamRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* AsyncCreateHapticStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* PrepareAsyncCreateHapticStreamRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetPerformersStream_;
    const ::grpc::internal::RpcMethod rpcmethod_AddPerformer_;
    const ::grpc::internal::RpcMethod rpcmethod_RemovePerformer_;
    const ::grpc::internal::RpcMethod rpcmethod_SetStagePerformer_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPerformerGlove_;
    const ::grpc::internal::RpcMethod rpcmethod_RemovePerformerGlove_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGloveStatusStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SetExpressCaptureStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_SmartCalibrate_;
    const ::grpc::internal::RpcMethod rpcmethod_CaptureSmartPose_;
    const ::grpc::internal::RpcMethod rpcmethod_Train_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGlovesConnectedToProfiles_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateHapticStream_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // * Gets a stream of performers, regardless of whether or not they have
    // been added to the stage. 
    virtual ::grpc::Status GetPerformersStream(::grpc::ServerContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* writer);
    // * Adds a new performer to Hand Engine. 
    virtual ::grpc::Status AddPerformer(::grpc::ServerContext* context, const ::handEngine::v1::AddPerformerRequest* request, ::handEngine::v1::AddPerformerResponse* response);
    // * Removes a performer from Hand Engine. 
    virtual ::grpc::Status RemovePerformer(::grpc::ServerContext* context, const ::handEngine::v1::RemovePerformerRequest* request, ::handEngine::v1::BlankResponse* response);
    // * Add or remove performer from the stage by providing the ID of the performer
    // and whether or not the performer should be staged. E.g.
    // `{performedId: 0, isStaged: true}` 
    virtual ::grpc::Status SetStagePerformer(::grpc::ServerContext* context, const ::handEngine::v1::StagePerformerRequest* request, ::handEngine::v1::BlankResponse* response);
    // * Assigns the source glove device to a given performer. 
    virtual ::grpc::Status SetPerformerGlove(::grpc::ServerContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest* request, ::handEngine::v1::BlankResponse* response);
    // * Unassign a source glove device from a given performer. 
    virtual ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response);
    // * Get a stream of the performer's glove device status changes, updated periodically
    // (usually as the battery level changes).  
    virtual ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* context, const ::handEngine::v1::ProfileMeta* request, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* writer);
    // * Start/stop express calibration. Provide `{status: 1}` to start express
    // calibration, provide `{status: 0}` to stop. The recommended duration for
    // express calibration is 20 seconds, with a 3 second countdown presented to
    // the user prior to calibration start. If you select a handedness value for a
    // disconnected glove device, you will not receive a `GloveInformationResponse`
    // until that device is connected.
    virtual ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* context, const ::handEngine::v1::ExpressCaptureRequest* request, ::handEngine::v1::BlankResponse* response);
    // * Starts a smart calibration
    // Takes the performer id and the handedness of the target glove to be calibrated
    // Returns a stream containing information on each of the calibration poses,
    // and a percentile number indicating the user's progress with the current pose
    virtual ::grpc::Status SmartCalibrate(::grpc::ServerContext* context, const ::handEngine::v1::ProfileMeta* request, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* writer);
    // * Capture the current glove data as a Smart Pose 
    virtual ::grpc::Status CaptureSmartPose(::grpc::ServerContext* context, const ::handEngine::v1::CaptureSmartPoseRequest* request, ::handEngine::v1::BlankResponse* response);
    // * Manually trigger a train from current calibration configuration 
    virtual ::grpc::Status Train(::grpc::ServerContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response);
    // * Gets a stream of performers which have been configured and ready to stream 
    virtual ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* writer);
    // * Opens a stream of haptic data
    // Takes a profileMeta of the the performer to output haptic stimulation and the desired HapticPattern
    // Returns a stream response including the status and a message
    virtual ::grpc::Status CreateHapticStream(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPerformersStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPerformersStream() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetPerformersStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPerformersStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPerformersStream(::grpc::ServerContext* context, ::handEngine::v1::BlankRequest* request, ::grpc::ServerAsyncWriter< ::handEngine::v1::PerformerNameListResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddPerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddPerformer() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_AddPerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPerformer(::grpc::ServerContext* context, ::handEngine::v1::AddPerformerRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::AddPerformerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemovePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemovePerformer() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RemovePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePerformer(::grpc::ServerContext* context, ::handEngine::v1::RemovePerformerRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetStagePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetStagePerformer() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetStagePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStagePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStagePerformer(::grpc::ServerContext* context, ::handEngine::v1::StagePerformerRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPerformerGlove() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetPerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPerformerGlove(::grpc::ServerContext* context, ::handEngine::v1::AssignGloveToPerformerRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemovePerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemovePerformerGlove() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_RemovePerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePerformerGlove(::grpc::ServerContext* context, ::handEngine::v1::ProfileMeta* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGloveStatusStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGloveStatusStream() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetGloveStatusStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGloveStatusStream(::grpc::ServerContext* context, ::handEngine::v1::ProfileMeta* request, ::grpc::ServerAsyncWriter< ::handEngine::v1::GloveInformationResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetExpressCaptureStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetExpressCaptureStatus() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SetExpressCaptureStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExpressCaptureStatus(::grpc::ServerContext* context, ::handEngine::v1::ExpressCaptureRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SmartCalibrate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SmartCalibrate() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SmartCalibrate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SmartCalibrate(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSmartCalibrate(::grpc::ServerContext* context, ::handEngine::v1::ProfileMeta* request, ::grpc::ServerAsyncWriter< ::handEngine::v1::SmartCalibrationResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CaptureSmartPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CaptureSmartPose() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_CaptureSmartPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaptureSmartPose(::grpc::ServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCaptureSmartPose(::grpc::ServerContext* context, ::handEngine::v1::CaptureSmartPoseRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Train : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Train() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Train() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Train(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrain(::grpc::ServerContext* context, ::handEngine::v1::ProfileMeta* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGlovesConnectedToProfiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGlovesConnectedToProfiles() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetGlovesConnectedToProfiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGlovesConnectedToProfiles(::grpc::ServerContext* context, ::handEngine::v1::BlankRequest* request, ::grpc::ServerAsyncWriter< ::handEngine::v1::DeviceDataResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateHapticStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateHapticStream() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_CreateHapticStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateHapticStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateHapticStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(12, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetPerformersStream<WithAsyncMethod_AddPerformer<WithAsyncMethod_RemovePerformer<WithAsyncMethod_SetStagePerformer<WithAsyncMethod_SetPerformerGlove<WithAsyncMethod_RemovePerformerGlove<WithAsyncMethod_GetGloveStatusStream<WithAsyncMethod_SetExpressCaptureStatus<WithAsyncMethod_SmartCalibrate<WithAsyncMethod_CaptureSmartPose<WithAsyncMethod_Train<WithAsyncMethod_GetGlovesConnectedToProfiles<WithAsyncMethod_CreateHapticStream<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetPerformersStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPerformersStream() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::handEngine::v1::BlankRequest, ::handEngine::v1::PerformerNameListResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::BlankRequest* request) { return this->GetPerformersStream(context, request); }));
    }
    ~WithCallbackMethod_GetPerformersStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPerformersStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::handEngine::v1::PerformerNameListResponse>* GetPerformersStream(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddPerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddPerformer() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::AddPerformerRequest, ::handEngine::v1::AddPerformerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::AddPerformerRequest* request, ::handEngine::v1::AddPerformerResponse* response) { return this->AddPerformer(context, request, response); }));}
    void SetMessageAllocatorFor_AddPerformer(
        ::grpc::MessageAllocator< ::handEngine::v1::AddPerformerRequest, ::handEngine::v1::AddPerformerResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::AddPerformerRequest, ::handEngine::v1::AddPerformerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddPerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPerformer(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemovePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemovePerformer() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::RemovePerformerRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::RemovePerformerRequest* request, ::handEngine::v1::BlankResponse* response) { return this->RemovePerformer(context, request, response); }));}
    void SetMessageAllocatorFor_RemovePerformer(
        ::grpc::MessageAllocator< ::handEngine::v1::RemovePerformerRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::RemovePerformerRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemovePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemovePerformer(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetStagePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetStagePerformer() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::StagePerformerRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::StagePerformerRequest* request, ::handEngine::v1::BlankResponse* response) { return this->SetStagePerformer(context, request, response); }));}
    void SetMessageAllocatorFor_SetStagePerformer(
        ::grpc::MessageAllocator< ::handEngine::v1::StagePerformerRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::StagePerformerRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetStagePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStagePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetStagePerformer(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPerformerGlove() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::AssignGloveToPerformerRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::AssignGloveToPerformerRequest* request, ::handEngine::v1::BlankResponse* response) { return this->SetPerformerGlove(context, request, response); }));}
    void SetMessageAllocatorFor_SetPerformerGlove(
        ::grpc::MessageAllocator< ::handEngine::v1::AssignGloveToPerformerRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::AssignGloveToPerformerRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPerformerGlove(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemovePerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemovePerformerGlove() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response) { return this->RemovePerformerGlove(context, request, response); }));}
    void SetMessageAllocatorFor_RemovePerformerGlove(
        ::grpc::MessageAllocator< ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemovePerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemovePerformerGlove(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGloveStatusStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGloveStatusStream() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::handEngine::v1::ProfileMeta, ::handEngine::v1::GloveInformationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::ProfileMeta* request) { return this->GetGloveStatusStream(context, request); }));
    }
    ~WithCallbackMethod_GetGloveStatusStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::handEngine::v1::GloveInformationResponse>* GetGloveStatusStream(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetExpressCaptureStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetExpressCaptureStatus() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::ExpressCaptureRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::ExpressCaptureRequest* request, ::handEngine::v1::BlankResponse* response) { return this->SetExpressCaptureStatus(context, request, response); }));}
    void SetMessageAllocatorFor_SetExpressCaptureStatus(
        ::grpc::MessageAllocator< ::handEngine::v1::ExpressCaptureRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::ExpressCaptureRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetExpressCaptureStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetExpressCaptureStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SmartCalibrate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SmartCalibrate() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::handEngine::v1::ProfileMeta, ::handEngine::v1::SmartCalibrationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::ProfileMeta* request) { return this->SmartCalibrate(context, request); }));
    }
    ~WithCallbackMethod_SmartCalibrate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SmartCalibrate(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::handEngine::v1::SmartCalibrationResponse>* SmartCalibrate(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CaptureSmartPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CaptureSmartPose() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::CaptureSmartPoseRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::CaptureSmartPoseRequest* request, ::handEngine::v1::BlankResponse* response) { return this->CaptureSmartPose(context, request, response); }));}
    void SetMessageAllocatorFor_CaptureSmartPose(
        ::grpc::MessageAllocator< ::handEngine::v1::CaptureSmartPoseRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::CaptureSmartPoseRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CaptureSmartPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaptureSmartPose(::grpc::ServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CaptureSmartPose(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Train : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Train() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::ProfileMeta* request, ::handEngine::v1::BlankResponse* response) { return this->Train(context, request, response); }));}
    void SetMessageAllocatorFor_Train(
        ::grpc::MessageAllocator< ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Train() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Train(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Train(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGlovesConnectedToProfiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGlovesConnectedToProfiles() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::handEngine::v1::BlankRequest, ::handEngine::v1::DeviceDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::BlankRequest* request) { return this->GetGlovesConnectedToProfiles(context, request); }));
    }
    ~WithCallbackMethod_GetGlovesConnectedToProfiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::handEngine::v1::DeviceDataResponse>* GetGlovesConnectedToProfiles(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateHapticStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateHapticStream() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackBidiHandler< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->CreateHapticStream(context); }));
    }
    ~WithCallbackMethod_CreateHapticStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateHapticStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::handEngine::v1::HapticsInputRequest, ::handEngine::v1::HapticsStatusResponse>* CreateHapticStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_GetPerformersStream<WithCallbackMethod_AddPerformer<WithCallbackMethod_RemovePerformer<WithCallbackMethod_SetStagePerformer<WithCallbackMethod_SetPerformerGlove<WithCallbackMethod_RemovePerformerGlove<WithCallbackMethod_GetGloveStatusStream<WithCallbackMethod_SetExpressCaptureStatus<WithCallbackMethod_SmartCalibrate<WithCallbackMethod_CaptureSmartPose<WithCallbackMethod_Train<WithCallbackMethod_GetGlovesConnectedToProfiles<WithCallbackMethod_CreateHapticStream<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetPerformersStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPerformersStream() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetPerformersStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPerformersStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddPerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddPerformer() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_AddPerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemovePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemovePerformer() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RemovePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetStagePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetStagePerformer() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetStagePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStagePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPerformerGlove() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetPerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemovePerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemovePerformerGlove() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_RemovePerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGloveStatusStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGloveStatusStream() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetGloveStatusStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetExpressCaptureStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetExpressCaptureStatus() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SetExpressCaptureStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SmartCalibrate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SmartCalibrate() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SmartCalibrate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SmartCalibrate(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CaptureSmartPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CaptureSmartPose() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_CaptureSmartPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaptureSmartPose(::grpc::ServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Train : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Train() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Train() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Train(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGlovesConnectedToProfiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGlovesConnectedToProfiles() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetGlovesConnectedToProfiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateHapticStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateHapticStream() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_CreateHapticStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateHapticStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPerformersStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPerformersStream() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetPerformersStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPerformersStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPerformersStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddPerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddPerformer() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_AddPerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddPerformer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemovePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemovePerformer() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RemovePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePerformer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetStagePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetStagePerformer() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SetStagePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStagePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStagePerformer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPerformerGlove() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetPerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPerformerGlove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemovePerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemovePerformerGlove() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_RemovePerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePerformerGlove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGloveStatusStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGloveStatusStream() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetGloveStatusStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGloveStatusStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetExpressCaptureStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetExpressCaptureStatus() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SetExpressCaptureStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetExpressCaptureStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SmartCalibrate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SmartCalibrate() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SmartCalibrate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SmartCalibrate(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSmartCalibrate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CaptureSmartPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CaptureSmartPose() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_CaptureSmartPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaptureSmartPose(::grpc::ServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCaptureSmartPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Train : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Train() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Train() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Train(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGlovesConnectedToProfiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGlovesConnectedToProfiles() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetGlovesConnectedToProfiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGlovesConnectedToProfiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateHapticStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateHapticStream() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_CreateHapticStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateHapticStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateHapticStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(12, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPerformersStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPerformersStream() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetPerformersStream(context, request); }));
    }
    ~WithRawCallbackMethod_GetPerformersStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPerformersStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetPerformersStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddPerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddPerformer() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddPerformer(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddPerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddPerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddPerformer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemovePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemovePerformer() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemovePerformer(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemovePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemovePerformer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetStagePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetStagePerformer() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetStagePerformer(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetStagePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStagePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetStagePerformer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPerformerGlove() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPerformerGlove(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPerformerGlove(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemovePerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemovePerformerGlove() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemovePerformerGlove(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemovePerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemovePerformerGlove(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGloveStatusStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGloveStatusStream() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetGloveStatusStream(context, request); }));
    }
    ~WithRawCallbackMethod_GetGloveStatusStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetGloveStatusStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetExpressCaptureStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetExpressCaptureStatus() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetExpressCaptureStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetExpressCaptureStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetExpressCaptureStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SmartCalibrate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SmartCalibrate() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SmartCalibrate(context, request); }));
    }
    ~WithRawCallbackMethod_SmartCalibrate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SmartCalibrate(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SmartCalibrate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CaptureSmartPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CaptureSmartPose() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CaptureSmartPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_CaptureSmartPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CaptureSmartPose(::grpc::ServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CaptureSmartPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Train : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Train() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Train(context, request, response); }));
    }
    ~WithRawCallbackMethod_Train() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Train(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Train(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGlovesConnectedToProfiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGlovesConnectedToProfiles() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetGlovesConnectedToProfiles(context, request); }));
    }
    ~WithRawCallbackMethod_GetGlovesConnectedToProfiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetGlovesConnectedToProfiles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateHapticStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateHapticStream() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->CreateHapticStream(context); }));
    }
    ~WithRawCallbackMethod_CreateHapticStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateHapticStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::handEngine::v1::HapticsStatusResponse, ::handEngine::v1::HapticsInputRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* CreateHapticStream(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddPerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddPerformer() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::AddPerformerRequest, ::handEngine::v1::AddPerformerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::AddPerformerRequest, ::handEngine::v1::AddPerformerResponse>* streamer) {
                       return this->StreamedAddPerformer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddPerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddPerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AddPerformerRequest* /*request*/, ::handEngine::v1::AddPerformerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddPerformer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::AddPerformerRequest,::handEngine::v1::AddPerformerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemovePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemovePerformer() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::RemovePerformerRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::RemovePerformerRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedRemovePerformer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemovePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemovePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RemovePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemovePerformer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::RemovePerformerRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetStagePerformer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetStagePerformer() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::StagePerformerRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::StagePerformerRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedSetStagePerformer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetStagePerformer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetStagePerformer(::grpc::ServerContext* /*context*/, const ::handEngine::v1::StagePerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetStagePerformer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::StagePerformerRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPerformerGlove() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::AssignGloveToPerformerRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::AssignGloveToPerformerRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedSetPerformerGlove(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::AssignGloveToPerformerRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPerformerGlove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::AssignGloveToPerformerRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemovePerformerGlove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemovePerformerGlove() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedRemovePerformerGlove(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemovePerformerGlove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemovePerformerGlove(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemovePerformerGlove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::ProfileMeta,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetExpressCaptureStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetExpressCaptureStatus() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::ExpressCaptureRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::ExpressCaptureRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedSetExpressCaptureStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetExpressCaptureStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetExpressCaptureStatus(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ExpressCaptureRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetExpressCaptureStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::ExpressCaptureRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CaptureSmartPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CaptureSmartPose() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::CaptureSmartPoseRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::CaptureSmartPoseRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedCaptureSmartPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CaptureSmartPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CaptureSmartPose(::grpc::ServerContext* /*context*/, const ::handEngine::v1::CaptureSmartPoseRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCaptureSmartPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::CaptureSmartPoseRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Train : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Train() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::ProfileMeta, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedTrain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Train() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Train(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTrain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::ProfileMeta,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AddPerformer<WithStreamedUnaryMethod_RemovePerformer<WithStreamedUnaryMethod_SetStagePerformer<WithStreamedUnaryMethod_SetPerformerGlove<WithStreamedUnaryMethod_RemovePerformerGlove<WithStreamedUnaryMethod_SetExpressCaptureStatus<WithStreamedUnaryMethod_CaptureSmartPose<WithStreamedUnaryMethod_Train<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetPerformersStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetPerformersStream() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::handEngine::v1::BlankRequest, ::handEngine::v1::PerformerNameListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::handEngine::v1::BlankRequest, ::handEngine::v1::PerformerNameListResponse>* streamer) {
                       return this->StreamedGetPerformersStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetPerformersStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPerformersStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::PerformerNameListResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetPerformersStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::handEngine::v1::BlankRequest,::handEngine::v1::PerformerNameListResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetGloveStatusStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetGloveStatusStream() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::handEngine::v1::ProfileMeta, ::handEngine::v1::GloveInformationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::handEngine::v1::ProfileMeta, ::handEngine::v1::GloveInformationResponse>* streamer) {
                       return this->StreamedGetGloveStatusStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetGloveStatusStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGloveStatusStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::GloveInformationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetGloveStatusStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::handEngine::v1::ProfileMeta,::handEngine::v1::GloveInformationResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SmartCalibrate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SmartCalibrate() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::handEngine::v1::ProfileMeta, ::handEngine::v1::SmartCalibrationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::handEngine::v1::ProfileMeta, ::handEngine::v1::SmartCalibrationResponse>* streamer) {
                       return this->StreamedSmartCalibrate(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SmartCalibrate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SmartCalibrate(::grpc::ServerContext* /*context*/, const ::handEngine::v1::ProfileMeta* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::SmartCalibrationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSmartCalibrate(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::handEngine::v1::ProfileMeta,::handEngine::v1::SmartCalibrationResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetGlovesConnectedToProfiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetGlovesConnectedToProfiles() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::handEngine::v1::BlankRequest, ::handEngine::v1::DeviceDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::handEngine::v1::BlankRequest, ::handEngine::v1::DeviceDataResponse>* streamer) {
                       return this->StreamedGetGlovesConnectedToProfiles(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetGlovesConnectedToProfiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGlovesConnectedToProfiles(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::DeviceDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetGlovesConnectedToProfiles(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::handEngine::v1::BlankRequest,::handEngine::v1::DeviceDataResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetPerformersStream<WithSplitStreamingMethod_GetGloveStatusStream<WithSplitStreamingMethod_SmartCalibrate<WithSplitStreamingMethod_GetGlovesConnectedToProfiles<Service > > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_GetPerformersStream<WithStreamedUnaryMethod_AddPerformer<WithStreamedUnaryMethod_RemovePerformer<WithStreamedUnaryMethod_SetStagePerformer<WithStreamedUnaryMethod_SetPerformerGlove<WithStreamedUnaryMethod_RemovePerformerGlove<WithSplitStreamingMethod_GetGloveStatusStream<WithStreamedUnaryMethod_SetExpressCaptureStatus<WithSplitStreamingMethod_SmartCalibrate<WithStreamedUnaryMethod_CaptureSmartPose<WithStreamedUnaryMethod_Train<WithSplitStreamingMethod_GetGlovesConnectedToProfiles<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace handEngine


#endif  // GRPC_v1_2fperformer_2eproto__INCLUDED

