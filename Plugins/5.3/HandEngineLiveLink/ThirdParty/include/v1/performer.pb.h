
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/performer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2fperformer_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_v1_2fperformer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
#include "v1/_api.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_v1_2fperformer_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2fperformer_2eproto {
  static const ::uint32_t offsets[];
};
namespace handEngine {
namespace v1 {
class AddPerformerRequest;
struct AddPerformerRequestDefaultTypeInternal;
extern AddPerformerRequestDefaultTypeInternal _AddPerformerRequest_default_instance_;
class AddPerformerResponse;
struct AddPerformerResponseDefaultTypeInternal;
extern AddPerformerResponseDefaultTypeInternal _AddPerformerResponse_default_instance_;
class AssignGloveToPerformerRequest;
struct AssignGloveToPerformerRequestDefaultTypeInternal;
extern AssignGloveToPerformerRequestDefaultTypeInternal _AssignGloveToPerformerRequest_default_instance_;
class CaptureSmartPoseRequest;
struct CaptureSmartPoseRequestDefaultTypeInternal;
extern CaptureSmartPoseRequestDefaultTypeInternal _CaptureSmartPoseRequest_default_instance_;
class DeviceData;
struct DeviceDataDefaultTypeInternal;
extern DeviceDataDefaultTypeInternal _DeviceData_default_instance_;
class DeviceDataResponse;
struct DeviceDataResponseDefaultTypeInternal;
extern DeviceDataResponseDefaultTypeInternal _DeviceDataResponse_default_instance_;
class ExpressCaptureRequest;
struct ExpressCaptureRequestDefaultTypeInternal;
extern ExpressCaptureRequestDefaultTypeInternal _ExpressCaptureRequest_default_instance_;
class HapticsInputRequest;
struct HapticsInputRequestDefaultTypeInternal;
extern HapticsInputRequestDefaultTypeInternal _HapticsInputRequest_default_instance_;
class HapticsStatusResponse;
struct HapticsStatusResponseDefaultTypeInternal;
extern HapticsStatusResponseDefaultTypeInternal _HapticsStatusResponse_default_instance_;
class PerformerData;
struct PerformerDataDefaultTypeInternal;
extern PerformerDataDefaultTypeInternal _PerformerData_default_instance_;
class PerformerNameListResponse;
struct PerformerNameListResponseDefaultTypeInternal;
extern PerformerNameListResponseDefaultTypeInternal _PerformerNameListResponse_default_instance_;
class RemovePerformerRequest;
struct RemovePerformerRequestDefaultTypeInternal;
extern RemovePerformerRequestDefaultTypeInternal _RemovePerformerRequest_default_instance_;
class SmartCalibrationResponse;
struct SmartCalibrationResponseDefaultTypeInternal;
extern SmartCalibrationResponseDefaultTypeInternal _SmartCalibrationResponse_default_instance_;
class SmartPoseCapture;
struct SmartPoseCaptureDefaultTypeInternal;
extern SmartPoseCaptureDefaultTypeInternal _SmartPoseCapture_default_instance_;
class StagePerformerRequest;
struct StagePerformerRequestDefaultTypeInternal;
extern StagePerformerRequestDefaultTypeInternal _StagePerformerRequest_default_instance_;
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template <>
::handEngine::v1::AddPerformerRequest* Arena::CreateMaybeMessage<::handEngine::v1::AddPerformerRequest>(Arena*);
template <>
::handEngine::v1::AddPerformerResponse* Arena::CreateMaybeMessage<::handEngine::v1::AddPerformerResponse>(Arena*);
template <>
::handEngine::v1::AssignGloveToPerformerRequest* Arena::CreateMaybeMessage<::handEngine::v1::AssignGloveToPerformerRequest>(Arena*);
template <>
::handEngine::v1::CaptureSmartPoseRequest* Arena::CreateMaybeMessage<::handEngine::v1::CaptureSmartPoseRequest>(Arena*);
template <>
::handEngine::v1::DeviceData* Arena::CreateMaybeMessage<::handEngine::v1::DeviceData>(Arena*);
template <>
::handEngine::v1::DeviceDataResponse* Arena::CreateMaybeMessage<::handEngine::v1::DeviceDataResponse>(Arena*);
template <>
::handEngine::v1::ExpressCaptureRequest* Arena::CreateMaybeMessage<::handEngine::v1::ExpressCaptureRequest>(Arena*);
template <>
::handEngine::v1::HapticsInputRequest* Arena::CreateMaybeMessage<::handEngine::v1::HapticsInputRequest>(Arena*);
template <>
::handEngine::v1::HapticsStatusResponse* Arena::CreateMaybeMessage<::handEngine::v1::HapticsStatusResponse>(Arena*);
template <>
::handEngine::v1::PerformerData* Arena::CreateMaybeMessage<::handEngine::v1::PerformerData>(Arena*);
template <>
::handEngine::v1::PerformerNameListResponse* Arena::CreateMaybeMessage<::handEngine::v1::PerformerNameListResponse>(Arena*);
template <>
::handEngine::v1::RemovePerformerRequest* Arena::CreateMaybeMessage<::handEngine::v1::RemovePerformerRequest>(Arena*);
template <>
::handEngine::v1::SmartCalibrationResponse* Arena::CreateMaybeMessage<::handEngine::v1::SmartCalibrationResponse>(Arena*);
template <>
::handEngine::v1::SmartPoseCapture* Arena::CreateMaybeMessage<::handEngine::v1::SmartPoseCapture>(Arena*);
template <>
::handEngine::v1::StagePerformerRequest* Arena::CreateMaybeMessage<::handEngine::v1::StagePerformerRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace handEngine {
namespace v1 {
enum ExpressCaptureRequest_CalibrationStatus : int {
  ExpressCaptureRequest_CalibrationStatus_START = 0,
  ExpressCaptureRequest_CalibrationStatus_STOP = 1,
  ExpressCaptureRequest_CalibrationStatus_ExpressCaptureRequest_CalibrationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExpressCaptureRequest_CalibrationStatus_ExpressCaptureRequest_CalibrationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExpressCaptureRequest_CalibrationStatus_IsValid(int value);
constexpr ExpressCaptureRequest_CalibrationStatus ExpressCaptureRequest_CalibrationStatus_CalibrationStatus_MIN = static_cast<ExpressCaptureRequest_CalibrationStatus>(0);
constexpr ExpressCaptureRequest_CalibrationStatus ExpressCaptureRequest_CalibrationStatus_CalibrationStatus_MAX = static_cast<ExpressCaptureRequest_CalibrationStatus>(1);
constexpr int ExpressCaptureRequest_CalibrationStatus_CalibrationStatus_ARRAYSIZE = 1 + 1;
const std::string& ExpressCaptureRequest_CalibrationStatus_Name(ExpressCaptureRequest_CalibrationStatus value);
template <typename T>
const std::string& ExpressCaptureRequest_CalibrationStatus_Name(T value) {
  static_assert(std::is_same<T, ExpressCaptureRequest_CalibrationStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CalibrationStatus_Name().");
  return ExpressCaptureRequest_CalibrationStatus_Name(static_cast<ExpressCaptureRequest_CalibrationStatus>(value));
}
const std::string& ExpressCaptureRequest_CalibrationStatus_Name(ExpressCaptureRequest_CalibrationStatus value);
bool ExpressCaptureRequest_CalibrationStatus_Parse(absl::string_view name, ExpressCaptureRequest_CalibrationStatus* value);
enum SmartPoseCaptureStatus : int {
  POSE_UNCAPTURED = 0,
  POSE_CAPTURING = 1,
  POSE_CAPTURED = 2,
  SmartPoseCaptureStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SmartPoseCaptureStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SmartPoseCaptureStatus_IsValid(int value);
constexpr SmartPoseCaptureStatus SmartPoseCaptureStatus_MIN = static_cast<SmartPoseCaptureStatus>(0);
constexpr SmartPoseCaptureStatus SmartPoseCaptureStatus_MAX = static_cast<SmartPoseCaptureStatus>(2);
constexpr int SmartPoseCaptureStatus_ARRAYSIZE = 2 + 1;
const std::string& SmartPoseCaptureStatus_Name(SmartPoseCaptureStatus value);
template <typename T>
const std::string& SmartPoseCaptureStatus_Name(T value) {
  static_assert(std::is_same<T, SmartPoseCaptureStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SmartPoseCaptureStatus_Name().");
  return SmartPoseCaptureStatus_Name(static_cast<SmartPoseCaptureStatus>(value));
}
const std::string& SmartPoseCaptureStatus_Name(SmartPoseCaptureStatus value);
bool SmartPoseCaptureStatus_Parse(absl::string_view name, SmartPoseCaptureStatus* value);
enum HapticsStatus : int {
  ERROR = 0,
  OK = 1,
  BUSY = 2,
  OVER = 4,
  SHORT = 8,
  TEMP = 16,
  VIN_FAIL = 32,
  FAILED_PRECONDITION = 64,
  PERMANENT_FAILURE = 99,
  HapticsStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HapticsStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HapticsStatus_IsValid(int value);
constexpr HapticsStatus HapticsStatus_MIN = static_cast<HapticsStatus>(0);
constexpr HapticsStatus HapticsStatus_MAX = static_cast<HapticsStatus>(99);
constexpr int HapticsStatus_ARRAYSIZE = 99 + 1;
const std::string& HapticsStatus_Name(HapticsStatus value);
template <typename T>
const std::string& HapticsStatus_Name(T value) {
  static_assert(std::is_same<T, HapticsStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HapticsStatus_Name().");
  return HapticsStatus_Name(static_cast<HapticsStatus>(value));
}
const std::string& HapticsStatus_Name(HapticsStatus value);
bool HapticsStatus_Parse(absl::string_view name, HapticsStatus* value);

// ===================================================================


// -------------------------------------------------------------------

class CaptureSmartPoseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.CaptureSmartPoseRequest) */ {
 public:
  inline CaptureSmartPoseRequest() : CaptureSmartPoseRequest(nullptr) {}
  ~CaptureSmartPoseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CaptureSmartPoseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureSmartPoseRequest(const CaptureSmartPoseRequest& from);
  CaptureSmartPoseRequest(CaptureSmartPoseRequest&& from) noexcept
    : CaptureSmartPoseRequest() {
    *this = ::std::move(from);
  }

  inline CaptureSmartPoseRequest& operator=(const CaptureSmartPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureSmartPoseRequest& operator=(CaptureSmartPoseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CaptureSmartPoseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureSmartPoseRequest* internal_default_instance() {
    return reinterpret_cast<const CaptureSmartPoseRequest*>(
               &_CaptureSmartPoseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CaptureSmartPoseRequest& a, CaptureSmartPoseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureSmartPoseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureSmartPoseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureSmartPoseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureSmartPoseRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CaptureSmartPoseRequest& from);
  void MergeFrom(const CaptureSmartPoseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CaptureSmartPoseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.CaptureSmartPoseRequest";
  }
  protected:
  explicit CaptureSmartPoseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerIdFieldNumber = 1,
    kHandednessFieldNumber = 2,
    kPoseFieldNumber = 3,
  };
  // int32 performerId = 1;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // .handEngine.v1.Handedness handedness = 2;
  void clear_handedness() ;
  ::handEngine::v1::Handedness handedness() const;
  void set_handedness(::handEngine::v1::Handedness value);

  private:
  ::handEngine::v1::Handedness _internal_handedness() const;
  void _internal_set_handedness(::handEngine::v1::Handedness value);

  public:
  // .handEngine.v1.SmartPose pose = 3;
  void clear_pose() ;
  ::handEngine::v1::SmartPose pose() const;
  void set_pose(::handEngine::v1::SmartPose value);

  private:
  ::handEngine::v1::SmartPose _internal_pose() const;
  void _internal_set_pose(::handEngine::v1::SmartPose value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.CaptureSmartPoseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t performerid_;
    int handedness_;
    int pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class AddPerformerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.AddPerformerRequest) */ {
 public:
  inline AddPerformerRequest() : AddPerformerRequest(nullptr) {}
  ~AddPerformerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddPerformerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPerformerRequest(const AddPerformerRequest& from);
  AddPerformerRequest(AddPerformerRequest&& from) noexcept
    : AddPerformerRequest() {
    *this = ::std::move(from);
  }

  inline AddPerformerRequest& operator=(const AddPerformerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPerformerRequest& operator=(AddPerformerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AddPerformerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPerformerRequest* internal_default_instance() {
    return reinterpret_cast<const AddPerformerRequest*>(
               &_AddPerformerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddPerformerRequest& a, AddPerformerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPerformerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPerformerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPerformerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPerformerRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AddPerformerRequest& from);
  void MergeFrom(const AddPerformerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddPerformerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.AddPerformerRequest";
  }
  protected:
  explicit AddPerformerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerNameFieldNumber = 1,
  };
  // string performerName = 1;
  void clear_performername() ;
  const std::string& performername() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_performername(Arg_&& arg, Args_... args);
  std::string* mutable_performername();
  PROTOBUF_NODISCARD std::string* release_performername();
  void set_allocated_performername(std::string* ptr);

  private:
  const std::string& _internal_performername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performername(
      const std::string& value);
  std::string* _internal_mutable_performername();

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.AddPerformerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr performername_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class AddPerformerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.AddPerformerResponse) */ {
 public:
  inline AddPerformerResponse() : AddPerformerResponse(nullptr) {}
  ~AddPerformerResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddPerformerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPerformerResponse(const AddPerformerResponse& from);
  AddPerformerResponse(AddPerformerResponse&& from) noexcept
    : AddPerformerResponse() {
    *this = ::std::move(from);
  }

  inline AddPerformerResponse& operator=(const AddPerformerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPerformerResponse& operator=(AddPerformerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AddPerformerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPerformerResponse* internal_default_instance() {
    return reinterpret_cast<const AddPerformerResponse*>(
               &_AddPerformerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AddPerformerResponse& a, AddPerformerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPerformerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPerformerResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPerformerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPerformerResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AddPerformerResponse& from);
  void MergeFrom(const AddPerformerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddPerformerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.AddPerformerResponse";
  }
  protected:
  explicit AddPerformerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerIdFieldNumber = 1,
  };
  // int32 performerId = 1;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.AddPerformerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t performerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class StagePerformerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.StagePerformerRequest) */ {
 public:
  inline StagePerformerRequest() : StagePerformerRequest(nullptr) {}
  ~StagePerformerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StagePerformerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StagePerformerRequest(const StagePerformerRequest& from);
  StagePerformerRequest(StagePerformerRequest&& from) noexcept
    : StagePerformerRequest() {
    *this = ::std::move(from);
  }

  inline StagePerformerRequest& operator=(const StagePerformerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StagePerformerRequest& operator=(StagePerformerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StagePerformerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StagePerformerRequest* internal_default_instance() {
    return reinterpret_cast<const StagePerformerRequest*>(
               &_StagePerformerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StagePerformerRequest& a, StagePerformerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StagePerformerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StagePerformerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StagePerformerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StagePerformerRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StagePerformerRequest& from);
  void MergeFrom(const StagePerformerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StagePerformerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.StagePerformerRequest";
  }
  protected:
  explicit StagePerformerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerIdFieldNumber = 1,
    kIsStagedFieldNumber = 2,
  };
  // int32 performerId = 1;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // bool isStaged = 2;
  void clear_isstaged() ;
  bool isstaged() const;
  void set_isstaged(bool value);

  private:
  bool _internal_isstaged() const;
  void _internal_set_isstaged(bool value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.StagePerformerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t performerid_;
    bool isstaged_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class RemovePerformerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.RemovePerformerRequest) */ {
 public:
  inline RemovePerformerRequest() : RemovePerformerRequest(nullptr) {}
  ~RemovePerformerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemovePerformerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemovePerformerRequest(const RemovePerformerRequest& from);
  RemovePerformerRequest(RemovePerformerRequest&& from) noexcept
    : RemovePerformerRequest() {
    *this = ::std::move(from);
  }

  inline RemovePerformerRequest& operator=(const RemovePerformerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemovePerformerRequest& operator=(RemovePerformerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemovePerformerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemovePerformerRequest* internal_default_instance() {
    return reinterpret_cast<const RemovePerformerRequest*>(
               &_RemovePerformerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RemovePerformerRequest& a, RemovePerformerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemovePerformerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemovePerformerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemovePerformerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemovePerformerRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemovePerformerRequest& from);
  void MergeFrom(const RemovePerformerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemovePerformerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.RemovePerformerRequest";
  }
  protected:
  explicit RemovePerformerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerIdFieldNumber = 1,
  };
  // int32 performerId = 1;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.RemovePerformerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t performerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class AssignGloveToPerformerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.AssignGloveToPerformerRequest) */ {
 public:
  inline AssignGloveToPerformerRequest() : AssignGloveToPerformerRequest(nullptr) {}
  ~AssignGloveToPerformerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AssignGloveToPerformerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignGloveToPerformerRequest(const AssignGloveToPerformerRequest& from);
  AssignGloveToPerformerRequest(AssignGloveToPerformerRequest&& from) noexcept
    : AssignGloveToPerformerRequest() {
    *this = ::std::move(from);
  }

  inline AssignGloveToPerformerRequest& operator=(const AssignGloveToPerformerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignGloveToPerformerRequest& operator=(AssignGloveToPerformerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AssignGloveToPerformerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignGloveToPerformerRequest* internal_default_instance() {
    return reinterpret_cast<const AssignGloveToPerformerRequest*>(
               &_AssignGloveToPerformerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AssignGloveToPerformerRequest& a, AssignGloveToPerformerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignGloveToPerformerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignGloveToPerformerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignGloveToPerformerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignGloveToPerformerRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AssignGloveToPerformerRequest& from);
  void MergeFrom(const AssignGloveToPerformerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssignGloveToPerformerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.AssignGloveToPerformerRequest";
  }
  protected:
  explicit AssignGloveToPerformerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kGloveIdFieldNumber = 2,
    kProfileMetaFieldNumber = 3,
  };
  // string sourceId = 1;
  void clear_sourceid() ;
  const std::string& sourceid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sourceid(Arg_&& arg, Args_... args);
  std::string* mutable_sourceid();
  PROTOBUF_NODISCARD std::string* release_sourceid();
  void set_allocated_sourceid(std::string* ptr);

  private:
  const std::string& _internal_sourceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceid(
      const std::string& value);
  std::string* _internal_mutable_sourceid();

  public:
  // string gloveId = 2;
  void clear_gloveid() ;
  const std::string& gloveid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gloveid(Arg_&& arg, Args_... args);
  std::string* mutable_gloveid();
  PROTOBUF_NODISCARD std::string* release_gloveid();
  void set_allocated_gloveid(std::string* ptr);

  private:
  const std::string& _internal_gloveid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gloveid(
      const std::string& value);
  std::string* _internal_mutable_gloveid();

  public:
  // .handEngine.v1.ProfileMeta profileMeta = 3;
  bool has_profilemeta() const;
  void clear_profilemeta() ;
  const ::handEngine::v1::ProfileMeta& profilemeta() const;
  PROTOBUF_NODISCARD ::handEngine::v1::ProfileMeta* release_profilemeta();
  ::handEngine::v1::ProfileMeta* mutable_profilemeta();
  void set_allocated_profilemeta(::handEngine::v1::ProfileMeta* profilemeta);
  private:
  const ::handEngine::v1::ProfileMeta& _internal_profilemeta() const;
  ::handEngine::v1::ProfileMeta* _internal_mutable_profilemeta();
  public:
  void unsafe_arena_set_allocated_profilemeta(
      ::handEngine::v1::ProfileMeta* profilemeta);
  ::handEngine::v1::ProfileMeta* unsafe_arena_release_profilemeta();
  // @@protoc_insertion_point(class_scope:handEngine.v1.AssignGloveToPerformerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gloveid_;
    ::handEngine::v1::ProfileMeta* profilemeta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class ExpressCaptureRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.ExpressCaptureRequest) */ {
 public:
  inline ExpressCaptureRequest() : ExpressCaptureRequest(nullptr) {}
  ~ExpressCaptureRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExpressCaptureRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpressCaptureRequest(const ExpressCaptureRequest& from);
  ExpressCaptureRequest(ExpressCaptureRequest&& from) noexcept
    : ExpressCaptureRequest() {
    *this = ::std::move(from);
  }

  inline ExpressCaptureRequest& operator=(const ExpressCaptureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressCaptureRequest& operator=(ExpressCaptureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExpressCaptureRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpressCaptureRequest* internal_default_instance() {
    return reinterpret_cast<const ExpressCaptureRequest*>(
               &_ExpressCaptureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExpressCaptureRequest& a, ExpressCaptureRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpressCaptureRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressCaptureRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpressCaptureRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpressCaptureRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExpressCaptureRequest& from);
  void MergeFrom(const ExpressCaptureRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExpressCaptureRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.ExpressCaptureRequest";
  }
  protected:
  explicit ExpressCaptureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using CalibrationStatus = ExpressCaptureRequest_CalibrationStatus;
  static constexpr CalibrationStatus START = ExpressCaptureRequest_CalibrationStatus_START;
  static constexpr CalibrationStatus STOP = ExpressCaptureRequest_CalibrationStatus_STOP;
  static inline bool CalibrationStatus_IsValid(int value) {
    return ExpressCaptureRequest_CalibrationStatus_IsValid(value);
  }
  static constexpr CalibrationStatus CalibrationStatus_MIN = ExpressCaptureRequest_CalibrationStatus_CalibrationStatus_MIN;
  static constexpr CalibrationStatus CalibrationStatus_MAX = ExpressCaptureRequest_CalibrationStatus_CalibrationStatus_MAX;
  static constexpr int CalibrationStatus_ARRAYSIZE = ExpressCaptureRequest_CalibrationStatus_CalibrationStatus_ARRAYSIZE;
  template <typename T>
  static inline const std::string& CalibrationStatus_Name(T value) {
    return ExpressCaptureRequest_CalibrationStatus_Name(value);
  }
  static inline bool CalibrationStatus_Parse(absl::string_view name, CalibrationStatus* value) {
    return ExpressCaptureRequest_CalibrationStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProfileMetaFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .handEngine.v1.ProfileMeta profileMeta = 1;
  bool has_profilemeta() const;
  void clear_profilemeta() ;
  const ::handEngine::v1::ProfileMeta& profilemeta() const;
  PROTOBUF_NODISCARD ::handEngine::v1::ProfileMeta* release_profilemeta();
  ::handEngine::v1::ProfileMeta* mutable_profilemeta();
  void set_allocated_profilemeta(::handEngine::v1::ProfileMeta* profilemeta);
  private:
  const ::handEngine::v1::ProfileMeta& _internal_profilemeta() const;
  ::handEngine::v1::ProfileMeta* _internal_mutable_profilemeta();
  public:
  void unsafe_arena_set_allocated_profilemeta(
      ::handEngine::v1::ProfileMeta* profilemeta);
  ::handEngine::v1::ProfileMeta* unsafe_arena_release_profilemeta();
  // .handEngine.v1.ExpressCaptureRequest.CalibrationStatus status = 2;
  void clear_status() ;
  ::handEngine::v1::ExpressCaptureRequest_CalibrationStatus status() const;
  void set_status(::handEngine::v1::ExpressCaptureRequest_CalibrationStatus value);

  private:
  ::handEngine::v1::ExpressCaptureRequest_CalibrationStatus _internal_status() const;
  void _internal_set_status(::handEngine::v1::ExpressCaptureRequest_CalibrationStatus value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.ExpressCaptureRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::handEngine::v1::ProfileMeta* profilemeta_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class PerformerNameListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.PerformerNameListResponse) */ {
 public:
  inline PerformerNameListResponse() : PerformerNameListResponse(nullptr) {}
  ~PerformerNameListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerformerNameListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerformerNameListResponse(const PerformerNameListResponse& from);
  PerformerNameListResponse(PerformerNameListResponse&& from) noexcept
    : PerformerNameListResponse() {
    *this = ::std::move(from);
  }

  inline PerformerNameListResponse& operator=(const PerformerNameListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerformerNameListResponse& operator=(PerformerNameListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PerformerNameListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerformerNameListResponse* internal_default_instance() {
    return reinterpret_cast<const PerformerNameListResponse*>(
               &_PerformerNameListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PerformerNameListResponse& a, PerformerNameListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PerformerNameListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerformerNameListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerformerNameListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerformerNameListResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PerformerNameListResponse& from);
  void MergeFrom(const PerformerNameListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PerformerNameListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.PerformerNameListResponse";
  }
  protected:
  explicit PerformerNameListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformersFieldNumber = 1,
  };
  // repeated .handEngine.v1.PerformerData performers = 1;
  int performers_size() const;
  private:
  int _internal_performers_size() const;

  public:
  void clear_performers() ;
  ::handEngine::v1::PerformerData* mutable_performers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::PerformerData >*
      mutable_performers();
  private:
  const ::handEngine::v1::PerformerData& _internal_performers(int index) const;
  ::handEngine::v1::PerformerData* _internal_add_performers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::PerformerData>& _internal_performers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::PerformerData>* _internal_mutable_performers();
  public:
  const ::handEngine::v1::PerformerData& performers(int index) const;
  ::handEngine::v1::PerformerData* add_performers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::PerformerData >&
      performers() const;
  // @@protoc_insertion_point(class_scope:handEngine.v1.PerformerNameListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::PerformerData > performers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class PerformerData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.PerformerData) */ {
 public:
  inline PerformerData() : PerformerData(nullptr) {}
  ~PerformerData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerformerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerformerData(const PerformerData& from);
  PerformerData(PerformerData&& from) noexcept
    : PerformerData() {
    *this = ::std::move(from);
  }

  inline PerformerData& operator=(const PerformerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerformerData& operator=(PerformerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PerformerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerformerData* internal_default_instance() {
    return reinterpret_cast<const PerformerData*>(
               &_PerformerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PerformerData& a, PerformerData& b) {
    a.Swap(&b);
  }
  inline void Swap(PerformerData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerformerData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerformerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerformerData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PerformerData& from);
  void MergeFrom(const PerformerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PerformerData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.PerformerData";
  }
  protected:
  explicit PerformerData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerNameFieldNumber = 1,
    kPerformerIdFieldNumber = 2,
    kIsStagedFieldNumber = 3,
  };
  // string performerName = 1;
  void clear_performername() ;
  const std::string& performername() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_performername(Arg_&& arg, Args_... args);
  std::string* mutable_performername();
  PROTOBUF_NODISCARD std::string* release_performername();
  void set_allocated_performername(std::string* ptr);

  private:
  const std::string& _internal_performername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performername(
      const std::string& value);
  std::string* _internal_mutable_performername();

  public:
  // int32 performerId = 2;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // bool isStaged = 3;
  void clear_isstaged() ;
  bool isstaged() const;
  void set_isstaged(bool value);

  private:
  bool _internal_isstaged() const;
  void _internal_set_isstaged(bool value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.PerformerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr performername_;
    ::int32_t performerid_;
    bool isstaged_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class DeviceData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceData) */ {
 public:
  inline DeviceData() : DeviceData(nullptr) {}
  ~DeviceData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceData(const DeviceData& from);
  DeviceData(DeviceData&& from) noexcept
    : DeviceData() {
    *this = ::std::move(from);
  }

  inline DeviceData& operator=(const DeviceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceData& operator=(DeviceData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceData* internal_default_instance() {
    return reinterpret_cast<const DeviceData*>(
               &_DeviceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeviceData& a, DeviceData& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceData& from);
  void MergeFrom(const DeviceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceData";
  }
  protected:
  explicit DeviceData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerNameFieldNumber = 1,
    kDeviceInformationFieldNumber = 4,
    kPerformerIdFieldNumber = 2,
    kHandednessFieldNumber = 3,
  };
  // string performerName = 1;
  void clear_performername() ;
  const std::string& performername() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_performername(Arg_&& arg, Args_... args);
  std::string* mutable_performername();
  PROTOBUF_NODISCARD std::string* release_performername();
  void set_allocated_performername(std::string* ptr);

  private:
  const std::string& _internal_performername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performername(
      const std::string& value);
  std::string* _internal_mutable_performername();

  public:
  // .handEngine.v1.GloveInformationResponse deviceInformation = 4;
  bool has_deviceinformation() const;
  void clear_deviceinformation() ;
  const ::handEngine::v1::GloveInformationResponse& deviceinformation() const;
  PROTOBUF_NODISCARD ::handEngine::v1::GloveInformationResponse* release_deviceinformation();
  ::handEngine::v1::GloveInformationResponse* mutable_deviceinformation();
  void set_allocated_deviceinformation(::handEngine::v1::GloveInformationResponse* deviceinformation);
  private:
  const ::handEngine::v1::GloveInformationResponse& _internal_deviceinformation() const;
  ::handEngine::v1::GloveInformationResponse* _internal_mutable_deviceinformation();
  public:
  void unsafe_arena_set_allocated_deviceinformation(
      ::handEngine::v1::GloveInformationResponse* deviceinformation);
  ::handEngine::v1::GloveInformationResponse* unsafe_arena_release_deviceinformation();
  // int32 performerId = 2;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // .handEngine.v1.Handedness handedness = 3;
  void clear_handedness() ;
  ::handEngine::v1::Handedness handedness() const;
  void set_handedness(::handEngine::v1::Handedness value);

  private:
  ::handEngine::v1::Handedness _internal_handedness() const;
  void _internal_set_handedness(::handEngine::v1::Handedness value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr performername_;
    ::handEngine::v1::GloveInformationResponse* deviceinformation_;
    ::int32_t performerid_;
    int handedness_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class DeviceDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.DeviceDataResponse) */ {
 public:
  inline DeviceDataResponse() : DeviceDataResponse(nullptr) {}
  ~DeviceDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceDataResponse(const DeviceDataResponse& from);
  DeviceDataResponse(DeviceDataResponse&& from) noexcept
    : DeviceDataResponse() {
    *this = ::std::move(from);
  }

  inline DeviceDataResponse& operator=(const DeviceDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceDataResponse& operator=(DeviceDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceDataResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceDataResponse*>(
               &_DeviceDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeviceDataResponse& a, DeviceDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceDataResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceDataResponse& from);
  void MergeFrom(const DeviceDataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.DeviceDataResponse";
  }
  protected:
  explicit DeviceDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .handEngine.v1.DeviceData devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;

  public:
  void clear_devices() ;
  ::handEngine::v1::DeviceData* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceData >*
      mutable_devices();
  private:
  const ::handEngine::v1::DeviceData& _internal_devices(int index) const;
  ::handEngine::v1::DeviceData* _internal_add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceData>& _internal_devices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceData>* _internal_mutable_devices();
  public:
  const ::handEngine::v1::DeviceData& devices(int index) const;
  ::handEngine::v1::DeviceData* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceData >&
      devices() const;
  // @@protoc_insertion_point(class_scope:handEngine.v1.DeviceDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceData > devices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class SmartPoseCapture final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.SmartPoseCapture) */ {
 public:
  inline SmartPoseCapture() : SmartPoseCapture(nullptr) {}
  ~SmartPoseCapture() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SmartPoseCapture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartPoseCapture(const SmartPoseCapture& from);
  SmartPoseCapture(SmartPoseCapture&& from) noexcept
    : SmartPoseCapture() {
    *this = ::std::move(from);
  }

  inline SmartPoseCapture& operator=(const SmartPoseCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartPoseCapture& operator=(SmartPoseCapture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SmartPoseCapture& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartPoseCapture* internal_default_instance() {
    return reinterpret_cast<const SmartPoseCapture*>(
               &_SmartPoseCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SmartPoseCapture& a, SmartPoseCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartPoseCapture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartPoseCapture* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartPoseCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartPoseCapture>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SmartPoseCapture& from);
  void MergeFrom(const SmartPoseCapture& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SmartPoseCapture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.SmartPoseCapture";
  }
  protected:
  explicit SmartPoseCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSliderValuesFieldNumber = 3,
    kPoseFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated double sliderValues = 3;
  int slidervalues_size() const;
  private:
  int _internal_slidervalues_size() const;

  public:
  void clear_slidervalues() ;
  double slidervalues(int index) const;
  void set_slidervalues(int index, double value);
  void add_slidervalues(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& slidervalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* mutable_slidervalues();

  private:
  double _internal_slidervalues(int index) const;
  void _internal_add_slidervalues(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& _internal_slidervalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* _internal_mutable_slidervalues();

  public:
  // .handEngine.v1.SmartPose pose = 1;
  void clear_pose() ;
  ::handEngine::v1::SmartPose pose() const;
  void set_pose(::handEngine::v1::SmartPose value);

  private:
  ::handEngine::v1::SmartPose _internal_pose() const;
  void _internal_set_pose(::handEngine::v1::SmartPose value);

  public:
  // .handEngine.v1.SmartPoseCaptureStatus status = 2;
  void clear_status() ;
  ::handEngine::v1::SmartPoseCaptureStatus status() const;
  void set_status(::handEngine::v1::SmartPoseCaptureStatus value);

  private:
  ::handEngine::v1::SmartPoseCaptureStatus _internal_status() const;
  void _internal_set_status(::handEngine::v1::SmartPoseCaptureStatus value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.SmartPoseCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<double> slidervalues_;
    int pose_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class SmartCalibrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.SmartCalibrationResponse) */ {
 public:
  inline SmartCalibrationResponse() : SmartCalibrationResponse(nullptr) {}
  ~SmartCalibrationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SmartCalibrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartCalibrationResponse(const SmartCalibrationResponse& from);
  SmartCalibrationResponse(SmartCalibrationResponse&& from) noexcept
    : SmartCalibrationResponse() {
    *this = ::std::move(from);
  }

  inline SmartCalibrationResponse& operator=(const SmartCalibrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartCalibrationResponse& operator=(SmartCalibrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SmartCalibrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartCalibrationResponse* internal_default_instance() {
    return reinterpret_cast<const SmartCalibrationResponse*>(
               &_SmartCalibrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SmartCalibrationResponse& a, SmartCalibrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartCalibrationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartCalibrationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartCalibrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartCalibrationResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SmartCalibrationResponse& from);
  void MergeFrom(const SmartCalibrationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SmartCalibrationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.SmartCalibrationResponse";
  }
  protected:
  explicit SmartCalibrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosesFieldNumber = 1,
    kPoseProgressFieldNumber = 3,
  };
  // repeated .handEngine.v1.SmartPoseCapture poses = 1;
  int poses_size() const;
  private:
  int _internal_poses_size() const;

  public:
  void clear_poses() ;
  ::handEngine::v1::SmartPoseCapture* mutable_poses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::SmartPoseCapture >*
      mutable_poses();
  private:
  const ::handEngine::v1::SmartPoseCapture& _internal_poses(int index) const;
  ::handEngine::v1::SmartPoseCapture* _internal_add_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::SmartPoseCapture>& _internal_poses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::SmartPoseCapture>* _internal_mutable_poses();
  public:
  const ::handEngine::v1::SmartPoseCapture& poses(int index) const;
  ::handEngine::v1::SmartPoseCapture* add_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::SmartPoseCapture >&
      poses() const;
  // uint32 poseProgress = 3;
  void clear_poseprogress() ;
  ::uint32_t poseprogress() const;
  void set_poseprogress(::uint32_t value);

  private:
  ::uint32_t _internal_poseprogress() const;
  void _internal_set_poseprogress(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.SmartCalibrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::SmartPoseCapture > poses_;
    ::uint32_t poseprogress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class HapticsInputRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.HapticsInputRequest) */ {
 public:
  inline HapticsInputRequest() : HapticsInputRequest(nullptr) {}
  ~HapticsInputRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HapticsInputRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HapticsInputRequest(const HapticsInputRequest& from);
  HapticsInputRequest(HapticsInputRequest&& from) noexcept
    : HapticsInputRequest() {
    *this = ::std::move(from);
  }

  inline HapticsInputRequest& operator=(const HapticsInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HapticsInputRequest& operator=(HapticsInputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HapticsInputRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HapticsInputRequest* internal_default_instance() {
    return reinterpret_cast<const HapticsInputRequest*>(
               &_HapticsInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HapticsInputRequest& a, HapticsInputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HapticsInputRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HapticsInputRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HapticsInputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HapticsInputRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HapticsInputRequest& from);
  void MergeFrom(const HapticsInputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HapticsInputRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.HapticsInputRequest";
  }
  protected:
  explicit HapticsInputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerIdFieldNumber = 1,
    kHandednessFieldNumber = 2,
    kPatternFieldNumber = 3,
  };
  // int32 performerId = 1;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // .handEngine.v1.Handedness handedness = 2;
  void clear_handedness() ;
  ::handEngine::v1::Handedness handedness() const;
  void set_handedness(::handEngine::v1::Handedness value);

  private:
  ::handEngine::v1::Handedness _internal_handedness() const;
  void _internal_set_handedness(::handEngine::v1::Handedness value);

  public:
  // .handEngine.v1.HapticPattern pattern = 3;
  void clear_pattern() ;
  ::handEngine::v1::HapticPattern pattern() const;
  void set_pattern(::handEngine::v1::HapticPattern value);

  private:
  ::handEngine::v1::HapticPattern _internal_pattern() const;
  void _internal_set_pattern(::handEngine::v1::HapticPattern value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.HapticsInputRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t performerid_;
    int handedness_;
    int pattern_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};// -------------------------------------------------------------------

class HapticsStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.HapticsStatusResponse) */ {
 public:
  inline HapticsStatusResponse() : HapticsStatusResponse(nullptr) {}
  ~HapticsStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HapticsStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HapticsStatusResponse(const HapticsStatusResponse& from);
  HapticsStatusResponse(HapticsStatusResponse&& from) noexcept
    : HapticsStatusResponse() {
    *this = ::std::move(from);
  }

  inline HapticsStatusResponse& operator=(const HapticsStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HapticsStatusResponse& operator=(HapticsStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HapticsStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HapticsStatusResponse* internal_default_instance() {
    return reinterpret_cast<const HapticsStatusResponse*>(
               &_HapticsStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HapticsStatusResponse& a, HapticsStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HapticsStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HapticsStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HapticsStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HapticsStatusResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HapticsStatusResponse& from);
  void MergeFrom(const HapticsStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HapticsStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.HapticsStatusResponse";
  }
  protected:
  explicit HapticsStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .handEngine.v1.HapticsStatus status = 2;
  void clear_status() ;
  ::handEngine::v1::HapticsStatus status() const;
  void set_status(::handEngine::v1::HapticsStatus value);

  private:
  ::handEngine::v1::HapticsStatus _internal_status() const;
  void _internal_set_status(::handEngine::v1::HapticsStatus value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.HapticsStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fperformer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CaptureSmartPoseRequest

// int32 performerId = 1;
inline void CaptureSmartPoseRequest::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t CaptureSmartPoseRequest::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.CaptureSmartPoseRequest.performerId)
  return _internal_performerid();
}
inline void CaptureSmartPoseRequest::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.CaptureSmartPoseRequest.performerId)
}
inline ::int32_t CaptureSmartPoseRequest::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void CaptureSmartPoseRequest::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// .handEngine.v1.Handedness handedness = 2;
inline void CaptureSmartPoseRequest::clear_handedness() {
  _impl_.handedness_ = 0;
}
inline ::handEngine::v1::Handedness CaptureSmartPoseRequest::handedness() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.CaptureSmartPoseRequest.handedness)
  return _internal_handedness();
}
inline void CaptureSmartPoseRequest::set_handedness(::handEngine::v1::Handedness value) {
   _internal_set_handedness(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.CaptureSmartPoseRequest.handedness)
}
inline ::handEngine::v1::Handedness CaptureSmartPoseRequest::_internal_handedness() const {
  return static_cast<::handEngine::v1::Handedness>(_impl_.handedness_);
}
inline void CaptureSmartPoseRequest::_internal_set_handedness(::handEngine::v1::Handedness value) {
  ;
  _impl_.handedness_ = value;
}

// .handEngine.v1.SmartPose pose = 3;
inline void CaptureSmartPoseRequest::clear_pose() {
  _impl_.pose_ = 0;
}
inline ::handEngine::v1::SmartPose CaptureSmartPoseRequest::pose() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.CaptureSmartPoseRequest.pose)
  return _internal_pose();
}
inline void CaptureSmartPoseRequest::set_pose(::handEngine::v1::SmartPose value) {
   _internal_set_pose(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.CaptureSmartPoseRequest.pose)
}
inline ::handEngine::v1::SmartPose CaptureSmartPoseRequest::_internal_pose() const {
  return static_cast<::handEngine::v1::SmartPose>(_impl_.pose_);
}
inline void CaptureSmartPoseRequest::_internal_set_pose(::handEngine::v1::SmartPose value) {
  ;
  _impl_.pose_ = value;
}

// -------------------------------------------------------------------

// AddPerformerRequest

// string performerName = 1;
inline void AddPerformerRequest::clear_performername() {
  _impl_.performername_.ClearToEmpty();
}
inline const std::string& AddPerformerRequest::performername() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.AddPerformerRequest.performerName)
  return _internal_performername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddPerformerRequest::set_performername(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.performername_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.AddPerformerRequest.performerName)
}
inline std::string* AddPerformerRequest::mutable_performername() {
  std::string* _s = _internal_mutable_performername();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.AddPerformerRequest.performerName)
  return _s;
}
inline const std::string& AddPerformerRequest::_internal_performername() const {
  return _impl_.performername_.Get();
}
inline void AddPerformerRequest::_internal_set_performername(const std::string& value) {
  ;


  _impl_.performername_.Set(value, GetArenaForAllocation());
}
inline std::string* AddPerformerRequest::_internal_mutable_performername() {
  ;
  return _impl_.performername_.Mutable( GetArenaForAllocation());
}
inline std::string* AddPerformerRequest::release_performername() {
  // @@protoc_insertion_point(field_release:handEngine.v1.AddPerformerRequest.performerName)
  return _impl_.performername_.Release();
}
inline void AddPerformerRequest::set_allocated_performername(std::string* value) {
  _impl_.performername_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.performername_.IsDefault()) {
          _impl_.performername_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.AddPerformerRequest.performerName)
}

// -------------------------------------------------------------------

// AddPerformerResponse

// int32 performerId = 1;
inline void AddPerformerResponse::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t AddPerformerResponse::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.AddPerformerResponse.performerId)
  return _internal_performerid();
}
inline void AddPerformerResponse::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.AddPerformerResponse.performerId)
}
inline ::int32_t AddPerformerResponse::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void AddPerformerResponse::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// -------------------------------------------------------------------

// StagePerformerRequest

// int32 performerId = 1;
inline void StagePerformerRequest::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t StagePerformerRequest::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StagePerformerRequest.performerId)
  return _internal_performerid();
}
inline void StagePerformerRequest::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StagePerformerRequest.performerId)
}
inline ::int32_t StagePerformerRequest::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void StagePerformerRequest::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// bool isStaged = 2;
inline void StagePerformerRequest::clear_isstaged() {
  _impl_.isstaged_ = false;
}
inline bool StagePerformerRequest::isstaged() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StagePerformerRequest.isStaged)
  return _internal_isstaged();
}
inline void StagePerformerRequest::set_isstaged(bool value) {
  _internal_set_isstaged(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.StagePerformerRequest.isStaged)
}
inline bool StagePerformerRequest::_internal_isstaged() const {
  return _impl_.isstaged_;
}
inline void StagePerformerRequest::_internal_set_isstaged(bool value) {
  ;
  _impl_.isstaged_ = value;
}

// -------------------------------------------------------------------

// RemovePerformerRequest

// int32 performerId = 1;
inline void RemovePerformerRequest::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t RemovePerformerRequest::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.RemovePerformerRequest.performerId)
  return _internal_performerid();
}
inline void RemovePerformerRequest::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.RemovePerformerRequest.performerId)
}
inline ::int32_t RemovePerformerRequest::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void RemovePerformerRequest::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// -------------------------------------------------------------------

// AssignGloveToPerformerRequest

// string sourceId = 1;
inline void AssignGloveToPerformerRequest::clear_sourceid() {
  _impl_.sourceid_.ClearToEmpty();
}
inline const std::string& AssignGloveToPerformerRequest::sourceid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.AssignGloveToPerformerRequest.sourceId)
  return _internal_sourceid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssignGloveToPerformerRequest::set_sourceid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sourceid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.AssignGloveToPerformerRequest.sourceId)
}
inline std::string* AssignGloveToPerformerRequest::mutable_sourceid() {
  std::string* _s = _internal_mutable_sourceid();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.AssignGloveToPerformerRequest.sourceId)
  return _s;
}
inline const std::string& AssignGloveToPerformerRequest::_internal_sourceid() const {
  return _impl_.sourceid_.Get();
}
inline void AssignGloveToPerformerRequest::_internal_set_sourceid(const std::string& value) {
  ;


  _impl_.sourceid_.Set(value, GetArenaForAllocation());
}
inline std::string* AssignGloveToPerformerRequest::_internal_mutable_sourceid() {
  ;
  return _impl_.sourceid_.Mutable( GetArenaForAllocation());
}
inline std::string* AssignGloveToPerformerRequest::release_sourceid() {
  // @@protoc_insertion_point(field_release:handEngine.v1.AssignGloveToPerformerRequest.sourceId)
  return _impl_.sourceid_.Release();
}
inline void AssignGloveToPerformerRequest::set_allocated_sourceid(std::string* value) {
  _impl_.sourceid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sourceid_.IsDefault()) {
          _impl_.sourceid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.AssignGloveToPerformerRequest.sourceId)
}

// string gloveId = 2;
inline void AssignGloveToPerformerRequest::clear_gloveid() {
  _impl_.gloveid_.ClearToEmpty();
}
inline const std::string& AssignGloveToPerformerRequest::gloveid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.AssignGloveToPerformerRequest.gloveId)
  return _internal_gloveid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssignGloveToPerformerRequest::set_gloveid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.gloveid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.AssignGloveToPerformerRequest.gloveId)
}
inline std::string* AssignGloveToPerformerRequest::mutable_gloveid() {
  std::string* _s = _internal_mutable_gloveid();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.AssignGloveToPerformerRequest.gloveId)
  return _s;
}
inline const std::string& AssignGloveToPerformerRequest::_internal_gloveid() const {
  return _impl_.gloveid_.Get();
}
inline void AssignGloveToPerformerRequest::_internal_set_gloveid(const std::string& value) {
  ;


  _impl_.gloveid_.Set(value, GetArenaForAllocation());
}
inline std::string* AssignGloveToPerformerRequest::_internal_mutable_gloveid() {
  ;
  return _impl_.gloveid_.Mutable( GetArenaForAllocation());
}
inline std::string* AssignGloveToPerformerRequest::release_gloveid() {
  // @@protoc_insertion_point(field_release:handEngine.v1.AssignGloveToPerformerRequest.gloveId)
  return _impl_.gloveid_.Release();
}
inline void AssignGloveToPerformerRequest::set_allocated_gloveid(std::string* value) {
  _impl_.gloveid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gloveid_.IsDefault()) {
          _impl_.gloveid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.AssignGloveToPerformerRequest.gloveId)
}

// .handEngine.v1.ProfileMeta profileMeta = 3;
inline bool AssignGloveToPerformerRequest::has_profilemeta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profilemeta_ != nullptr);
  return value;
}
inline const ::handEngine::v1::ProfileMeta& AssignGloveToPerformerRequest::_internal_profilemeta() const {
  const ::handEngine::v1::ProfileMeta* p = _impl_.profilemeta_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::ProfileMeta&>(
      ::handEngine::v1::_ProfileMeta_default_instance_);
}
inline const ::handEngine::v1::ProfileMeta& AssignGloveToPerformerRequest::profilemeta() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.AssignGloveToPerformerRequest.profileMeta)
  return _internal_profilemeta();
}
inline void AssignGloveToPerformerRequest::unsafe_arena_set_allocated_profilemeta(
    ::handEngine::v1::ProfileMeta* profilemeta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profilemeta_);
  }
  _impl_.profilemeta_ = profilemeta;
  if (profilemeta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.AssignGloveToPerformerRequest.profileMeta)
}
inline ::handEngine::v1::ProfileMeta* AssignGloveToPerformerRequest::release_profilemeta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::ProfileMeta* temp = _impl_.profilemeta_;
  _impl_.profilemeta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::ProfileMeta* AssignGloveToPerformerRequest::unsafe_arena_release_profilemeta() {
  // @@protoc_insertion_point(field_release:handEngine.v1.AssignGloveToPerformerRequest.profileMeta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::ProfileMeta* temp = _impl_.profilemeta_;
  _impl_.profilemeta_ = nullptr;
  return temp;
}
inline ::handEngine::v1::ProfileMeta* AssignGloveToPerformerRequest::_internal_mutable_profilemeta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.profilemeta_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::ProfileMeta>(GetArenaForAllocation());
    _impl_.profilemeta_ = p;
  }
  return _impl_.profilemeta_;
}
inline ::handEngine::v1::ProfileMeta* AssignGloveToPerformerRequest::mutable_profilemeta() {
  ::handEngine::v1::ProfileMeta* _msg = _internal_mutable_profilemeta();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.AssignGloveToPerformerRequest.profileMeta)
  return _msg;
}
inline void AssignGloveToPerformerRequest::set_allocated_profilemeta(::handEngine::v1::ProfileMeta* profilemeta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profilemeta_);
  }
  if (profilemeta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profilemeta));
    if (message_arena != submessage_arena) {
      profilemeta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profilemeta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.profilemeta_ = profilemeta;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.AssignGloveToPerformerRequest.profileMeta)
}

// -------------------------------------------------------------------

// ExpressCaptureRequest

// .handEngine.v1.ProfileMeta profileMeta = 1;
inline bool ExpressCaptureRequest::has_profilemeta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profilemeta_ != nullptr);
  return value;
}
inline const ::handEngine::v1::ProfileMeta& ExpressCaptureRequest::_internal_profilemeta() const {
  const ::handEngine::v1::ProfileMeta* p = _impl_.profilemeta_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::ProfileMeta&>(
      ::handEngine::v1::_ProfileMeta_default_instance_);
}
inline const ::handEngine::v1::ProfileMeta& ExpressCaptureRequest::profilemeta() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ExpressCaptureRequest.profileMeta)
  return _internal_profilemeta();
}
inline void ExpressCaptureRequest::unsafe_arena_set_allocated_profilemeta(
    ::handEngine::v1::ProfileMeta* profilemeta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profilemeta_);
  }
  _impl_.profilemeta_ = profilemeta;
  if (profilemeta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.ExpressCaptureRequest.profileMeta)
}
inline ::handEngine::v1::ProfileMeta* ExpressCaptureRequest::release_profilemeta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::ProfileMeta* temp = _impl_.profilemeta_;
  _impl_.profilemeta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::ProfileMeta* ExpressCaptureRequest::unsafe_arena_release_profilemeta() {
  // @@protoc_insertion_point(field_release:handEngine.v1.ExpressCaptureRequest.profileMeta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::ProfileMeta* temp = _impl_.profilemeta_;
  _impl_.profilemeta_ = nullptr;
  return temp;
}
inline ::handEngine::v1::ProfileMeta* ExpressCaptureRequest::_internal_mutable_profilemeta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.profilemeta_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::ProfileMeta>(GetArenaForAllocation());
    _impl_.profilemeta_ = p;
  }
  return _impl_.profilemeta_;
}
inline ::handEngine::v1::ProfileMeta* ExpressCaptureRequest::mutable_profilemeta() {
  ::handEngine::v1::ProfileMeta* _msg = _internal_mutable_profilemeta();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.ExpressCaptureRequest.profileMeta)
  return _msg;
}
inline void ExpressCaptureRequest::set_allocated_profilemeta(::handEngine::v1::ProfileMeta* profilemeta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profilemeta_);
  }
  if (profilemeta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profilemeta));
    if (message_arena != submessage_arena) {
      profilemeta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profilemeta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.profilemeta_ = profilemeta;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.ExpressCaptureRequest.profileMeta)
}

// .handEngine.v1.ExpressCaptureRequest.CalibrationStatus status = 2;
inline void ExpressCaptureRequest::clear_status() {
  _impl_.status_ = 0;
}
inline ::handEngine::v1::ExpressCaptureRequest_CalibrationStatus ExpressCaptureRequest::status() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ExpressCaptureRequest.status)
  return _internal_status();
}
inline void ExpressCaptureRequest::set_status(::handEngine::v1::ExpressCaptureRequest_CalibrationStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ExpressCaptureRequest.status)
}
inline ::handEngine::v1::ExpressCaptureRequest_CalibrationStatus ExpressCaptureRequest::_internal_status() const {
  return static_cast<::handEngine::v1::ExpressCaptureRequest_CalibrationStatus>(_impl_.status_);
}
inline void ExpressCaptureRequest::_internal_set_status(::handEngine::v1::ExpressCaptureRequest_CalibrationStatus value) {
  ;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// PerformerNameListResponse

// repeated .handEngine.v1.PerformerData performers = 1;
inline int PerformerNameListResponse::_internal_performers_size() const {
  return _impl_.performers_.size();
}
inline int PerformerNameListResponse::performers_size() const {
  return _internal_performers_size();
}
inline void PerformerNameListResponse::clear_performers() {
  _internal_mutable_performers()->Clear();
}
inline ::handEngine::v1::PerformerData* PerformerNameListResponse::mutable_performers(int index) {
  // @@protoc_insertion_point(field_mutable:handEngine.v1.PerformerNameListResponse.performers)
  return _internal_mutable_performers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::PerformerData >*
PerformerNameListResponse::mutable_performers() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.PerformerNameListResponse.performers)
  return _internal_mutable_performers();
}
inline const ::handEngine::v1::PerformerData& PerformerNameListResponse::_internal_performers(int index) const {
  return _internal_performers().Get(index);
}
inline const ::handEngine::v1::PerformerData& PerformerNameListResponse::performers(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PerformerNameListResponse.performers)
  return _internal_performers(index);
}
inline ::handEngine::v1::PerformerData* PerformerNameListResponse::_internal_add_performers() {
  return _internal_mutable_performers()->Add();
}
inline ::handEngine::v1::PerformerData* PerformerNameListResponse::add_performers() {
  ::handEngine::v1::PerformerData* _add = _internal_add_performers();
  // @@protoc_insertion_point(field_add:handEngine.v1.PerformerNameListResponse.performers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::PerformerData >&
PerformerNameListResponse::performers() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.PerformerNameListResponse.performers)
  return _internal_performers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::PerformerData>&
PerformerNameListResponse::_internal_performers() const {
  return _impl_.performers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::PerformerData>*
PerformerNameListResponse::_internal_mutable_performers() {
  return &_impl_.performers_;
}

// -------------------------------------------------------------------

// PerformerData

// string performerName = 1;
inline void PerformerData::clear_performername() {
  _impl_.performername_.ClearToEmpty();
}
inline const std::string& PerformerData::performername() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PerformerData.performerName)
  return _internal_performername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerformerData::set_performername(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.performername_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.PerformerData.performerName)
}
inline std::string* PerformerData::mutable_performername() {
  std::string* _s = _internal_mutable_performername();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.PerformerData.performerName)
  return _s;
}
inline const std::string& PerformerData::_internal_performername() const {
  return _impl_.performername_.Get();
}
inline void PerformerData::_internal_set_performername(const std::string& value) {
  ;


  _impl_.performername_.Set(value, GetArenaForAllocation());
}
inline std::string* PerformerData::_internal_mutable_performername() {
  ;
  return _impl_.performername_.Mutable( GetArenaForAllocation());
}
inline std::string* PerformerData::release_performername() {
  // @@protoc_insertion_point(field_release:handEngine.v1.PerformerData.performerName)
  return _impl_.performername_.Release();
}
inline void PerformerData::set_allocated_performername(std::string* value) {
  _impl_.performername_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.performername_.IsDefault()) {
          _impl_.performername_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.PerformerData.performerName)
}

// int32 performerId = 2;
inline void PerformerData::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t PerformerData::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PerformerData.performerId)
  return _internal_performerid();
}
inline void PerformerData::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.PerformerData.performerId)
}
inline ::int32_t PerformerData::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void PerformerData::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// bool isStaged = 3;
inline void PerformerData::clear_isstaged() {
  _impl_.isstaged_ = false;
}
inline bool PerformerData::isstaged() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.PerformerData.isStaged)
  return _internal_isstaged();
}
inline void PerformerData::set_isstaged(bool value) {
  _internal_set_isstaged(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.PerformerData.isStaged)
}
inline bool PerformerData::_internal_isstaged() const {
  return _impl_.isstaged_;
}
inline void PerformerData::_internal_set_isstaged(bool value) {
  ;
  _impl_.isstaged_ = value;
}

// -------------------------------------------------------------------

// DeviceData

// string performerName = 1;
inline void DeviceData::clear_performername() {
  _impl_.performername_.ClearToEmpty();
}
inline const std::string& DeviceData::performername() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceData.performerName)
  return _internal_performername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceData::set_performername(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.performername_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceData.performerName)
}
inline std::string* DeviceData::mutable_performername() {
  std::string* _s = _internal_mutable_performername();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceData.performerName)
  return _s;
}
inline const std::string& DeviceData::_internal_performername() const {
  return _impl_.performername_.Get();
}
inline void DeviceData::_internal_set_performername(const std::string& value) {
  ;


  _impl_.performername_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceData::_internal_mutable_performername() {
  ;
  return _impl_.performername_.Mutable( GetArenaForAllocation());
}
inline std::string* DeviceData::release_performername() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceData.performerName)
  return _impl_.performername_.Release();
}
inline void DeviceData::set_allocated_performername(std::string* value) {
  _impl_.performername_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.performername_.IsDefault()) {
          _impl_.performername_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceData.performerName)
}

// int32 performerId = 2;
inline void DeviceData::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t DeviceData::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceData.performerId)
  return _internal_performerid();
}
inline void DeviceData::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceData.performerId)
}
inline ::int32_t DeviceData::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void DeviceData::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// .handEngine.v1.Handedness handedness = 3;
inline void DeviceData::clear_handedness() {
  _impl_.handedness_ = 0;
}
inline ::handEngine::v1::Handedness DeviceData::handedness() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceData.handedness)
  return _internal_handedness();
}
inline void DeviceData::set_handedness(::handEngine::v1::Handedness value) {
   _internal_set_handedness(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.DeviceData.handedness)
}
inline ::handEngine::v1::Handedness DeviceData::_internal_handedness() const {
  return static_cast<::handEngine::v1::Handedness>(_impl_.handedness_);
}
inline void DeviceData::_internal_set_handedness(::handEngine::v1::Handedness value) {
  ;
  _impl_.handedness_ = value;
}

// .handEngine.v1.GloveInformationResponse deviceInformation = 4;
inline bool DeviceData::has_deviceinformation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deviceinformation_ != nullptr);
  return value;
}
inline const ::handEngine::v1::GloveInformationResponse& DeviceData::_internal_deviceinformation() const {
  const ::handEngine::v1::GloveInformationResponse* p = _impl_.deviceinformation_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::GloveInformationResponse&>(
      ::handEngine::v1::_GloveInformationResponse_default_instance_);
}
inline const ::handEngine::v1::GloveInformationResponse& DeviceData::deviceinformation() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceData.deviceInformation)
  return _internal_deviceinformation();
}
inline void DeviceData::unsafe_arena_set_allocated_deviceinformation(
    ::handEngine::v1::GloveInformationResponse* deviceinformation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceinformation_);
  }
  _impl_.deviceinformation_ = deviceinformation;
  if (deviceinformation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.DeviceData.deviceInformation)
}
inline ::handEngine::v1::GloveInformationResponse* DeviceData::release_deviceinformation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::GloveInformationResponse* temp = _impl_.deviceinformation_;
  _impl_.deviceinformation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::GloveInformationResponse* DeviceData::unsafe_arena_release_deviceinformation() {
  // @@protoc_insertion_point(field_release:handEngine.v1.DeviceData.deviceInformation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::GloveInformationResponse* temp = _impl_.deviceinformation_;
  _impl_.deviceinformation_ = nullptr;
  return temp;
}
inline ::handEngine::v1::GloveInformationResponse* DeviceData::_internal_mutable_deviceinformation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deviceinformation_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::GloveInformationResponse>(GetArenaForAllocation());
    _impl_.deviceinformation_ = p;
  }
  return _impl_.deviceinformation_;
}
inline ::handEngine::v1::GloveInformationResponse* DeviceData::mutable_deviceinformation() {
  ::handEngine::v1::GloveInformationResponse* _msg = _internal_mutable_deviceinformation();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceData.deviceInformation)
  return _msg;
}
inline void DeviceData::set_allocated_deviceinformation(::handEngine::v1::GloveInformationResponse* deviceinformation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceinformation_);
  }
  if (deviceinformation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deviceinformation));
    if (message_arena != submessage_arena) {
      deviceinformation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceinformation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deviceinformation_ = deviceinformation;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.DeviceData.deviceInformation)
}

// -------------------------------------------------------------------

// DeviceDataResponse

// repeated .handEngine.v1.DeviceData devices = 1;
inline int DeviceDataResponse::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int DeviceDataResponse::devices_size() const {
  return _internal_devices_size();
}
inline void DeviceDataResponse::clear_devices() {
  _internal_mutable_devices()->Clear();
}
inline ::handEngine::v1::DeviceData* DeviceDataResponse::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:handEngine.v1.DeviceDataResponse.devices)
  return _internal_mutable_devices()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceData >*
DeviceDataResponse::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.DeviceDataResponse.devices)
  return _internal_mutable_devices();
}
inline const ::handEngine::v1::DeviceData& DeviceDataResponse::_internal_devices(int index) const {
  return _internal_devices().Get(index);
}
inline const ::handEngine::v1::DeviceData& DeviceDataResponse::devices(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.DeviceDataResponse.devices)
  return _internal_devices(index);
}
inline ::handEngine::v1::DeviceData* DeviceDataResponse::_internal_add_devices() {
  return _internal_mutable_devices()->Add();
}
inline ::handEngine::v1::DeviceData* DeviceDataResponse::add_devices() {
  ::handEngine::v1::DeviceData* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:handEngine.v1.DeviceDataResponse.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::DeviceData >&
DeviceDataResponse::devices() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.DeviceDataResponse.devices)
  return _internal_devices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceData>&
DeviceDataResponse::_internal_devices() const {
  return _impl_.devices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::DeviceData>*
DeviceDataResponse::_internal_mutable_devices() {
  return &_impl_.devices_;
}

// -------------------------------------------------------------------

// SmartPoseCapture

// .handEngine.v1.SmartPose pose = 1;
inline void SmartPoseCapture::clear_pose() {
  _impl_.pose_ = 0;
}
inline ::handEngine::v1::SmartPose SmartPoseCapture::pose() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.SmartPoseCapture.pose)
  return _internal_pose();
}
inline void SmartPoseCapture::set_pose(::handEngine::v1::SmartPose value) {
   _internal_set_pose(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.SmartPoseCapture.pose)
}
inline ::handEngine::v1::SmartPose SmartPoseCapture::_internal_pose() const {
  return static_cast<::handEngine::v1::SmartPose>(_impl_.pose_);
}
inline void SmartPoseCapture::_internal_set_pose(::handEngine::v1::SmartPose value) {
  ;
  _impl_.pose_ = value;
}

// .handEngine.v1.SmartPoseCaptureStatus status = 2;
inline void SmartPoseCapture::clear_status() {
  _impl_.status_ = 0;
}
inline ::handEngine::v1::SmartPoseCaptureStatus SmartPoseCapture::status() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.SmartPoseCapture.status)
  return _internal_status();
}
inline void SmartPoseCapture::set_status(::handEngine::v1::SmartPoseCaptureStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.SmartPoseCapture.status)
}
inline ::handEngine::v1::SmartPoseCaptureStatus SmartPoseCapture::_internal_status() const {
  return static_cast<::handEngine::v1::SmartPoseCaptureStatus>(_impl_.status_);
}
inline void SmartPoseCapture::_internal_set_status(::handEngine::v1::SmartPoseCaptureStatus value) {
  ;
  _impl_.status_ = value;
}

// repeated double sliderValues = 3;
inline int SmartPoseCapture::_internal_slidervalues_size() const {
  return _impl_.slidervalues_.size();
}
inline int SmartPoseCapture::slidervalues_size() const {
  return _internal_slidervalues_size();
}
inline void SmartPoseCapture::clear_slidervalues() {
  _internal_mutable_slidervalues()->Clear();
}
inline double SmartPoseCapture::slidervalues(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.SmartPoseCapture.sliderValues)
  return _internal_slidervalues(index);
}
inline void SmartPoseCapture::set_slidervalues(int index, double value) {
  _internal_mutable_slidervalues()->Set(index, value);
  // @@protoc_insertion_point(field_set:handEngine.v1.SmartPoseCapture.sliderValues)
}
inline void SmartPoseCapture::add_slidervalues(double value) {
  _internal_add_slidervalues(value);
  // @@protoc_insertion_point(field_add:handEngine.v1.SmartPoseCapture.sliderValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& SmartPoseCapture::slidervalues() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.SmartPoseCapture.sliderValues)
  return _internal_slidervalues();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* SmartPoseCapture::mutable_slidervalues() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.SmartPoseCapture.sliderValues)
  return _internal_mutable_slidervalues();
}

inline double SmartPoseCapture::_internal_slidervalues(int index) const {
  return _internal_slidervalues().Get(index);
}
inline void SmartPoseCapture::_internal_add_slidervalues(double value) {
  _internal_mutable_slidervalues()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& SmartPoseCapture::_internal_slidervalues() const {
  return _impl_.slidervalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* SmartPoseCapture::_internal_mutable_slidervalues() {
  return &_impl_.slidervalues_;
}

// -------------------------------------------------------------------

// SmartCalibrationResponse

// repeated .handEngine.v1.SmartPoseCapture poses = 1;
inline int SmartCalibrationResponse::_internal_poses_size() const {
  return _impl_.poses_.size();
}
inline int SmartCalibrationResponse::poses_size() const {
  return _internal_poses_size();
}
inline void SmartCalibrationResponse::clear_poses() {
  _internal_mutable_poses()->Clear();
}
inline ::handEngine::v1::SmartPoseCapture* SmartCalibrationResponse::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:handEngine.v1.SmartCalibrationResponse.poses)
  return _internal_mutable_poses()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::SmartPoseCapture >*
SmartCalibrationResponse::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:handEngine.v1.SmartCalibrationResponse.poses)
  return _internal_mutable_poses();
}
inline const ::handEngine::v1::SmartPoseCapture& SmartCalibrationResponse::_internal_poses(int index) const {
  return _internal_poses().Get(index);
}
inline const ::handEngine::v1::SmartPoseCapture& SmartCalibrationResponse::poses(int index) const {
  // @@protoc_insertion_point(field_get:handEngine.v1.SmartCalibrationResponse.poses)
  return _internal_poses(index);
}
inline ::handEngine::v1::SmartPoseCapture* SmartCalibrationResponse::_internal_add_poses() {
  return _internal_mutable_poses()->Add();
}
inline ::handEngine::v1::SmartPoseCapture* SmartCalibrationResponse::add_poses() {
  ::handEngine::v1::SmartPoseCapture* _add = _internal_add_poses();
  // @@protoc_insertion_point(field_add:handEngine.v1.SmartCalibrationResponse.poses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::handEngine::v1::SmartPoseCapture >&
SmartCalibrationResponse::poses() const {
  // @@protoc_insertion_point(field_list:handEngine.v1.SmartCalibrationResponse.poses)
  return _internal_poses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::SmartPoseCapture>&
SmartCalibrationResponse::_internal_poses() const {
  return _impl_.poses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::handEngine::v1::SmartPoseCapture>*
SmartCalibrationResponse::_internal_mutable_poses() {
  return &_impl_.poses_;
}

// uint32 poseProgress = 3;
inline void SmartCalibrationResponse::clear_poseprogress() {
  _impl_.poseprogress_ = 0u;
}
inline ::uint32_t SmartCalibrationResponse::poseprogress() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.SmartCalibrationResponse.poseProgress)
  return _internal_poseprogress();
}
inline void SmartCalibrationResponse::set_poseprogress(::uint32_t value) {
  _internal_set_poseprogress(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.SmartCalibrationResponse.poseProgress)
}
inline ::uint32_t SmartCalibrationResponse::_internal_poseprogress() const {
  return _impl_.poseprogress_;
}
inline void SmartCalibrationResponse::_internal_set_poseprogress(::uint32_t value) {
  ;
  _impl_.poseprogress_ = value;
}

// -------------------------------------------------------------------

// HapticsInputRequest

// int32 performerId = 1;
inline void HapticsInputRequest::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t HapticsInputRequest::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.HapticsInputRequest.performerId)
  return _internal_performerid();
}
inline void HapticsInputRequest::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.HapticsInputRequest.performerId)
}
inline ::int32_t HapticsInputRequest::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void HapticsInputRequest::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// .handEngine.v1.Handedness handedness = 2;
inline void HapticsInputRequest::clear_handedness() {
  _impl_.handedness_ = 0;
}
inline ::handEngine::v1::Handedness HapticsInputRequest::handedness() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.HapticsInputRequest.handedness)
  return _internal_handedness();
}
inline void HapticsInputRequest::set_handedness(::handEngine::v1::Handedness value) {
   _internal_set_handedness(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.HapticsInputRequest.handedness)
}
inline ::handEngine::v1::Handedness HapticsInputRequest::_internal_handedness() const {
  return static_cast<::handEngine::v1::Handedness>(_impl_.handedness_);
}
inline void HapticsInputRequest::_internal_set_handedness(::handEngine::v1::Handedness value) {
  ;
  _impl_.handedness_ = value;
}

// .handEngine.v1.HapticPattern pattern = 3;
inline void HapticsInputRequest::clear_pattern() {
  _impl_.pattern_ = 0;
}
inline ::handEngine::v1::HapticPattern HapticsInputRequest::pattern() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.HapticsInputRequest.pattern)
  return _internal_pattern();
}
inline void HapticsInputRequest::set_pattern(::handEngine::v1::HapticPattern value) {
   _internal_set_pattern(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.HapticsInputRequest.pattern)
}
inline ::handEngine::v1::HapticPattern HapticsInputRequest::_internal_pattern() const {
  return static_cast<::handEngine::v1::HapticPattern>(_impl_.pattern_);
}
inline void HapticsInputRequest::_internal_set_pattern(::handEngine::v1::HapticPattern value) {
  ;
  _impl_.pattern_ = value;
}

// -------------------------------------------------------------------

// HapticsStatusResponse

// string message = 1;
inline void HapticsStatusResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HapticsStatusResponse::message() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.HapticsStatusResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HapticsStatusResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.HapticsStatusResponse.message)
}
inline std::string* HapticsStatusResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.HapticsStatusResponse.message)
  return _s;
}
inline const std::string& HapticsStatusResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HapticsStatusResponse::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HapticsStatusResponse::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* HapticsStatusResponse::release_message() {
  // @@protoc_insertion_point(field_release:handEngine.v1.HapticsStatusResponse.message)
  return _impl_.message_.Release();
}
inline void HapticsStatusResponse::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.HapticsStatusResponse.message)
}

// .handEngine.v1.HapticsStatus status = 2;
inline void HapticsStatusResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::handEngine::v1::HapticsStatus HapticsStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.HapticsStatusResponse.status)
  return _internal_status();
}
inline void HapticsStatusResponse::set_status(::handEngine::v1::HapticsStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.HapticsStatusResponse.status)
}
inline ::handEngine::v1::HapticsStatus HapticsStatusResponse::_internal_status() const {
  return static_cast<::handEngine::v1::HapticsStatus>(_impl_.status_);
}
inline void HapticsStatusResponse::_internal_set_status(::handEngine::v1::HapticsStatus value) {
  ;
  _impl_.status_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::handEngine::v1::ExpressCaptureRequest_CalibrationStatus> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::SmartPoseCaptureStatus> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::HapticsStatus> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_v1_2fperformer_2eproto_2epb_2eh


