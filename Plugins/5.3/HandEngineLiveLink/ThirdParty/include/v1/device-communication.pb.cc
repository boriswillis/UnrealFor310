// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/device-communication.proto
#include "EnableGrpcIncludes.h"
#include "v1/device-communication.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
#include "DisableGrpcIncludes.h"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace handEngine {
namespace v1 {
template <typename>
PROTOBUF_CONSTEXPR Product::Product(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.productcode_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.productfamily_)*/ 0
} {}
struct ProductDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProductDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProductDefaultTypeInternal() {}
  union {
    Product _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProductDefaultTypeInternal _Product_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeviceProperty::DeviceProperty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DevicePropertyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePropertyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePropertyDefaultTypeInternal() {}
  union {
    DeviceProperty _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePropertyDefaultTypeInternal _DeviceProperty_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FirmwareData::FirmwareData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.partname_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.major_)*/ 0u

  , /*decltype(_impl_.minor_)*/ 0u

  , /*decltype(_impl_.bugfix_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FirmwareDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FirmwareDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FirmwareDataDefaultTypeInternal() {}
  union {
    FirmwareData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FirmwareDataDefaultTypeInternal _FirmwareData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ManufacturingData::ManufacturingData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.partnumber_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.revision_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.monthofmanufacture_)*/ 0u

  , /*decltype(_impl_.yearofmanufacture_)*/ 0u

  , /*decltype(_impl_.batchnumber_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ManufacturingDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ManufacturingDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ManufacturingDataDefaultTypeInternal() {}
  union {
    ManufacturingData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ManufacturingDataDefaultTypeInternal _ManufacturingData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StretchSensorData::StretchSensorData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.thumbthumbside_)*/ 0u

  , /*decltype(_impl_.thumbmid_)*/ 0u

  , /*decltype(_impl_.thumbpinkyside_)*/ 0u

  , /*decltype(_impl_.dorsalthumbextension_)*/ 0u

  , /*decltype(_impl_.indexthumbside_)*/ 0u

  , /*decltype(_impl_.indexmid_)*/ 0u

  , /*decltype(_impl_.indexpinkyside_)*/ 0u

  , /*decltype(_impl_.middlethumbside_)*/ 0u

  , /*decltype(_impl_.middlemid_)*/ 0u

  , /*decltype(_impl_.middlepinkyside_)*/ 0u

  , /*decltype(_impl_.ringthumbside_)*/ 0u

  , /*decltype(_impl_.ringmid_)*/ 0u

  , /*decltype(_impl_.ringpinkyside_)*/ 0u

  , /*decltype(_impl_.pinkythumbside_)*/ 0u

  , /*decltype(_impl_.pinkymid_)*/ 0u

  , /*decltype(_impl_.pinkypinkyside_)*/ 0u
} {}
struct StretchSensorDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StretchSensorDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StretchSensorDataDefaultTypeInternal() {}
  union {
    StretchSensorData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StretchSensorDataDefaultTypeInternal _StretchSensorData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeviceInformation::DeviceInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.manufacturingdata_)*/{}
  , /*decltype(_impl_.properties_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.product_)*/nullptr
  , /*decltype(_impl_.size_)*/nullptr
  , /*decltype(_impl_.firmwaredata_)*/nullptr
  , /*decltype(_impl_.basecapacitances_)*/nullptr
  , /*decltype(_impl_.sensorsensitivity_)*/nullptr
  , /*decltype(_impl_.devicetype_)*/ 0

  , /*decltype(_impl_.location_)*/ 0
} {}
struct DeviceInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceInformationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceInformationDefaultTypeInternal() {}
  union {
    DeviceInformation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceInformationDefaultTypeInternal _DeviceInformation_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ImuData::ImuData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.accelx_)*/ 0u

  , /*decltype(_impl_.accely_)*/ 0u

  , /*decltype(_impl_.accelz_)*/ 0u

  , /*decltype(_impl_.gyrox_)*/ 0u

  , /*decltype(_impl_.gyroy_)*/ 0u

  , /*decltype(_impl_.gyroz_)*/ 0u

  , /*decltype(_impl_.magx_)*/ 0u

  , /*decltype(_impl_.magy_)*/ 0u

  , /*decltype(_impl_.magz_)*/ 0u

  , /*decltype(_impl_.temperature_)*/ 0u
} {}
struct ImuDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImuDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImuDataDefaultTypeInternal() {}
  union {
    ImuData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImuDataDefaultTypeInternal _ImuData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TimeData::TimeData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.internalmstime_)*/ 0u

  , /*decltype(_impl_.timecode_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TimeDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeDataDefaultTypeInternal() {}
  union {
    TimeData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeDataDefaultTypeInternal _TimeData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PeripheralState::PeripheralState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.batterylevel_)*/ 0u

  , /*decltype(_impl_.timesincelastjamsync_)*/ 0u

  , /*decltype(_impl_.sdcardpresence_)*/ false

  , /*decltype(_impl_.sdcardrecording_)*/ false
} {}
struct PeripheralStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeripheralStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeripheralStateDefaultTypeInternal() {}
  union {
    PeripheralState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeripheralStateDefaultTypeInternal _PeripheralState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CommandPacket::CommandPacket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.commanduid_)*/ 0u

  , /*decltype(_impl_.commandcode_)*/ 0
} {}
struct CommandPacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPacketDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPacketDefaultTypeInternal() {}
  union {
    CommandPacket _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPacketDefaultTypeInternal _CommandPacket_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeviceEvent::DeviceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.event_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceEventDefaultTypeInternal() {}
  union {
    DeviceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceEventDefaultTypeInternal _DeviceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DfuData::DfuData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dfuuid_)*/ 0u
} {}
struct DfuDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DfuDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DfuDataDefaultTypeInternal() {}
  union {
    DfuData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DfuDataDefaultTypeInternal _DfuData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeviceMessage::DeviceMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.serialnumber_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deviceinformation_)*/nullptr
  , /*decltype(_impl_.stretchsensordata_)*/nullptr
  , /*decltype(_impl_.imudata_)*/nullptr
  , /*decltype(_impl_.timedata_)*/nullptr
  , /*decltype(_impl_.peripheralstate_)*/nullptr
  , /*decltype(_impl_.commandresponse_)*/nullptr
  , /*decltype(_impl_.deviceevent_)*/nullptr
  , /*decltype(_impl_.dfudata_)*/nullptr
  , /*decltype(_impl_.packetcounter_)*/ 0u
} {}
struct DeviceMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceMessageDefaultTypeInternal() {}
  union {
    DeviceMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceMessageDefaultTypeInternal _DeviceMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AggregateMessage::AggregateMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.devicemessage_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AggregateMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AggregateMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AggregateMessageDefaultTypeInternal() {}
  union {
    AggregateMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AggregateMessageDefaultTypeInternal _AggregateMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DeviceCommand::DeviceCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.targetdevice_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.commandpacket_)*/nullptr
  , /*decltype(_impl_.dfudata_)*/nullptr} {}
struct DeviceCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceCommandDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceCommandDefaultTypeInternal() {}
  union {
    DeviceCommand _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceCommandDefaultTypeInternal _DeviceCommand_default_instance_;
}  // namespace v1
}  // namespace handEngine
namespace handEngine {
namespace v1 {
bool DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    DeviceType_strings[3] = {};

static const char DeviceType_names[] = {
    "DONGLE"
    "GLOVE"
    "UNKNOWN_DEVICE_TYPE"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceType_entries[] =
    {
        {{&DeviceType_names[0], 6}, 1},
        {{&DeviceType_names[6], 5}, 2},
        {{&DeviceType_names[11], 19}, 0},
};

static const int DeviceType_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_DEVICE_TYPE
    0,  // 1 -> DONGLE
    1,  // 2 -> GLOVE
};

const std::string& DeviceType_Name(DeviceType value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceType_entries, DeviceType_entries_by_number,
          3, DeviceType_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceType_entries, DeviceType_entries_by_number, 3,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : DeviceType_strings[idx].get();
}

bool DeviceType_Parse(absl::string_view name, DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceType>(int_value);
  }
  return success;
}
bool DeviceLocation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    DeviceLocation_strings[4] = {};

static const char DeviceLocation_names[] = {
    "LEFT_HAND"
    "RIGHT_HAND"
    "UNKNOWN_LOCATION"
    "USB"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceLocation_entries[] =
    {
        {{&DeviceLocation_names[0], 9}, 1},
        {{&DeviceLocation_names[9], 10}, 2},
        {{&DeviceLocation_names[19], 16}, 0},
        {{&DeviceLocation_names[35], 3}, 3},
};

static const int DeviceLocation_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_LOCATION
    0,  // 1 -> LEFT_HAND
    1,  // 2 -> RIGHT_HAND
    3,  // 3 -> USB
};

const std::string& DeviceLocation_Name(DeviceLocation value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceLocation_entries, DeviceLocation_entries_by_number,
          4, DeviceLocation_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceLocation_entries, DeviceLocation_entries_by_number, 4,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : DeviceLocation_strings[idx].get();
}

bool DeviceLocation_Parse(absl::string_view name, DeviceLocation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceLocation_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceLocation>(int_value);
  }
  return success;
}
bool ProductFamily_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ProductFamily_strings[4] = {};

static const char ProductFamily_names[] = {
    "REV_E"
    "REV_F"
    "REV_G"
    "UNKNOWN_DEVICE_REVISION"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProductFamily_entries[] =
    {
        {{&ProductFamily_names[0], 5}, 1},
        {{&ProductFamily_names[5], 5}, 2},
        {{&ProductFamily_names[10], 5}, 3},
        {{&ProductFamily_names[15], 23}, 0},
};

static const int ProductFamily_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_DEVICE_REVISION
    0,  // 1 -> REV_E
    1,  // 2 -> REV_F
    2,  // 3 -> REV_G
};

const std::string& ProductFamily_Name(ProductFamily value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProductFamily_entries, ProductFamily_entries_by_number,
          4, ProductFamily_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProductFamily_entries, ProductFamily_entries_by_number, 4,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : ProductFamily_strings[idx].get();
}

bool ProductFamily_Parse(absl::string_view name, ProductFamily* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProductFamily_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ProductFamily>(int_value);
  }
  return success;
}
bool PropertyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    PropertyType_strings[3] = {};

static const char PropertyType_names[] = {
    "COLOR"
    "DEVICE_SIZE"
    "MATERIAL"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PropertyType_entries[] =
    {
        {{&PropertyType_names[0], 5}, 1},
        {{&PropertyType_names[5], 11}, 0},
        {{&PropertyType_names[16], 8}, 2},
};

static const int PropertyType_entries_by_number[] = {
    1,  // 0 -> DEVICE_SIZE
    0,  // 1 -> COLOR
    2,  // 2 -> MATERIAL
};

const std::string& PropertyType_Name(PropertyType value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PropertyType_entries, PropertyType_entries_by_number,
          3, PropertyType_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PropertyType_entries, PropertyType_entries_by_number, 3,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : PropertyType_strings[idx].get();
}

bool PropertyType_Parse(absl::string_view name, PropertyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PropertyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PropertyType>(int_value);
  }
  return success;
}
bool CommandCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 99:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    CommandCode_strings[18] = {};

static const char CommandCode_names[] = {
    "ACTIVATE_HAPTICS"
    "CUSTOM_COMMAND"
    "DFU_FINISHED"
    "DFU_IN_PROGRESS"
    "DFU_START"
    "GET_FULL_DEVICE_INFO"
    "JAMSYNC_DEVICE"
    "PROGRAM_DEVICE_INFO"
    "PROGRAM_SERIAL_NUMBER"
    "SEND_TAKE_META_DATA"
    "SET_DEVICE_NAME"
    "SET_TOKEN"
    "START_RECORDING"
    "STOP_RECORDING"
    "TEST_ASIC"
    "TEST_FRAM"
    "UNKNOWN_DEVICE_COMMAND_CODE"
    "UNLOCK_DEVICE"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandCode_entries[] =
    {
        {{&CommandCode_names[0], 16}, 16},
        {{&CommandCode_names[16], 14}, 99},
        {{&CommandCode_names[30], 12}, 14},
        {{&CommandCode_names[42], 15}, 13},
        {{&CommandCode_names[57], 9}, 12},
        {{&CommandCode_names[66], 20}, 1},
        {{&CommandCode_names[86], 14}, 2},
        {{&CommandCode_names[100], 19}, 9},
        {{&CommandCode_names[119], 21}, 10},
        {{&CommandCode_names[140], 19}, 3},
        {{&CommandCode_names[159], 15}, 11},
        {{&CommandCode_names[174], 9}, 15},
        {{&CommandCode_names[183], 15}, 4},
        {{&CommandCode_names[198], 14}, 5},
        {{&CommandCode_names[212], 9}, 6},
        {{&CommandCode_names[221], 9}, 7},
        {{&CommandCode_names[230], 27}, 0},
        {{&CommandCode_names[257], 13}, 8},
};

static const int CommandCode_entries_by_number[] = {
    16,  // 0 -> UNKNOWN_DEVICE_COMMAND_CODE
    5,  // 1 -> GET_FULL_DEVICE_INFO
    6,  // 2 -> JAMSYNC_DEVICE
    9,  // 3 -> SEND_TAKE_META_DATA
    12,  // 4 -> START_RECORDING
    13,  // 5 -> STOP_RECORDING
    14,  // 6 -> TEST_ASIC
    15,  // 7 -> TEST_FRAM
    17,  // 8 -> UNLOCK_DEVICE
    7,  // 9 -> PROGRAM_DEVICE_INFO
    8,  // 10 -> PROGRAM_SERIAL_NUMBER
    10,  // 11 -> SET_DEVICE_NAME
    4,  // 12 -> DFU_START
    3,  // 13 -> DFU_IN_PROGRESS
    2,  // 14 -> DFU_FINISHED
    11,  // 15 -> SET_TOKEN
    0,  // 16 -> ACTIVATE_HAPTICS
    1,  // 99 -> CUSTOM_COMMAND
};

const std::string& CommandCode_Name(CommandCode value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandCode_entries, CommandCode_entries_by_number,
          18, CommandCode_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandCode_entries, CommandCode_entries_by_number, 18,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : CommandCode_strings[idx].get();
}

bool CommandCode_Parse(absl::string_view name, CommandCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandCode_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<CommandCode>(int_value);
  }
  return success;
}
bool Event_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 99:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    Event_strings[9] = {};

static const char Event_names[] = {
    "CONNECTED"
    "DEAD_BATTERY"
    "DEBUG_LOG"
    "DFU_READY"
    "DISCONNECTED"
    "LOW_BATTERY"
    "SENSOR_FAULT"
    "TOKEN_REQUEST"
    "UNKNOWN_EVENT"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Event_entries[] =
    {
        {{&Event_names[0], 9}, 3},
        {{&Event_names[9], 12}, 2},
        {{&Event_names[21], 9}, 99},
        {{&Event_names[30], 9}, 7},
        {{&Event_names[39], 12}, 4},
        {{&Event_names[51], 11}, 1},
        {{&Event_names[62], 12}, 5},
        {{&Event_names[74], 13}, 6},
        {{&Event_names[87], 13}, 0},
};

static const int Event_entries_by_number[] = {
    8,  // 0 -> UNKNOWN_EVENT
    5,  // 1 -> LOW_BATTERY
    1,  // 2 -> DEAD_BATTERY
    0,  // 3 -> CONNECTED
    4,  // 4 -> DISCONNECTED
    6,  // 5 -> SENSOR_FAULT
    7,  // 6 -> TOKEN_REQUEST
    3,  // 7 -> DFU_READY
    2,  // 99 -> DEBUG_LOG
};

const std::string& Event_Name(Event value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Event_entries, Event_entries_by_number,
          9, Event_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Event_entries, Event_entries_by_number, 9,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : Event_strings[idx].get();
}

bool Event_Parse(absl::string_view name, Event* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Event_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<Event>(int_value);
  }
  return success;
}
// ===================================================================

class Product::_Internal {
 public:
  using HasBits = decltype(std::declval<Product>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Product, _impl_._has_bits_);
  static void set_has_productcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Product::Product(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.Product)
}
Product::Product(const Product& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Product* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.productcode_) {}

    , decltype(_impl_.productfamily_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.productcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.productcode_.Set(from._internal_productcode(), _this->GetArenaForAllocation());
  }
  _this->_impl_.productfamily_ = from._impl_.productfamily_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.Product)
}

inline void Product::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.productcode_) {}

    , decltype(_impl_.productfamily_) { 0 }

  };
  _impl_.productcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.productcode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Product::~Product() {
  // @@protoc_insertion_point(destructor:handEngine.v1.Product)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Product::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.productcode_.Destroy();
}

void Product::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Product::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.Product)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.productcode_.ClearNonDefaultToEmpty();
  }
  _impl_.productfamily_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Product::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .handEngine.v1.ProductFamily productFamily = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_productfamily(static_cast<::handEngine::v1::ProductFamily>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string productCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_productcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Product::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.Product)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .handEngine.v1.ProductFamily productFamily = 1;
  if (this->_internal_productfamily() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_productfamily(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string productCode = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_productcode();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.Product.productCode");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.Product)
  return target;
}

::size_t Product::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.Product)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string productCode = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_productcode());
  }

  // .handEngine.v1.ProductFamily productFamily = 1;
  if (this->_internal_productfamily() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_productfamily());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Product::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Product*>(
      &from));
}

void Product::MergeFrom(const Product& from) {
  Product* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.Product)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_productcode(from._internal_productcode());
  }
  if (from._internal_productfamily() != 0) {
    _this->_internal_set_productfamily(from._internal_productfamily());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Product::CopyFrom(const Product& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.Product)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Product::IsInitialized() const {
  return true;
}

void Product::InternalSwap(Product* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.productcode_, lhs_arena,
                                       &other->_impl_.productcode_, rhs_arena);
  swap(_impl_.productfamily_, other->_impl_.productfamily_);
}

std::string Product::GetTypeName() const {
  return "handEngine.v1.Product";
}

// ===================================================================

class DeviceProperty::_Internal {
 public:
};

DeviceProperty::DeviceProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.DeviceProperty)
}
DeviceProperty::DeviceProperty(const DeviceProperty& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceProperty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) {}

    , decltype(_impl_.type_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.DeviceProperty)
}

inline void DeviceProperty::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) {}

    , decltype(_impl_.type_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceProperty::~DeviceProperty() {
  // @@protoc_insertion_point(destructor:handEngine.v1.DeviceProperty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceProperty::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void DeviceProperty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceProperty::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.DeviceProperty)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceProperty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .handEngine.v1.PropertyType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::handEngine::v1::PropertyType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeviceProperty::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.DeviceProperty)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .handEngine.v1.PropertyType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    const std::string& _s = this->_internal_value();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.DeviceProperty.value");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.DeviceProperty)
  return target;
}

::size_t DeviceProperty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.DeviceProperty)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_value());
  }

  // .handEngine.v1.PropertyType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceProperty::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceProperty*>(
      &from));
}

void DeviceProperty::MergeFrom(const DeviceProperty& from) {
  DeviceProperty* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.DeviceProperty)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceProperty::CopyFrom(const DeviceProperty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.DeviceProperty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceProperty::IsInitialized() const {
  return true;
}

void DeviceProperty::InternalSwap(DeviceProperty* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena,
                                       &other->_impl_.value_, rhs_arena);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string DeviceProperty::GetTypeName() const {
  return "handEngine.v1.DeviceProperty";
}

// ===================================================================

class FirmwareData::_Internal {
 public:
};

FirmwareData::FirmwareData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.FirmwareData)
}
FirmwareData::FirmwareData(const FirmwareData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FirmwareData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.partname_) {}

    , decltype(_impl_.major_) {}

    , decltype(_impl_.minor_) {}

    , decltype(_impl_.bugfix_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.partname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.partname_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_partname().empty()) {
    _this->_impl_.partname_.Set(from._internal_partname(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.major_, &from._impl_.major_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.bugfix_) -
    reinterpret_cast<char*>(&_impl_.major_)) + sizeof(_impl_.bugfix_));
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.FirmwareData)
}

inline void FirmwareData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.partname_) {}

    , decltype(_impl_.major_) { 0u }

    , decltype(_impl_.minor_) { 0u }

    , decltype(_impl_.bugfix_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.partname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.partname_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FirmwareData::~FirmwareData() {
  // @@protoc_insertion_point(destructor:handEngine.v1.FirmwareData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FirmwareData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partname_.Destroy();
}

void FirmwareData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FirmwareData::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.FirmwareData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partname_.ClearToEmpty();
  ::memset(&_impl_.major_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.bugfix_) -
      reinterpret_cast<char*>(&_impl_.major_)) + sizeof(_impl_.bugfix_));
  _internal_metadata_.Clear<std::string>();
}

const char* FirmwareData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string partName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_partname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 major = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 minor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 bugfix = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.bugfix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FirmwareData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.FirmwareData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string partName = 1;
  if (!this->_internal_partname().empty()) {
    const std::string& _s = this->_internal_partname();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.FirmwareData.partName");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 major = 2;
  if (this->_internal_major() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_major(), target);
  }

  // uint32 minor = 3;
  if (this->_internal_minor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_minor(), target);
  }

  // uint32 bugfix = 4;
  if (this->_internal_bugfix() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_bugfix(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.FirmwareData)
  return target;
}

::size_t FirmwareData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.FirmwareData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string partName = 1;
  if (!this->_internal_partname().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_partname());
  }

  // uint32 major = 2;
  if (this->_internal_major() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_major());
  }

  // uint32 minor = 3;
  if (this->_internal_minor() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_minor());
  }

  // uint32 bugfix = 4;
  if (this->_internal_bugfix() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_bugfix());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FirmwareData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FirmwareData*>(
      &from));
}

void FirmwareData::MergeFrom(const FirmwareData& from) {
  FirmwareData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.FirmwareData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_partname().empty()) {
    _this->_internal_set_partname(from._internal_partname());
  }
  if (from._internal_major() != 0) {
    _this->_internal_set_major(from._internal_major());
  }
  if (from._internal_minor() != 0) {
    _this->_internal_set_minor(from._internal_minor());
  }
  if (from._internal_bugfix() != 0) {
    _this->_internal_set_bugfix(from._internal_bugfix());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FirmwareData::CopyFrom(const FirmwareData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.FirmwareData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareData::IsInitialized() const {
  return true;
}

void FirmwareData::InternalSwap(FirmwareData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.partname_, lhs_arena,
                                       &other->_impl_.partname_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FirmwareData, _impl_.bugfix_)
      + sizeof(FirmwareData::_impl_.bugfix_)
      - PROTOBUF_FIELD_OFFSET(FirmwareData, _impl_.major_)>(
          reinterpret_cast<char*>(&_impl_.major_),
          reinterpret_cast<char*>(&other->_impl_.major_));
}

std::string FirmwareData::GetTypeName() const {
  return "handEngine.v1.FirmwareData";
}

// ===================================================================

class ManufacturingData::_Internal {
 public:
};

ManufacturingData::ManufacturingData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.ManufacturingData)
}
ManufacturingData::ManufacturingData(const ManufacturingData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ManufacturingData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.partnumber_) {}

    , decltype(_impl_.revision_) {}

    , decltype(_impl_.monthofmanufacture_) {}

    , decltype(_impl_.yearofmanufacture_) {}

    , decltype(_impl_.batchnumber_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.partnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.partnumber_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_partnumber().empty()) {
    _this->_impl_.partnumber_.Set(from._internal_partnumber(), _this->GetArenaForAllocation());
  }
  _impl_.revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.revision_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_revision().empty()) {
    _this->_impl_.revision_.Set(from._internal_revision(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.monthofmanufacture_, &from._impl_.monthofmanufacture_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.batchnumber_) -
    reinterpret_cast<char*>(&_impl_.monthofmanufacture_)) + sizeof(_impl_.batchnumber_));
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.ManufacturingData)
}

inline void ManufacturingData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.partnumber_) {}

    , decltype(_impl_.revision_) {}

    , decltype(_impl_.monthofmanufacture_) { 0u }

    , decltype(_impl_.yearofmanufacture_) { 0u }

    , decltype(_impl_.batchnumber_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.partnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.partnumber_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.revision_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ManufacturingData::~ManufacturingData() {
  // @@protoc_insertion_point(destructor:handEngine.v1.ManufacturingData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ManufacturingData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partnumber_.Destroy();
  _impl_.revision_.Destroy();
}

void ManufacturingData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ManufacturingData::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.ManufacturingData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partnumber_.ClearToEmpty();
  _impl_.revision_.ClearToEmpty();
  ::memset(&_impl_.monthofmanufacture_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.batchnumber_) -
      reinterpret_cast<char*>(&_impl_.monthofmanufacture_)) + sizeof(_impl_.batchnumber_));
  _internal_metadata_.Clear<std::string>();
}

const char* ManufacturingData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string partNumber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_partnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string revision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_revision();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 monthOfManufacture = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.monthofmanufacture_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 yearOfManufacture = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.yearofmanufacture_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 batchNumber = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.batchnumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ManufacturingData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.ManufacturingData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string partNumber = 1;
  if (!this->_internal_partnumber().empty()) {
    const std::string& _s = this->_internal_partnumber();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.ManufacturingData.partNumber");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string revision = 2;
  if (!this->_internal_revision().empty()) {
    const std::string& _s = this->_internal_revision();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.ManufacturingData.revision");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint32 monthOfManufacture = 3;
  if (this->_internal_monthofmanufacture() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_monthofmanufacture(), target);
  }

  // uint32 yearOfManufacture = 4;
  if (this->_internal_yearofmanufacture() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_yearofmanufacture(), target);
  }

  // uint32 batchNumber = 5;
  if (this->_internal_batchnumber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_batchnumber(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.ManufacturingData)
  return target;
}

::size_t ManufacturingData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.ManufacturingData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string partNumber = 1;
  if (!this->_internal_partnumber().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_partnumber());
  }

  // string revision = 2;
  if (!this->_internal_revision().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_revision());
  }

  // uint32 monthOfManufacture = 3;
  if (this->_internal_monthofmanufacture() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_monthofmanufacture());
  }

  // uint32 yearOfManufacture = 4;
  if (this->_internal_yearofmanufacture() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_yearofmanufacture());
  }

  // uint32 batchNumber = 5;
  if (this->_internal_batchnumber() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_batchnumber());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ManufacturingData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ManufacturingData*>(
      &from));
}

void ManufacturingData::MergeFrom(const ManufacturingData& from) {
  ManufacturingData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.ManufacturingData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_partnumber().empty()) {
    _this->_internal_set_partnumber(from._internal_partnumber());
  }
  if (!from._internal_revision().empty()) {
    _this->_internal_set_revision(from._internal_revision());
  }
  if (from._internal_monthofmanufacture() != 0) {
    _this->_internal_set_monthofmanufacture(from._internal_monthofmanufacture());
  }
  if (from._internal_yearofmanufacture() != 0) {
    _this->_internal_set_yearofmanufacture(from._internal_yearofmanufacture());
  }
  if (from._internal_batchnumber() != 0) {
    _this->_internal_set_batchnumber(from._internal_batchnumber());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ManufacturingData::CopyFrom(const ManufacturingData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.ManufacturingData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ManufacturingData::IsInitialized() const {
  return true;
}

void ManufacturingData::InternalSwap(ManufacturingData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.partnumber_, lhs_arena,
                                       &other->_impl_.partnumber_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.revision_, lhs_arena,
                                       &other->_impl_.revision_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ManufacturingData, _impl_.batchnumber_)
      + sizeof(ManufacturingData::_impl_.batchnumber_)
      - PROTOBUF_FIELD_OFFSET(ManufacturingData, _impl_.monthofmanufacture_)>(
          reinterpret_cast<char*>(&_impl_.monthofmanufacture_),
          reinterpret_cast<char*>(&other->_impl_.monthofmanufacture_));
}

std::string ManufacturingData::GetTypeName() const {
  return "handEngine.v1.ManufacturingData";
}

// ===================================================================

class StretchSensorData::_Internal {
 public:
  using HasBits = decltype(std::declval<StretchSensorData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StretchSensorData, _impl_._has_bits_);
  static void set_has_thumbthumbside(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_thumbmid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_thumbpinkyside(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dorsalthumbextension(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_indexthumbside(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_indexmid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_indexpinkyside(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_middlethumbside(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_middlemid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_middlepinkyside(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ringthumbside(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_ringmid(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_ringpinkyside(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_pinkythumbside(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_pinkymid(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_pinkypinkyside(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

StretchSensorData::StretchSensorData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.StretchSensorData)
}
StretchSensorData::StretchSensorData(const StretchSensorData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.StretchSensorData)
}

inline void StretchSensorData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.thumbthumbside_) { 0u }

    , decltype(_impl_.thumbmid_) { 0u }

    , decltype(_impl_.thumbpinkyside_) { 0u }

    , decltype(_impl_.dorsalthumbextension_) { 0u }

    , decltype(_impl_.indexthumbside_) { 0u }

    , decltype(_impl_.indexmid_) { 0u }

    , decltype(_impl_.indexpinkyside_) { 0u }

    , decltype(_impl_.middlethumbside_) { 0u }

    , decltype(_impl_.middlemid_) { 0u }

    , decltype(_impl_.middlepinkyside_) { 0u }

    , decltype(_impl_.ringthumbside_) { 0u }

    , decltype(_impl_.ringmid_) { 0u }

    , decltype(_impl_.ringpinkyside_) { 0u }

    , decltype(_impl_.pinkythumbside_) { 0u }

    , decltype(_impl_.pinkymid_) { 0u }

    , decltype(_impl_.pinkypinkyside_) { 0u }

  };
}

StretchSensorData::~StretchSensorData() {
  // @@protoc_insertion_point(destructor:handEngine.v1.StretchSensorData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StretchSensorData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void StretchSensorData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StretchSensorData::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.StretchSensorData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.thumbthumbside_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.middlethumbside_) -
        reinterpret_cast<char*>(&_impl_.thumbthumbside_)) + sizeof(_impl_.middlethumbside_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.middlemid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pinkypinkyside_) -
        reinterpret_cast<char*>(&_impl_.middlemid_)) + sizeof(_impl_.pinkypinkyside_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StretchSensorData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 thumbThumbside = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_thumbthumbside(&has_bits);
          _impl_.thumbthumbside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 thumbMid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_thumbmid(&has_bits);
          _impl_.thumbmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 thumbPinkyside = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_thumbpinkyside(&has_bits);
          _impl_.thumbpinkyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 dorsalThumbExtension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_dorsalthumbextension(&has_bits);
          _impl_.dorsalthumbextension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 indexThumbside = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_indexthumbside(&has_bits);
          _impl_.indexthumbside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 indexMid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_indexmid(&has_bits);
          _impl_.indexmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 indexPinkyside = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_indexpinkyside(&has_bits);
          _impl_.indexpinkyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 middleThumbside = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_middlethumbside(&has_bits);
          _impl_.middlethumbside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 middleMid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_middlemid(&has_bits);
          _impl_.middlemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 middlePinkyside = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_middlepinkyside(&has_bits);
          _impl_.middlepinkyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 ringThumbside = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_ringthumbside(&has_bits);
          _impl_.ringthumbside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 ringMid = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_ringmid(&has_bits);
          _impl_.ringmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 ringPinkyside = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_ringpinkyside(&has_bits);
          _impl_.ringpinkyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pinkyThumbside = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_pinkythumbside(&has_bits);
          _impl_.pinkythumbside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pinkyMid = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _Internal::set_has_pinkymid(&has_bits);
          _impl_.pinkymid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pinkyPinkyside = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_pinkypinkyside(&has_bits);
          _impl_.pinkypinkyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StretchSensorData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.StretchSensorData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 thumbThumbside = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_thumbthumbside(), target);
  }

  // optional uint32 thumbMid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_thumbmid(), target);
  }

  // optional uint32 thumbPinkyside = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_thumbpinkyside(), target);
  }

  // optional uint32 dorsalThumbExtension = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_dorsalthumbextension(), target);
  }

  // optional uint32 indexThumbside = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_indexthumbside(), target);
  }

  // optional uint32 indexMid = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_indexmid(), target);
  }

  // optional uint32 indexPinkyside = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_indexpinkyside(), target);
  }

  // optional uint32 middleThumbside = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_middlethumbside(), target);
  }

  // optional uint32 middleMid = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_middlemid(), target);
  }

  // optional uint32 middlePinkyside = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_middlepinkyside(), target);
  }

  // optional uint32 ringThumbside = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_ringthumbside(), target);
  }

  // optional uint32 ringMid = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        12, this->_internal_ringmid(), target);
  }

  // optional uint32 ringPinkyside = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        13, this->_internal_ringpinkyside(), target);
  }

  // optional uint32 pinkyThumbside = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        14, this->_internal_pinkythumbside(), target);
  }

  // optional uint32 pinkyMid = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this->_internal_pinkymid(), target);
  }

  // optional uint32 pinkyPinkyside = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this->_internal_pinkypinkyside(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.StretchSensorData)
  return target;
}

::size_t StretchSensorData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.StretchSensorData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 thumbThumbside = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_thumbthumbside());
    }

    // optional uint32 thumbMid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_thumbmid());
    }

    // optional uint32 thumbPinkyside = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_thumbpinkyside());
    }

    // optional uint32 dorsalThumbExtension = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_dorsalthumbextension());
    }

    // optional uint32 indexThumbside = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_indexthumbside());
    }

    // optional uint32 indexMid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_indexmid());
    }

    // optional uint32 indexPinkyside = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_indexpinkyside());
    }

    // optional uint32 middleThumbside = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_middlethumbside());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 middleMid = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_middlemid());
    }

    // optional uint32 middlePinkyside = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_middlepinkyside());
    }

    // optional uint32 ringThumbside = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ringthumbside());
    }

    // optional uint32 ringMid = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ringmid());
    }

    // optional uint32 ringPinkyside = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ringpinkyside());
    }

    // optional uint32 pinkyThumbside = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pinkythumbside());
    }

    // optional uint32 pinkyMid = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pinkymid());
    }

    // optional uint32 pinkyPinkyside = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_pinkypinkyside());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StretchSensorData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StretchSensorData*>(
      &from));
}

void StretchSensorData::MergeFrom(const StretchSensorData& from) {
  StretchSensorData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.StretchSensorData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.thumbthumbside_ = from._impl_.thumbthumbside_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.thumbmid_ = from._impl_.thumbmid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.thumbpinkyside_ = from._impl_.thumbpinkyside_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dorsalthumbextension_ = from._impl_.dorsalthumbextension_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.indexthumbside_ = from._impl_.indexthumbside_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.indexmid_ = from._impl_.indexmid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.indexpinkyside_ = from._impl_.indexpinkyside_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.middlethumbside_ = from._impl_.middlethumbside_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.middlemid_ = from._impl_.middlemid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.middlepinkyside_ = from._impl_.middlepinkyside_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.ringthumbside_ = from._impl_.ringthumbside_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.ringmid_ = from._impl_.ringmid_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.ringpinkyside_ = from._impl_.ringpinkyside_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.pinkythumbside_ = from._impl_.pinkythumbside_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.pinkymid_ = from._impl_.pinkymid_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.pinkypinkyside_ = from._impl_.pinkypinkyside_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StretchSensorData::CopyFrom(const StretchSensorData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.StretchSensorData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StretchSensorData::IsInitialized() const {
  return true;
}

void StretchSensorData::InternalSwap(StretchSensorData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StretchSensorData, _impl_.pinkypinkyside_)
      + sizeof(StretchSensorData::_impl_.pinkypinkyside_)
      - PROTOBUF_FIELD_OFFSET(StretchSensorData, _impl_.thumbthumbside_)>(
          reinterpret_cast<char*>(&_impl_.thumbthumbside_),
          reinterpret_cast<char*>(&other->_impl_.thumbthumbside_));
}

std::string StretchSensorData::GetTypeName() const {
  return "handEngine.v1.StretchSensorData";
}

// ===================================================================

class DeviceInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceInformation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DeviceInformation, _impl_._has_bits_);
  static void set_has_devicetype(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::handEngine::v1::Product& product(const DeviceInformation* msg);
  static void set_has_product(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::handEngine::v1::DeviceProperty& size(const DeviceInformation* msg);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::handEngine::v1::FirmwareData& firmwaredata(const DeviceInformation* msg);
  static void set_has_firmwaredata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::handEngine::v1::StretchSensorData& basecapacitances(const DeviceInformation* msg);
  static void set_has_basecapacitances(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::handEngine::v1::StretchSensorData& sensorsensitivity(const DeviceInformation* msg);
  static void set_has_sensorsensitivity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::handEngine::v1::Product&
DeviceInformation::_Internal::product(const DeviceInformation* msg) {
  return *msg->_impl_.product_;
}
const ::handEngine::v1::DeviceProperty&
DeviceInformation::_Internal::size(const DeviceInformation* msg) {
  return *msg->_impl_.size_;
}
const ::handEngine::v1::FirmwareData&
DeviceInformation::_Internal::firmwaredata(const DeviceInformation* msg) {
  return *msg->_impl_.firmwaredata_;
}
const ::handEngine::v1::StretchSensorData&
DeviceInformation::_Internal::basecapacitances(const DeviceInformation* msg) {
  return *msg->_impl_.basecapacitances_;
}
const ::handEngine::v1::StretchSensorData&
DeviceInformation::_Internal::sensorsensitivity(const DeviceInformation* msg) {
  return *msg->_impl_.sensorsensitivity_;
}
DeviceInformation::DeviceInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.DeviceInformation)
}
DeviceInformation::DeviceInformation(const DeviceInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.manufacturingdata_){from._impl_.manufacturingdata_}
    , decltype(_impl_.properties_){from._impl_.properties_}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.product_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.firmwaredata_){nullptr}
    , decltype(_impl_.basecapacitances_){nullptr}
    , decltype(_impl_.sensorsensitivity_){nullptr}
    , decltype(_impl_.devicetype_) {}

    , decltype(_impl_.location_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.product_ = new ::handEngine::v1::Product(*from._impl_.product_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.size_ = new ::handEngine::v1::DeviceProperty(*from._impl_.size_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.firmwaredata_ = new ::handEngine::v1::FirmwareData(*from._impl_.firmwaredata_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.basecapacitances_ = new ::handEngine::v1::StretchSensorData(*from._impl_.basecapacitances_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.sensorsensitivity_ = new ::handEngine::v1::StretchSensorData(*from._impl_.sensorsensitivity_);
  }
  ::memcpy(&_impl_.devicetype_, &from._impl_.devicetype_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.location_) -
    reinterpret_cast<char*>(&_impl_.devicetype_)) + sizeof(_impl_.location_));
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.DeviceInformation)
}

inline void DeviceInformation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.manufacturingdata_){arena}
    , decltype(_impl_.properties_){arena}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.product_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.firmwaredata_){nullptr}
    , decltype(_impl_.basecapacitances_){nullptr}
    , decltype(_impl_.sensorsensitivity_){nullptr}
    , decltype(_impl_.devicetype_) { 0 }

    , decltype(_impl_.location_) { 0 }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceInformation::~DeviceInformation() {
  // @@protoc_insertion_point(destructor:handEngine.v1.DeviceInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceInformation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_manufacturingdata()->~RepeatedPtrField();
  _internal_mutable_properties()->~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.product_;
  if (this != internal_default_instance()) delete _impl_.size_;
  if (this != internal_default_instance()) delete _impl_.firmwaredata_;
  if (this != internal_default_instance()) delete _impl_.basecapacitances_;
  if (this != internal_default_instance()) delete _impl_.sensorsensitivity_;
}

void DeviceInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.DeviceInformation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_manufacturingdata()->Clear();
  _internal_mutable_properties()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.product_ != nullptr);
      _impl_.product_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.size_ != nullptr);
      _impl_.size_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.firmwaredata_ != nullptr);
      _impl_.firmwaredata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.basecapacitances_ != nullptr);
      _impl_.basecapacitances_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.sensorsensitivity_ != nullptr);
      _impl_.sensorsensitivity_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.devicetype_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.location_) -
        reinterpret_cast<char*>(&_impl_.devicetype_)) + sizeof(_impl_.location_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .handEngine.v1.DeviceType deviceType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_devicetype(static_cast<::handEngine::v1::DeviceType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.Product product = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_product(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.DeviceProperty size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.DeviceLocation location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_location(static_cast<::handEngine::v1::DeviceLocation>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .handEngine.v1.ManufacturingData manufacturingData = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_manufacturingdata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .handEngine.v1.DeviceProperty properties = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.FirmwareData firmwareData = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_firmwaredata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.StretchSensorData baseCapacitances = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_basecapacitances(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.StretchSensorData sensorSensitivity = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sensorsensitivity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeviceInformation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.DeviceInformation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .handEngine.v1.DeviceType deviceType = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_devicetype(), target);
  }

  // optional .handEngine.v1.Product product = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::product(this),
        _Internal::product(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.DeviceProperty size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::size(this),
        _Internal::size(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.DeviceLocation location = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_location(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.DeviceInformation.name");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // repeated .handEngine.v1.ManufacturingData manufacturingData = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_manufacturingdata_size()); i < n; i++) {
    const auto& repfield = this->_internal_manufacturingdata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .handEngine.v1.DeviceProperty properties = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.FirmwareData firmwareData = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::firmwaredata(this),
        _Internal::firmwaredata(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.StretchSensorData baseCapacitances = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::basecapacitances(this),
        _Internal::basecapacitances(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.StretchSensorData sensorSensitivity = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sensorsensitivity(this),
        _Internal::sensorsensitivity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.DeviceInformation)
  return target;
}

::size_t DeviceInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.DeviceInformation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .handEngine.v1.ManufacturingData manufacturingData = 6;
  total_size += 1UL * this->_internal_manufacturingdata_size();
  for (const auto& msg : this->_internal_manufacturingdata()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .handEngine.v1.DeviceProperty properties = 7;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_internal_properties()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional .handEngine.v1.Product product = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.product_);
    }

    // optional .handEngine.v1.DeviceProperty size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.size_);
    }

    // optional .handEngine.v1.FirmwareData firmwareData = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.firmwaredata_);
    }

    // optional .handEngine.v1.StretchSensorData baseCapacitances = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.basecapacitances_);
    }

    // optional .handEngine.v1.StretchSensorData sensorSensitivity = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sensorsensitivity_);
    }

    // optional .handEngine.v1.DeviceType deviceType = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_devicetype());
    }

    // optional .handEngine.v1.DeviceLocation location = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_location());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceInformation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceInformation*>(
      &from));
}

void DeviceInformation::MergeFrom(const DeviceInformation& from) {
  DeviceInformation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.DeviceInformation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_manufacturingdata()->MergeFrom(from._internal_manufacturingdata());
  _this->_internal_mutable_properties()->MergeFrom(from._internal_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_product()->::handEngine::v1::Product::MergeFrom(
          from._internal_product());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_size()->::handEngine::v1::DeviceProperty::MergeFrom(
          from._internal_size());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_firmwaredata()->::handEngine::v1::FirmwareData::MergeFrom(
          from._internal_firmwaredata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_basecapacitances()->::handEngine::v1::StretchSensorData::MergeFrom(
          from._internal_basecapacitances());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_sensorsensitivity()->::handEngine::v1::StretchSensorData::MergeFrom(
          from._internal_sensorsensitivity());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.devicetype_ = from._impl_.devicetype_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.location_ = from._impl_.location_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceInformation::CopyFrom(const DeviceInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.DeviceInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInformation::IsInitialized() const {
  return true;
}

void DeviceInformation::InternalSwap(DeviceInformation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_manufacturingdata()->InternalSwap(other->_internal_mutable_manufacturingdata());
  _internal_mutable_properties()->InternalSwap(other->_internal_mutable_properties());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceInformation, _impl_.location_)
      + sizeof(DeviceInformation::_impl_.location_)
      - PROTOBUF_FIELD_OFFSET(DeviceInformation, _impl_.product_)>(
          reinterpret_cast<char*>(&_impl_.product_),
          reinterpret_cast<char*>(&other->_impl_.product_));
}

std::string DeviceInformation::GetTypeName() const {
  return "handEngine.v1.DeviceInformation";
}

// ===================================================================

class ImuData::_Internal {
 public:
  using HasBits = decltype(std::declval<ImuData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ImuData, _impl_._has_bits_);
  static void set_has_accelx(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_accely(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_accelz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gyrox(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gyroy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gyroz(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_magx(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_magy(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_magz(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

ImuData::ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.ImuData)
}
ImuData::ImuData(const ImuData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.ImuData)
}

inline void ImuData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accelx_) { 0u }

    , decltype(_impl_.accely_) { 0u }

    , decltype(_impl_.accelz_) { 0u }

    , decltype(_impl_.gyrox_) { 0u }

    , decltype(_impl_.gyroy_) { 0u }

    , decltype(_impl_.gyroz_) { 0u }

    , decltype(_impl_.magx_) { 0u }

    , decltype(_impl_.magy_) { 0u }

    , decltype(_impl_.magz_) { 0u }

    , decltype(_impl_.temperature_) { 0u }

  };
}

ImuData::~ImuData() {
  // @@protoc_insertion_point(destructor:handEngine.v1.ImuData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImuData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImuData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImuData::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.ImuData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.accelx_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.magy_) -
        reinterpret_cast<char*>(&_impl_.accelx_)) + sizeof(_impl_.magy_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.magz_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.temperature_) -
        reinterpret_cast<char*>(&_impl_.magz_)) + sizeof(_impl_.temperature_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ImuData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 accelX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_accelx(&has_bits);
          _impl_.accelx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 accelY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_accely(&has_bits);
          _impl_.accely_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 accelZ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_accelz(&has_bits);
          _impl_.accelz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gyroX = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_gyrox(&has_bits);
          _impl_.gyrox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gyroY = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_gyroy(&has_bits);
          _impl_.gyroy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gyroZ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_gyroz(&has_bits);
          _impl_.gyroz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 magX = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_magx(&has_bits);
          _impl_.magx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 magY = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_magy(&has_bits);
          _impl_.magy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 magZ = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_magz(&has_bits);
          _impl_.magz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 temperature = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_temperature(&has_bits);
          _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ImuData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.ImuData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 accelX = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_accelx(), target);
  }

  // optional uint32 accelY = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_accely(), target);
  }

  // optional uint32 accelZ = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_accelz(), target);
  }

  // optional uint32 gyroX = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_gyrox(), target);
  }

  // optional uint32 gyroY = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_gyroy(), target);
  }

  // optional uint32 gyroZ = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_gyroz(), target);
  }

  // optional uint32 magX = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_magx(), target);
  }

  // optional uint32 magY = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_magy(), target);
  }

  // optional uint32 magZ = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_magz(), target);
  }

  // optional uint32 temperature = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_temperature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.ImuData)
  return target;
}

::size_t ImuData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.ImuData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 accelX = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_accelx());
    }

    // optional uint32 accelY = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_accely());
    }

    // optional uint32 accelZ = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_accelz());
    }

    // optional uint32 gyroX = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gyrox());
    }

    // optional uint32 gyroY = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gyroy());
    }

    // optional uint32 gyroZ = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gyroz());
    }

    // optional uint32 magX = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_magx());
    }

    // optional uint32 magY = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_magy());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 magZ = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_magz());
    }

    // optional uint32 temperature = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_temperature());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImuData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ImuData*>(
      &from));
}

void ImuData::MergeFrom(const ImuData& from) {
  ImuData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.ImuData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.accelx_ = from._impl_.accelx_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.accely_ = from._impl_.accely_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.accelz_ = from._impl_.accelz_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gyrox_ = from._impl_.gyrox_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gyroy_ = from._impl_.gyroy_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.gyroz_ = from._impl_.gyroz_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.magx_ = from._impl_.magx_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.magy_ = from._impl_.magy_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.magz_ = from._impl_.magz_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.temperature_ = from._impl_.temperature_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImuData::CopyFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuData::IsInitialized() const {
  return true;
}

void ImuData::InternalSwap(ImuData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImuData, _impl_.temperature_)
      + sizeof(ImuData::_impl_.temperature_)
      - PROTOBUF_FIELD_OFFSET(ImuData, _impl_.accelx_)>(
          reinterpret_cast<char*>(&_impl_.accelx_),
          reinterpret_cast<char*>(&other->_impl_.accelx_));
}

std::string ImuData::GetTypeName() const {
  return "handEngine.v1.ImuData";
}

// ===================================================================

class TimeData::_Internal {
 public:
};

TimeData::TimeData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.TimeData)
}
TimeData::TimeData(const TimeData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.TimeData)
}

inline void TimeData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.internalmstime_) { 0u }

    , decltype(_impl_.timecode_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TimeData::~TimeData() {
  // @@protoc_insertion_point(destructor:handEngine.v1.TimeData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeData::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.TimeData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.internalmstime_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.timecode_) -
      reinterpret_cast<char*>(&_impl_.internalmstime_)) + sizeof(_impl_.timecode_));
  _internal_metadata_.Clear<std::string>();
}

const char* TimeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 internalMsTime = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.internalmstime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 timeCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.timecode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TimeData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.TimeData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 internalMsTime = 1;
  if (this->_internal_internalmstime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_internalmstime(), target);
  }

  // uint32 timeCode = 2;
  if (this->_internal_timecode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_timecode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.TimeData)
  return target;
}

::size_t TimeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.TimeData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 internalMsTime = 1;
  if (this->_internal_internalmstime() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_internalmstime());
  }

  // uint32 timeCode = 2;
  if (this->_internal_timecode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_timecode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimeData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimeData*>(
      &from));
}

void TimeData::MergeFrom(const TimeData& from) {
  TimeData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.TimeData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_internalmstime() != 0) {
    _this->_internal_set_internalmstime(from._internal_internalmstime());
  }
  if (from._internal_timecode() != 0) {
    _this->_internal_set_timecode(from._internal_timecode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimeData::CopyFrom(const TimeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.TimeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeData::IsInitialized() const {
  return true;
}

void TimeData::InternalSwap(TimeData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeData, _impl_.timecode_)
      + sizeof(TimeData::_impl_.timecode_)
      - PROTOBUF_FIELD_OFFSET(TimeData, _impl_.internalmstime_)>(
          reinterpret_cast<char*>(&_impl_.internalmstime_),
          reinterpret_cast<char*>(&other->_impl_.internalmstime_));
}

std::string TimeData::GetTypeName() const {
  return "handEngine.v1.TimeData";
}

// ===================================================================

class PeripheralState::_Internal {
 public:
  using HasBits = decltype(std::declval<PeripheralState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PeripheralState, _impl_._has_bits_);
  static void set_has_sdcardpresence(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sdcardrecording(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PeripheralState::PeripheralState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.PeripheralState)
}
PeripheralState::PeripheralState(const PeripheralState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.PeripheralState)
}

inline void PeripheralState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.batterylevel_) { 0u }

    , decltype(_impl_.timesincelastjamsync_) { 0u }

    , decltype(_impl_.sdcardpresence_) { false }

    , decltype(_impl_.sdcardrecording_) { false }

  };
}

PeripheralState::~PeripheralState() {
  // @@protoc_insertion_point(destructor:handEngine.v1.PeripheralState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PeripheralState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PeripheralState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PeripheralState::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.PeripheralState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.batterylevel_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.timesincelastjamsync_) -
      reinterpret_cast<char*>(&_impl_.batterylevel_)) + sizeof(_impl_.timesincelastjamsync_));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.sdcardpresence_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sdcardrecording_) -
        reinterpret_cast<char*>(&_impl_.sdcardpresence_)) + sizeof(_impl_.sdcardrecording_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PeripheralState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 batteryLevel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.batterylevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 timeSinceLastJamsync = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.timesincelastjamsync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool sdCardPresence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_sdcardpresence(&has_bits);
          _impl_.sdcardpresence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool sdCardRecording = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_sdcardrecording(&has_bits);
          _impl_.sdcardrecording_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PeripheralState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.PeripheralState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 batteryLevel = 1;
  if (this->_internal_batterylevel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_batterylevel(), target);
  }

  // uint32 timeSinceLastJamsync = 2;
  if (this->_internal_timesincelastjamsync() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_timesincelastjamsync(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool sdCardPresence = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_sdcardpresence(), target);
  }

  // optional bool sdCardRecording = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_sdcardrecording(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.PeripheralState)
  return target;
}

::size_t PeripheralState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.PeripheralState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 batteryLevel = 1;
  if (this->_internal_batterylevel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_batterylevel());
  }

  // uint32 timeSinceLastJamsync = 2;
  if (this->_internal_timesincelastjamsync() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_timesincelastjamsync());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool sdCardPresence = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2;
    }

    // optional bool sdCardRecording = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PeripheralState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PeripheralState*>(
      &from));
}

void PeripheralState::MergeFrom(const PeripheralState& from) {
  PeripheralState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.PeripheralState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_batterylevel() != 0) {
    _this->_internal_set_batterylevel(from._internal_batterylevel());
  }
  if (from._internal_timesincelastjamsync() != 0) {
    _this->_internal_set_timesincelastjamsync(from._internal_timesincelastjamsync());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sdcardpresence_ = from._impl_.sdcardpresence_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sdcardrecording_ = from._impl_.sdcardrecording_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PeripheralState::CopyFrom(const PeripheralState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.PeripheralState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeripheralState::IsInitialized() const {
  return true;
}

void PeripheralState::InternalSwap(PeripheralState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PeripheralState, _impl_.sdcardrecording_)
      + sizeof(PeripheralState::_impl_.sdcardrecording_)
      - PROTOBUF_FIELD_OFFSET(PeripheralState, _impl_.batterylevel_)>(
          reinterpret_cast<char*>(&_impl_.batterylevel_),
          reinterpret_cast<char*>(&other->_impl_.batterylevel_));
}

std::string PeripheralState::GetTypeName() const {
  return "handEngine.v1.PeripheralState";
}

// ===================================================================

class CommandPacket::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPacket>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandPacket, _impl_._has_bits_);
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CommandPacket::CommandPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.CommandPacket)
}
CommandPacket::CommandPacket(const CommandPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CommandPacket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_) {}

    , decltype(_impl_.commanduid_) {}

    , decltype(_impl_.commandcode_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.payload_.Set(from._internal_payload(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.commanduid_, &from._impl_.commanduid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.commandcode_) -
    reinterpret_cast<char*>(&_impl_.commanduid_)) + sizeof(_impl_.commandcode_));
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.CommandPacket)
}

inline void CommandPacket::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_) {}

    , decltype(_impl_.commanduid_) { 0u }

    , decltype(_impl_.commandcode_) { 0 }

  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommandPacket::~CommandPacket() {
  // @@protoc_insertion_point(destructor:handEngine.v1.CommandPacket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandPacket::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.Destroy();
}

void CommandPacket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.CommandPacket)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.payload_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.commanduid_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.commandcode_) -
      reinterpret_cast<char*>(&_impl_.commanduid_)) + sizeof(_impl_.commandcode_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandPacket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 commandUid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.commanduid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.CommandCode commandCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_commandcode(static_cast<::handEngine::v1::CommandCode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string payload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CommandPacket::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.CommandPacket)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 commandUid = 1;
  if (this->_internal_commanduid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_commanduid(), target);
  }

  // .handEngine.v1.CommandCode commandCode = 2;
  if (this->_internal_commandcode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_commandcode(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string payload = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_payload();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.CommandPacket.payload");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.CommandPacket)
  return target;
}

::size_t CommandPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.CommandPacket)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string payload = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payload());
  }

  // uint32 commandUid = 1;
  if (this->_internal_commanduid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_commanduid());
  }

  // .handEngine.v1.CommandCode commandCode = 2;
  if (this->_internal_commandcode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_commandcode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandPacket::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandPacket*>(
      &from));
}

void CommandPacket::MergeFrom(const CommandPacket& from) {
  CommandPacket* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.CommandPacket)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_payload(from._internal_payload());
  }
  if (from._internal_commanduid() != 0) {
    _this->_internal_set_commanduid(from._internal_commanduid());
  }
  if (from._internal_commandcode() != 0) {
    _this->_internal_set_commandcode(from._internal_commandcode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPacket::CopyFrom(const CommandPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.CommandPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPacket::IsInitialized() const {
  return true;
}

void CommandPacket::InternalSwap(CommandPacket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_, lhs_arena,
                                       &other->_impl_.payload_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandPacket, _impl_.commandcode_)
      + sizeof(CommandPacket::_impl_.commandcode_)
      - PROTOBUF_FIELD_OFFSET(CommandPacket, _impl_.commanduid_)>(
          reinterpret_cast<char*>(&_impl_.commanduid_),
          reinterpret_cast<char*>(&other->_impl_.commanduid_));
}

std::string CommandPacket::GetTypeName() const {
  return "handEngine.v1.CommandPacket";
}

// ===================================================================

class DeviceEvent::_Internal {
 public:
};

DeviceEvent::DeviceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.DeviceEvent)
}
DeviceEvent::DeviceEvent(const DeviceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_) {}

    , decltype(_impl_.event_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payload().empty()) {
    _this->_impl_.payload_.Set(from._internal_payload(), _this->GetArenaForAllocation());
  }
  _this->_impl_.event_ = from._impl_.event_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.DeviceEvent)
}

inline void DeviceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_) {}

    , decltype(_impl_.event_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceEvent::~DeviceEvent() {
  // @@protoc_insertion_point(destructor:handEngine.v1.DeviceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.Destroy();
}

void DeviceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.DeviceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payload_.ClearToEmpty();
  _impl_.event_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .handEngine.v1.Event event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_event(static_cast<::handEngine::v1::Event>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeviceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.DeviceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .handEngine.v1.Event event = 1;
  if (this->_internal_event() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_event(), target);
  }

  // string payload = 2;
  if (!this->_internal_payload().empty()) {
    const std::string& _s = this->_internal_payload();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.DeviceEvent.payload");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.DeviceEvent)
  return target;
}

::size_t DeviceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.DeviceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string payload = 2;
  if (!this->_internal_payload().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payload());
  }

  // .handEngine.v1.Event event = 1;
  if (this->_internal_event() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_event());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceEvent*>(
      &from));
}

void DeviceEvent::MergeFrom(const DeviceEvent& from) {
  DeviceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.DeviceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_payload().empty()) {
    _this->_internal_set_payload(from._internal_payload());
  }
  if (from._internal_event() != 0) {
    _this->_internal_set_event(from._internal_event());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceEvent::CopyFrom(const DeviceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.DeviceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceEvent::IsInitialized() const {
  return true;
}

void DeviceEvent::InternalSwap(DeviceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_, lhs_arena,
                                       &other->_impl_.payload_, rhs_arena);
  swap(_impl_.event_, other->_impl_.event_);
}

std::string DeviceEvent::GetTypeName() const {
  return "handEngine.v1.DeviceEvent";
}

// ===================================================================

class DfuData::_Internal {
 public:
  using HasBits = decltype(std::declval<DfuData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DfuData, _impl_._has_bits_);
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DfuData::DfuData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.DfuData)
}
DfuData::DfuData(const DfuData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DfuData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_) {}

    , decltype(_impl_.dfuuid_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.payload_.Set(from._internal_payload(), _this->GetArenaForAllocation());
  }
  _this->_impl_.dfuuid_ = from._impl_.dfuuid_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.DfuData)
}

inline void DfuData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_) {}

    , decltype(_impl_.dfuuid_) { 0u }

  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DfuData::~DfuData() {
  // @@protoc_insertion_point(destructor:handEngine.v1.DfuData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DfuData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.Destroy();
}

void DfuData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DfuData::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.DfuData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.payload_.ClearNonDefaultToEmpty();
  }
  _impl_.dfuuid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DfuData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 dfuUid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.dfuuid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DfuData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.DfuData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 dfuUid = 1;
  if (this->_internal_dfuuid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_dfuuid(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string payload = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_payload();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.DfuData.payload");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.DfuData)
  return target;
}

::size_t DfuData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.DfuData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string payload = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payload());
  }

  // uint32 dfuUid = 1;
  if (this->_internal_dfuuid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_dfuuid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DfuData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DfuData*>(
      &from));
}

void DfuData::MergeFrom(const DfuData& from) {
  DfuData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.DfuData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_payload(from._internal_payload());
  }
  if (from._internal_dfuuid() != 0) {
    _this->_internal_set_dfuuid(from._internal_dfuuid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DfuData::CopyFrom(const DfuData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.DfuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DfuData::IsInitialized() const {
  return true;
}

void DfuData::InternalSwap(DfuData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_, lhs_arena,
                                       &other->_impl_.payload_, rhs_arena);

  swap(_impl_.dfuuid_, other->_impl_.dfuuid_);
}

std::string DfuData::GetTypeName() const {
  return "handEngine.v1.DfuData";
}

// ===================================================================

class DeviceMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DeviceMessage, _impl_._has_bits_);
  static const ::handEngine::v1::DeviceInformation& deviceinformation(const DeviceMessage* msg);
  static void set_has_deviceinformation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::handEngine::v1::StretchSensorData& stretchsensordata(const DeviceMessage* msg);
  static void set_has_stretchsensordata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::handEngine::v1::ImuData& imudata(const DeviceMessage* msg);
  static void set_has_imudata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::handEngine::v1::TimeData& timedata(const DeviceMessage* msg);
  static void set_has_timedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::handEngine::v1::PeripheralState& peripheralstate(const DeviceMessage* msg);
  static void set_has_peripheralstate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::handEngine::v1::CommandPacket& commandresponse(const DeviceMessage* msg);
  static void set_has_commandresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::handEngine::v1::DeviceEvent& deviceevent(const DeviceMessage* msg);
  static void set_has_deviceevent(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::handEngine::v1::DfuData& dfudata(const DeviceMessage* msg);
  static void set_has_dfudata(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::handEngine::v1::DeviceInformation&
DeviceMessage::_Internal::deviceinformation(const DeviceMessage* msg) {
  return *msg->_impl_.deviceinformation_;
}
const ::handEngine::v1::StretchSensorData&
DeviceMessage::_Internal::stretchsensordata(const DeviceMessage* msg) {
  return *msg->_impl_.stretchsensordata_;
}
const ::handEngine::v1::ImuData&
DeviceMessage::_Internal::imudata(const DeviceMessage* msg) {
  return *msg->_impl_.imudata_;
}
const ::handEngine::v1::TimeData&
DeviceMessage::_Internal::timedata(const DeviceMessage* msg) {
  return *msg->_impl_.timedata_;
}
const ::handEngine::v1::PeripheralState&
DeviceMessage::_Internal::peripheralstate(const DeviceMessage* msg) {
  return *msg->_impl_.peripheralstate_;
}
const ::handEngine::v1::CommandPacket&
DeviceMessage::_Internal::commandresponse(const DeviceMessage* msg) {
  return *msg->_impl_.commandresponse_;
}
const ::handEngine::v1::DeviceEvent&
DeviceMessage::_Internal::deviceevent(const DeviceMessage* msg) {
  return *msg->_impl_.deviceevent_;
}
const ::handEngine::v1::DfuData&
DeviceMessage::_Internal::dfudata(const DeviceMessage* msg) {
  return *msg->_impl_.dfudata_;
}
DeviceMessage::DeviceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.DeviceMessage)
}
DeviceMessage::DeviceMessage(const DeviceMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serialnumber_) {}

    , decltype(_impl_.deviceinformation_){nullptr}
    , decltype(_impl_.stretchsensordata_){nullptr}
    , decltype(_impl_.imudata_){nullptr}
    , decltype(_impl_.timedata_){nullptr}
    , decltype(_impl_.peripheralstate_){nullptr}
    , decltype(_impl_.commandresponse_){nullptr}
    , decltype(_impl_.deviceevent_){nullptr}
    , decltype(_impl_.dfudata_){nullptr}
    , decltype(_impl_.packetcounter_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.serialnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.serialnumber_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serialnumber().empty()) {
    _this->_impl_.serialnumber_.Set(from._internal_serialnumber(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.deviceinformation_ = new ::handEngine::v1::DeviceInformation(*from._impl_.deviceinformation_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.stretchsensordata_ = new ::handEngine::v1::StretchSensorData(*from._impl_.stretchsensordata_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.imudata_ = new ::handEngine::v1::ImuData(*from._impl_.imudata_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.timedata_ = new ::handEngine::v1::TimeData(*from._impl_.timedata_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.peripheralstate_ = new ::handEngine::v1::PeripheralState(*from._impl_.peripheralstate_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.commandresponse_ = new ::handEngine::v1::CommandPacket(*from._impl_.commandresponse_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.deviceevent_ = new ::handEngine::v1::DeviceEvent(*from._impl_.deviceevent_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000080u) != 0) {
    _this->_impl_.dfudata_ = new ::handEngine::v1::DfuData(*from._impl_.dfudata_);
  }
  _this->_impl_.packetcounter_ = from._impl_.packetcounter_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.DeviceMessage)
}

inline void DeviceMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serialnumber_) {}

    , decltype(_impl_.deviceinformation_){nullptr}
    , decltype(_impl_.stretchsensordata_){nullptr}
    , decltype(_impl_.imudata_){nullptr}
    , decltype(_impl_.timedata_){nullptr}
    , decltype(_impl_.peripheralstate_){nullptr}
    , decltype(_impl_.commandresponse_){nullptr}
    , decltype(_impl_.deviceevent_){nullptr}
    , decltype(_impl_.dfudata_){nullptr}
    , decltype(_impl_.packetcounter_) { 0u }

  };
  _impl_.serialnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.serialnumber_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceMessage::~DeviceMessage() {
  // @@protoc_insertion_point(destructor:handEngine.v1.DeviceMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serialnumber_.Destroy();
  if (this != internal_default_instance()) delete _impl_.deviceinformation_;
  if (this != internal_default_instance()) delete _impl_.stretchsensordata_;
  if (this != internal_default_instance()) delete _impl_.imudata_;
  if (this != internal_default_instance()) delete _impl_.timedata_;
  if (this != internal_default_instance()) delete _impl_.peripheralstate_;
  if (this != internal_default_instance()) delete _impl_.commandresponse_;
  if (this != internal_default_instance()) delete _impl_.deviceevent_;
  if (this != internal_default_instance()) delete _impl_.dfudata_;
}

void DeviceMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.DeviceMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serialnumber_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.deviceinformation_ != nullptr);
      _impl_.deviceinformation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.stretchsensordata_ != nullptr);
      _impl_.stretchsensordata_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.imudata_ != nullptr);
      _impl_.imudata_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.timedata_ != nullptr);
      _impl_.timedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.peripheralstate_ != nullptr);
      _impl_.peripheralstate_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.commandresponse_ != nullptr);
      _impl_.commandresponse_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.deviceevent_ != nullptr);
      _impl_.deviceevent_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.dfudata_ != nullptr);
      _impl_.dfudata_->Clear();
    }
  }
  _impl_.packetcounter_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string serialNumber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serialnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 packetCounter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.packetcounter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.DeviceInformation deviceInformation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_deviceinformation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.StretchSensorData stretchSensorData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stretchsensordata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.ImuData imuData = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_imudata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.TimeData timeData = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_timedata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.PeripheralState peripheralState = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_peripheralstate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.CommandPacket commandResponse = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_commandresponse(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.DeviceEvent deviceEvent = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_deviceevent(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.DfuData dfuData = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_dfudata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeviceMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.DeviceMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string serialNumber = 1;
  if (!this->_internal_serialnumber().empty()) {
    const std::string& _s = this->_internal_serialnumber();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.DeviceMessage.serialNumber");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 packetCounter = 2;
  if (this->_internal_packetcounter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_packetcounter(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .handEngine.v1.DeviceInformation deviceInformation = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::deviceinformation(this),
        _Internal::deviceinformation(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.StretchSensorData stretchSensorData = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stretchsensordata(this),
        _Internal::stretchsensordata(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.ImuData imuData = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::imudata(this),
        _Internal::imudata(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.TimeData timeData = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::timedata(this),
        _Internal::timedata(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.PeripheralState peripheralState = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::peripheralstate(this),
        _Internal::peripheralstate(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.CommandPacket commandResponse = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::commandresponse(this),
        _Internal::commandresponse(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.DeviceEvent deviceEvent = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::deviceevent(this),
        _Internal::deviceevent(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.DfuData dfuData = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::dfudata(this),
        _Internal::dfudata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.DeviceMessage)
  return target;
}

::size_t DeviceMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.DeviceMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string serialNumber = 1;
  if (!this->_internal_serialnumber().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_serialnumber());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // .handEngine.v1.DeviceInformation deviceInformation = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deviceinformation_);
    }

    // optional .handEngine.v1.StretchSensorData stretchSensorData = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stretchsensordata_);
    }

    // optional .handEngine.v1.ImuData imuData = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.imudata_);
    }

    // optional .handEngine.v1.TimeData timeData = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timedata_);
    }

    // optional .handEngine.v1.PeripheralState peripheralState = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.peripheralstate_);
    }

    // optional .handEngine.v1.CommandPacket commandResponse = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.commandresponse_);
    }

    // optional .handEngine.v1.DeviceEvent deviceEvent = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deviceevent_);
    }

    // optional .handEngine.v1.DfuData dfuData = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dfudata_);
    }

  }
  // uint32 packetCounter = 2;
  if (this->_internal_packetcounter() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_packetcounter());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceMessage*>(
      &from));
}

void DeviceMessage::MergeFrom(const DeviceMessage& from) {
  DeviceMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.DeviceMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_serialnumber().empty()) {
    _this->_internal_set_serialnumber(from._internal_serialnumber());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_deviceinformation()->::handEngine::v1::DeviceInformation::MergeFrom(
          from._internal_deviceinformation());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stretchsensordata()->::handEngine::v1::StretchSensorData::MergeFrom(
          from._internal_stretchsensordata());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_imudata()->::handEngine::v1::ImuData::MergeFrom(
          from._internal_imudata());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_timedata()->::handEngine::v1::TimeData::MergeFrom(
          from._internal_timedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_peripheralstate()->::handEngine::v1::PeripheralState::MergeFrom(
          from._internal_peripheralstate());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_commandresponse()->::handEngine::v1::CommandPacket::MergeFrom(
          from._internal_commandresponse());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_deviceevent()->::handEngine::v1::DeviceEvent::MergeFrom(
          from._internal_deviceevent());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_dfudata()->::handEngine::v1::DfuData::MergeFrom(
          from._internal_dfudata());
    }
  }
  if (from._internal_packetcounter() != 0) {
    _this->_internal_set_packetcounter(from._internal_packetcounter());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceMessage::CopyFrom(const DeviceMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.DeviceMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceMessage::IsInitialized() const {
  return true;
}

void DeviceMessage::InternalSwap(DeviceMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.serialnumber_, lhs_arena,
                                       &other->_impl_.serialnumber_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceMessage, _impl_.packetcounter_)
      + sizeof(DeviceMessage::_impl_.packetcounter_)
      - PROTOBUF_FIELD_OFFSET(DeviceMessage, _impl_.deviceinformation_)>(
          reinterpret_cast<char*>(&_impl_.deviceinformation_),
          reinterpret_cast<char*>(&other->_impl_.deviceinformation_));
}

std::string DeviceMessage::GetTypeName() const {
  return "handEngine.v1.DeviceMessage";
}

// ===================================================================

class AggregateMessage::_Internal {
 public:
};

AggregateMessage::AggregateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.AggregateMessage)
}
AggregateMessage::AggregateMessage(const AggregateMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AggregateMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.devicemessage_){from._impl_.devicemessage_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.AggregateMessage)
}

inline void AggregateMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.devicemessage_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AggregateMessage::~AggregateMessage() {
  // @@protoc_insertion_point(destructor:handEngine.v1.AggregateMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AggregateMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_devicemessage()->~RepeatedPtrField();
}

void AggregateMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AggregateMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.AggregateMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_devicemessage()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AggregateMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .handEngine.v1.DeviceMessage deviceMessage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_devicemessage(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AggregateMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.AggregateMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .handEngine.v1.DeviceMessage deviceMessage = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_devicemessage_size()); i < n; i++) {
    const auto& repfield = this->_internal_devicemessage(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.AggregateMessage)
  return target;
}

::size_t AggregateMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.AggregateMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .handEngine.v1.DeviceMessage deviceMessage = 1;
  total_size += 1UL * this->_internal_devicemessage_size();
  for (const auto& msg : this->_internal_devicemessage()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AggregateMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AggregateMessage*>(
      &from));
}

void AggregateMessage::MergeFrom(const AggregateMessage& from) {
  AggregateMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.AggregateMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_devicemessage()->MergeFrom(from._internal_devicemessage());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AggregateMessage::CopyFrom(const AggregateMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.AggregateMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AggregateMessage::IsInitialized() const {
  return true;
}

void AggregateMessage::InternalSwap(AggregateMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_devicemessage()->InternalSwap(other->_internal_mutable_devicemessage());
}

std::string AggregateMessage::GetTypeName() const {
  return "handEngine.v1.AggregateMessage";
}

// ===================================================================

class DeviceCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceCommand>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DeviceCommand, _impl_._has_bits_);
  static const ::handEngine::v1::CommandPacket& commandpacket(const DeviceCommand* msg);
  static void set_has_commandpacket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::handEngine::v1::DfuData& dfudata(const DeviceCommand* msg);
  static void set_has_dfudata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::handEngine::v1::CommandPacket&
DeviceCommand::_Internal::commandpacket(const DeviceCommand* msg) {
  return *msg->_impl_.commandpacket_;
}
const ::handEngine::v1::DfuData&
DeviceCommand::_Internal::dfudata(const DeviceCommand* msg) {
  return *msg->_impl_.dfudata_;
}
DeviceCommand::DeviceCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.DeviceCommand)
}
DeviceCommand::DeviceCommand(const DeviceCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetdevice_) {}

    , decltype(_impl_.commandpacket_){nullptr}
    , decltype(_impl_.dfudata_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.targetdevice_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.targetdevice_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_targetdevice().empty()) {
    _this->_impl_.targetdevice_.Set(from._internal_targetdevice(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.commandpacket_ = new ::handEngine::v1::CommandPacket(*from._impl_.commandpacket_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.dfudata_ = new ::handEngine::v1::DfuData(*from._impl_.dfudata_);
  }
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.DeviceCommand)
}

inline void DeviceCommand::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetdevice_) {}

    , decltype(_impl_.commandpacket_){nullptr}
    , decltype(_impl_.dfudata_){nullptr}
  };
  _impl_.targetdevice_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.targetdevice_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceCommand::~DeviceCommand() {
  // @@protoc_insertion_point(destructor:handEngine.v1.DeviceCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceCommand::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.targetdevice_.Destroy();
  if (this != internal_default_instance()) delete _impl_.commandpacket_;
  if (this != internal_default_instance()) delete _impl_.dfudata_;
}

void DeviceCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.DeviceCommand)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.targetdevice_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.commandpacket_ != nullptr);
      _impl_.commandpacket_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.dfudata_ != nullptr);
      _impl_.dfudata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string targetDevice = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_targetdevice();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.CommandPacket commandPacket = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_commandpacket(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.DfuData dfuData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dfudata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeviceCommand::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.DeviceCommand)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string targetDevice = 1;
  if (!this->_internal_targetdevice().empty()) {
    const std::string& _s = this->_internal_targetdevice();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.DeviceCommand.targetDevice");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .handEngine.v1.CommandPacket commandPacket = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::commandpacket(this),
        _Internal::commandpacket(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.DfuData dfuData = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dfudata(this),
        _Internal::dfudata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.DeviceCommand)
  return target;
}

::size_t DeviceCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.DeviceCommand)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string targetDevice = 1;
  if (!this->_internal_targetdevice().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_targetdevice());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .handEngine.v1.CommandPacket commandPacket = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.commandpacket_);
    }

    // optional .handEngine.v1.DfuData dfuData = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dfudata_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceCommand*>(
      &from));
}

void DeviceCommand::MergeFrom(const DeviceCommand& from) {
  DeviceCommand* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.DeviceCommand)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_targetdevice().empty()) {
    _this->_internal_set_targetdevice(from._internal_targetdevice());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_commandpacket()->::handEngine::v1::CommandPacket::MergeFrom(
          from._internal_commandpacket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dfudata()->::handEngine::v1::DfuData::MergeFrom(
          from._internal_dfudata());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceCommand::CopyFrom(const DeviceCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.DeviceCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceCommand::IsInitialized() const {
  return true;
}

void DeviceCommand::InternalSwap(DeviceCommand* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.targetdevice_, lhs_arena,
                                       &other->_impl_.targetdevice_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceCommand, _impl_.dfudata_)
      + sizeof(DeviceCommand::_impl_.dfudata_)
      - PROTOBUF_FIELD_OFFSET(DeviceCommand, _impl_.commandpacket_)>(
          reinterpret_cast<char*>(&_impl_.commandpacket_),
          reinterpret_cast<char*>(&other->_impl_.commandpacket_));
}

std::string DeviceCommand::GetTypeName() const {
  return "handEngine.v1.DeviceCommand";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::handEngine::v1::Product*
Arena::CreateMaybeMessage< ::handEngine::v1::Product >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::Product >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::DeviceProperty*
Arena::CreateMaybeMessage< ::handEngine::v1::DeviceProperty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::DeviceProperty >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::FirmwareData*
Arena::CreateMaybeMessage< ::handEngine::v1::FirmwareData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::FirmwareData >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::ManufacturingData*
Arena::CreateMaybeMessage< ::handEngine::v1::ManufacturingData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::ManufacturingData >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::StretchSensorData*
Arena::CreateMaybeMessage< ::handEngine::v1::StretchSensorData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::StretchSensorData >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::DeviceInformation*
Arena::CreateMaybeMessage< ::handEngine::v1::DeviceInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::DeviceInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::ImuData*
Arena::CreateMaybeMessage< ::handEngine::v1::ImuData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::ImuData >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::TimeData*
Arena::CreateMaybeMessage< ::handEngine::v1::TimeData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::TimeData >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::PeripheralState*
Arena::CreateMaybeMessage< ::handEngine::v1::PeripheralState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::PeripheralState >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::CommandPacket*
Arena::CreateMaybeMessage< ::handEngine::v1::CommandPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::CommandPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::DeviceEvent*
Arena::CreateMaybeMessage< ::handEngine::v1::DeviceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::DeviceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::DfuData*
Arena::CreateMaybeMessage< ::handEngine::v1::DfuData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::DfuData >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::DeviceMessage*
Arena::CreateMaybeMessage< ::handEngine::v1::DeviceMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::DeviceMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::AggregateMessage*
Arena::CreateMaybeMessage< ::handEngine::v1::AggregateMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::AggregateMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::DeviceCommand*
Arena::CreateMaybeMessage< ::handEngine::v1::DeviceCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::DeviceCommand >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
