
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/stage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2fstage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_v1_2fstage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "v1/_api.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_v1_2fstage_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2fstage_2eproto {
  static const ::uint32_t offsets[];
};
namespace handEngine {
namespace v1 {
class RecordingDirectoryRequest;
struct RecordingDirectoryRequestDefaultTypeInternal;
extern RecordingDirectoryRequestDefaultTypeInternal _RecordingDirectoryRequest_default_instance_;
class RecordingStateRequest;
struct RecordingStateRequestDefaultTypeInternal;
extern RecordingStateRequestDefaultTypeInternal _RecordingStateRequest_default_instance_;
class StageStateResponse;
struct StageStateResponseDefaultTypeInternal;
extern StageStateResponseDefaultTypeInternal _StageStateResponse_default_instance_;
class TimeCodeRequest;
struct TimeCodeRequestDefaultTypeInternal;
extern TimeCodeRequestDefaultTypeInternal _TimeCodeRequest_default_instance_;
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template <>
::handEngine::v1::RecordingDirectoryRequest* Arena::CreateMaybeMessage<::handEngine::v1::RecordingDirectoryRequest>(Arena*);
template <>
::handEngine::v1::RecordingStateRequest* Arena::CreateMaybeMessage<::handEngine::v1::RecordingStateRequest>(Arena*);
template <>
::handEngine::v1::StageStateResponse* Arena::CreateMaybeMessage<::handEngine::v1::StageStateResponse>(Arena*);
template <>
::handEngine::v1::TimeCodeRequest* Arena::CreateMaybeMessage<::handEngine::v1::TimeCodeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace handEngine {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class StageStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.StageStateResponse) */ {
 public:
  inline StageStateResponse() : StageStateResponse(nullptr) {}
  ~StageStateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StageStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StageStateResponse(const StageStateResponse& from);
  StageStateResponse(StageStateResponse&& from) noexcept
    : StageStateResponse() {
    *this = ::std::move(from);
  }

  inline StageStateResponse& operator=(const StageStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StageStateResponse& operator=(StageStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StageStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StageStateResponse* internal_default_instance() {
    return reinterpret_cast<const StageStateResponse*>(
               &_StageStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StageStateResponse& a, StageStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StageStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StageStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StageStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StageStateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StageStateResponse& from);
  void MergeFrom(const StageStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StageStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.StageStateResponse";
  }
  protected:
  explicit StageStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimecodeFieldNumber = 1,
    kRecordingFieldNumber = 2,
  };
  // .handEngine.v1.TimeCodeRequest timecode = 1;
  bool has_timecode() const;
  void clear_timecode() ;
  const ::handEngine::v1::TimeCodeRequest& timecode() const;
  PROTOBUF_NODISCARD ::handEngine::v1::TimeCodeRequest* release_timecode();
  ::handEngine::v1::TimeCodeRequest* mutable_timecode();
  void set_allocated_timecode(::handEngine::v1::TimeCodeRequest* timecode);
  private:
  const ::handEngine::v1::TimeCodeRequest& _internal_timecode() const;
  ::handEngine::v1::TimeCodeRequest* _internal_mutable_timecode();
  public:
  void unsafe_arena_set_allocated_timecode(
      ::handEngine::v1::TimeCodeRequest* timecode);
  ::handEngine::v1::TimeCodeRequest* unsafe_arena_release_timecode();
  // .handEngine.v1.RecordingStateRequest recording = 2;
  bool has_recording() const;
  void clear_recording() ;
  const ::handEngine::v1::RecordingStateRequest& recording() const;
  PROTOBUF_NODISCARD ::handEngine::v1::RecordingStateRequest* release_recording();
  ::handEngine::v1::RecordingStateRequest* mutable_recording();
  void set_allocated_recording(::handEngine::v1::RecordingStateRequest* recording);
  private:
  const ::handEngine::v1::RecordingStateRequest& _internal_recording() const;
  ::handEngine::v1::RecordingStateRequest* _internal_mutable_recording();
  public:
  void unsafe_arena_set_allocated_recording(
      ::handEngine::v1::RecordingStateRequest* recording);
  ::handEngine::v1::RecordingStateRequest* unsafe_arena_release_recording();
  // @@protoc_insertion_point(class_scope:handEngine.v1.StageStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::handEngine::v1::TimeCodeRequest* timecode_;
    ::handEngine::v1::RecordingStateRequest* recording_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fstage_2eproto;
};// -------------------------------------------------------------------

class RecordingStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.RecordingStateRequest) */ {
 public:
  inline RecordingStateRequest() : RecordingStateRequest(nullptr) {}
  ~RecordingStateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordingStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordingStateRequest(const RecordingStateRequest& from);
  RecordingStateRequest(RecordingStateRequest&& from) noexcept
    : RecordingStateRequest() {
    *this = ::std::move(from);
  }

  inline RecordingStateRequest& operator=(const RecordingStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordingStateRequest& operator=(RecordingStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RecordingStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordingStateRequest* internal_default_instance() {
    return reinterpret_cast<const RecordingStateRequest*>(
               &_RecordingStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RecordingStateRequest& a, RecordingStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordingStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordingStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordingStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordingStateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecordingStateRequest& from);
  void MergeFrom(const RecordingStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecordingStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.RecordingStateRequest";
  }
  protected:
  explicit RecordingStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTakeNameFieldNumber = 2,
    kIsRecordingFieldNumber = 1,
  };
  // string takeName = 2;
  void clear_takename() ;
  const std::string& takename() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_takename(Arg_&& arg, Args_... args);
  std::string* mutable_takename();
  PROTOBUF_NODISCARD std::string* release_takename();
  void set_allocated_takename(std::string* ptr);

  private:
  const std::string& _internal_takename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_takename(
      const std::string& value);
  std::string* _internal_mutable_takename();

  public:
  // bool isRecording = 1;
  void clear_isrecording() ;
  bool isrecording() const;
  void set_isrecording(bool value);

  private:
  bool _internal_isrecording() const;
  void _internal_set_isrecording(bool value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.RecordingStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr takename_;
    bool isrecording_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fstage_2eproto;
};// -------------------------------------------------------------------

class RecordingDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.RecordingDirectoryRequest) */ {
 public:
  inline RecordingDirectoryRequest() : RecordingDirectoryRequest(nullptr) {}
  ~RecordingDirectoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecordingDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordingDirectoryRequest(const RecordingDirectoryRequest& from);
  RecordingDirectoryRequest(RecordingDirectoryRequest&& from) noexcept
    : RecordingDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline RecordingDirectoryRequest& operator=(const RecordingDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordingDirectoryRequest& operator=(RecordingDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RecordingDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordingDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const RecordingDirectoryRequest*>(
               &_RecordingDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RecordingDirectoryRequest& a, RecordingDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordingDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordingDirectoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordingDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordingDirectoryRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecordingDirectoryRequest& from);
  void MergeFrom(const RecordingDirectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecordingDirectoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.RecordingDirectoryRequest";
  }
  protected:
  explicit RecordingDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordingDirectoryFieldNumber = 1,
  };
  // string recordingDirectory = 1;
  void clear_recordingdirectory() ;
  const std::string& recordingdirectory() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recordingdirectory(Arg_&& arg, Args_... args);
  std::string* mutable_recordingdirectory();
  PROTOBUF_NODISCARD std::string* release_recordingdirectory();
  void set_allocated_recordingdirectory(std::string* ptr);

  private:
  const std::string& _internal_recordingdirectory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recordingdirectory(
      const std::string& value);
  std::string* _internal_mutable_recordingdirectory();

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.RecordingDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recordingdirectory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fstage_2eproto;
};// -------------------------------------------------------------------

class TimeCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.TimeCodeRequest) */ {
 public:
  inline TimeCodeRequest() : TimeCodeRequest(nullptr) {}
  ~TimeCodeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeCodeRequest(const TimeCodeRequest& from);
  TimeCodeRequest(TimeCodeRequest&& from) noexcept
    : TimeCodeRequest() {
    *this = ::std::move(from);
  }

  inline TimeCodeRequest& operator=(const TimeCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeCodeRequest& operator=(TimeCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimeCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeCodeRequest* internal_default_instance() {
    return reinterpret_cast<const TimeCodeRequest*>(
               &_TimeCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TimeCodeRequest& a, TimeCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeCodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeCodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeCodeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimeCodeRequest& from);
  void MergeFrom(const TimeCodeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeCodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.TimeCodeRequest";
  }
  protected:
  explicit TimeCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 2,
    kInterfaceAddressFieldNumber = 3,
    kSourceFieldNumber = 1,
    kFramerateFieldNumber = 4,
    kCastFieldNumber = 5,
  };
  // string ipAddress = 2;
  void clear_ipaddress() ;
  const std::string& ipaddress() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ipaddress(Arg_&& arg, Args_... args);
  std::string* mutable_ipaddress();
  PROTOBUF_NODISCARD std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* ptr);

  private:
  const std::string& _internal_ipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddress(
      const std::string& value);
  std::string* _internal_mutable_ipaddress();

  public:
  // string interfaceAddress = 3;
  void clear_interfaceaddress() ;
  const std::string& interfaceaddress() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interfaceaddress(Arg_&& arg, Args_... args);
  std::string* mutable_interfaceaddress();
  PROTOBUF_NODISCARD std::string* release_interfaceaddress();
  void set_allocated_interfaceaddress(std::string* ptr);

  private:
  const std::string& _internal_interfaceaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interfaceaddress(
      const std::string& value);
  std::string* _internal_mutable_interfaceaddress();

  public:
  // .handEngine.v1.TimecodeSource source = 1;
  void clear_source() ;
  ::handEngine::v1::TimecodeSource source() const;
  void set_source(::handEngine::v1::TimecodeSource value);

  private:
  ::handEngine::v1::TimecodeSource _internal_source() const;
  void _internal_set_source(::handEngine::v1::TimecodeSource value);

  public:
  // .handEngine.v1.FrameRate framerate = 4;
  void clear_framerate() ;
  ::handEngine::v1::FrameRate framerate() const;
  void set_framerate(::handEngine::v1::FrameRate value);

  private:
  ::handEngine::v1::FrameRate _internal_framerate() const;
  void _internal_set_framerate(::handEngine::v1::FrameRate value);

  public:
  // .handEngine.v1.Cast cast = 5;
  void clear_cast() ;
  ::handEngine::v1::Cast cast() const;
  void set_cast(::handEngine::v1::Cast value);

  private:
  ::handEngine::v1::Cast _internal_cast() const;
  void _internal_set_cast(::handEngine::v1::Cast value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.TimeCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interfaceaddress_;
    int source_;
    int framerate_;
    int cast_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2fstage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// StageStateResponse

// .handEngine.v1.TimeCodeRequest timecode = 1;
inline bool StageStateResponse::has_timecode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timecode_ != nullptr);
  return value;
}
inline void StageStateResponse::clear_timecode() {
  if (_impl_.timecode_ != nullptr) _impl_.timecode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::handEngine::v1::TimeCodeRequest& StageStateResponse::_internal_timecode() const {
  const ::handEngine::v1::TimeCodeRequest* p = _impl_.timecode_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::TimeCodeRequest&>(
      ::handEngine::v1::_TimeCodeRequest_default_instance_);
}
inline const ::handEngine::v1::TimeCodeRequest& StageStateResponse::timecode() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StageStateResponse.timecode)
  return _internal_timecode();
}
inline void StageStateResponse::unsafe_arena_set_allocated_timecode(
    ::handEngine::v1::TimeCodeRequest* timecode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timecode_);
  }
  _impl_.timecode_ = timecode;
  if (timecode) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.StageStateResponse.timecode)
}
inline ::handEngine::v1::TimeCodeRequest* StageStateResponse::release_timecode() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::TimeCodeRequest* temp = _impl_.timecode_;
  _impl_.timecode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::TimeCodeRequest* StageStateResponse::unsafe_arena_release_timecode() {
  // @@protoc_insertion_point(field_release:handEngine.v1.StageStateResponse.timecode)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::handEngine::v1::TimeCodeRequest* temp = _impl_.timecode_;
  _impl_.timecode_ = nullptr;
  return temp;
}
inline ::handEngine::v1::TimeCodeRequest* StageStateResponse::_internal_mutable_timecode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timecode_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::TimeCodeRequest>(GetArenaForAllocation());
    _impl_.timecode_ = p;
  }
  return _impl_.timecode_;
}
inline ::handEngine::v1::TimeCodeRequest* StageStateResponse::mutable_timecode() {
  ::handEngine::v1::TimeCodeRequest* _msg = _internal_mutable_timecode();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.StageStateResponse.timecode)
  return _msg;
}
inline void StageStateResponse::set_allocated_timecode(::handEngine::v1::TimeCodeRequest* timecode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timecode_;
  }
  if (timecode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timecode);
    if (message_arena != submessage_arena) {
      timecode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timecode, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timecode_ = timecode;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.StageStateResponse.timecode)
}

// .handEngine.v1.RecordingStateRequest recording = 2;
inline bool StageStateResponse::has_recording() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.recording_ != nullptr);
  return value;
}
inline void StageStateResponse::clear_recording() {
  if (_impl_.recording_ != nullptr) _impl_.recording_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::handEngine::v1::RecordingStateRequest& StageStateResponse::_internal_recording() const {
  const ::handEngine::v1::RecordingStateRequest* p = _impl_.recording_;
  return p != nullptr ? *p : reinterpret_cast<const ::handEngine::v1::RecordingStateRequest&>(
      ::handEngine::v1::_RecordingStateRequest_default_instance_);
}
inline const ::handEngine::v1::RecordingStateRequest& StageStateResponse::recording() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.StageStateResponse.recording)
  return _internal_recording();
}
inline void StageStateResponse::unsafe_arena_set_allocated_recording(
    ::handEngine::v1::RecordingStateRequest* recording) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recording_);
  }
  _impl_.recording_ = recording;
  if (recording) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:handEngine.v1.StageStateResponse.recording)
}
inline ::handEngine::v1::RecordingStateRequest* StageStateResponse::release_recording() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::RecordingStateRequest* temp = _impl_.recording_;
  _impl_.recording_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::handEngine::v1::RecordingStateRequest* StageStateResponse::unsafe_arena_release_recording() {
  // @@protoc_insertion_point(field_release:handEngine.v1.StageStateResponse.recording)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::handEngine::v1::RecordingStateRequest* temp = _impl_.recording_;
  _impl_.recording_ = nullptr;
  return temp;
}
inline ::handEngine::v1::RecordingStateRequest* StageStateResponse::_internal_mutable_recording() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.recording_ == nullptr) {
    auto* p = CreateMaybeMessage<::handEngine::v1::RecordingStateRequest>(GetArenaForAllocation());
    _impl_.recording_ = p;
  }
  return _impl_.recording_;
}
inline ::handEngine::v1::RecordingStateRequest* StageStateResponse::mutable_recording() {
  ::handEngine::v1::RecordingStateRequest* _msg = _internal_mutable_recording();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.StageStateResponse.recording)
  return _msg;
}
inline void StageStateResponse::set_allocated_recording(::handEngine::v1::RecordingStateRequest* recording) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recording_;
  }
  if (recording) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recording);
    if (message_arena != submessage_arena) {
      recording = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recording, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.recording_ = recording;
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.StageStateResponse.recording)
}

// -------------------------------------------------------------------

// RecordingStateRequest

// bool isRecording = 1;
inline void RecordingStateRequest::clear_isrecording() {
  _impl_.isrecording_ = false;
}
inline bool RecordingStateRequest::isrecording() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.RecordingStateRequest.isRecording)
  return _internal_isrecording();
}
inline void RecordingStateRequest::set_isrecording(bool value) {
  _internal_set_isrecording(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.RecordingStateRequest.isRecording)
}
inline bool RecordingStateRequest::_internal_isrecording() const {
  return _impl_.isrecording_;
}
inline void RecordingStateRequest::_internal_set_isrecording(bool value) {
  ;
  _impl_.isrecording_ = value;
}

// string takeName = 2;
inline void RecordingStateRequest::clear_takename() {
  _impl_.takename_.ClearToEmpty();
}
inline const std::string& RecordingStateRequest::takename() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.RecordingStateRequest.takeName)
  return _internal_takename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordingStateRequest::set_takename(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.takename_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.RecordingStateRequest.takeName)
}
inline std::string* RecordingStateRequest::mutable_takename() {
  std::string* _s = _internal_mutable_takename();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.RecordingStateRequest.takeName)
  return _s;
}
inline const std::string& RecordingStateRequest::_internal_takename() const {
  return _impl_.takename_.Get();
}
inline void RecordingStateRequest::_internal_set_takename(const std::string& value) {
  ;


  _impl_.takename_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordingStateRequest::_internal_mutable_takename() {
  ;
  return _impl_.takename_.Mutable( GetArenaForAllocation());
}
inline std::string* RecordingStateRequest::release_takename() {
  // @@protoc_insertion_point(field_release:handEngine.v1.RecordingStateRequest.takeName)
  return _impl_.takename_.Release();
}
inline void RecordingStateRequest::set_allocated_takename(std::string* value) {
  _impl_.takename_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.takename_.IsDefault()) {
          _impl_.takename_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.RecordingStateRequest.takeName)
}

// -------------------------------------------------------------------

// RecordingDirectoryRequest

// string recordingDirectory = 1;
inline void RecordingDirectoryRequest::clear_recordingdirectory() {
  _impl_.recordingdirectory_.ClearToEmpty();
}
inline const std::string& RecordingDirectoryRequest::recordingdirectory() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.RecordingDirectoryRequest.recordingDirectory)
  return _internal_recordingdirectory();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecordingDirectoryRequest::set_recordingdirectory(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.recordingdirectory_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.RecordingDirectoryRequest.recordingDirectory)
}
inline std::string* RecordingDirectoryRequest::mutable_recordingdirectory() {
  std::string* _s = _internal_mutable_recordingdirectory();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.RecordingDirectoryRequest.recordingDirectory)
  return _s;
}
inline const std::string& RecordingDirectoryRequest::_internal_recordingdirectory() const {
  return _impl_.recordingdirectory_.Get();
}
inline void RecordingDirectoryRequest::_internal_set_recordingdirectory(const std::string& value) {
  ;


  _impl_.recordingdirectory_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordingDirectoryRequest::_internal_mutable_recordingdirectory() {
  ;
  return _impl_.recordingdirectory_.Mutable( GetArenaForAllocation());
}
inline std::string* RecordingDirectoryRequest::release_recordingdirectory() {
  // @@protoc_insertion_point(field_release:handEngine.v1.RecordingDirectoryRequest.recordingDirectory)
  return _impl_.recordingdirectory_.Release();
}
inline void RecordingDirectoryRequest::set_allocated_recordingdirectory(std::string* value) {
  _impl_.recordingdirectory_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recordingdirectory_.IsDefault()) {
          _impl_.recordingdirectory_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.RecordingDirectoryRequest.recordingDirectory)
}

// -------------------------------------------------------------------

// TimeCodeRequest

// .handEngine.v1.TimecodeSource source = 1;
inline void TimeCodeRequest::clear_source() {
  _impl_.source_ = 0;
}
inline ::handEngine::v1::TimecodeSource TimeCodeRequest::source() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeCodeRequest.source)
  return _internal_source();
}
inline void TimeCodeRequest::set_source(::handEngine::v1::TimecodeSource value) {
   _internal_set_source(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeCodeRequest.source)
}
inline ::handEngine::v1::TimecodeSource TimeCodeRequest::_internal_source() const {
  return static_cast<::handEngine::v1::TimecodeSource>(_impl_.source_);
}
inline void TimeCodeRequest::_internal_set_source(::handEngine::v1::TimecodeSource value) {
  ;
  _impl_.source_ = value;
}

// string ipAddress = 2;
inline void TimeCodeRequest::clear_ipaddress() {
  _impl_.ipaddress_.ClearToEmpty();
}
inline const std::string& TimeCodeRequest::ipaddress() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeCodeRequest.ipAddress)
  return _internal_ipaddress();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TimeCodeRequest::set_ipaddress(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ipaddress_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeCodeRequest.ipAddress)
}
inline std::string* TimeCodeRequest::mutable_ipaddress() {
  std::string* _s = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.TimeCodeRequest.ipAddress)
  return _s;
}
inline const std::string& TimeCodeRequest::_internal_ipaddress() const {
  return _impl_.ipaddress_.Get();
}
inline void TimeCodeRequest::_internal_set_ipaddress(const std::string& value) {
  ;


  _impl_.ipaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* TimeCodeRequest::_internal_mutable_ipaddress() {
  ;
  return _impl_.ipaddress_.Mutable( GetArenaForAllocation());
}
inline std::string* TimeCodeRequest::release_ipaddress() {
  // @@protoc_insertion_point(field_release:handEngine.v1.TimeCodeRequest.ipAddress)
  return _impl_.ipaddress_.Release();
}
inline void TimeCodeRequest::set_allocated_ipaddress(std::string* value) {
  _impl_.ipaddress_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ipaddress_.IsDefault()) {
          _impl_.ipaddress_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.TimeCodeRequest.ipAddress)
}

// string interfaceAddress = 3;
inline void TimeCodeRequest::clear_interfaceaddress() {
  _impl_.interfaceaddress_.ClearToEmpty();
}
inline const std::string& TimeCodeRequest::interfaceaddress() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeCodeRequest.interfaceAddress)
  return _internal_interfaceaddress();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TimeCodeRequest::set_interfaceaddress(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.interfaceaddress_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeCodeRequest.interfaceAddress)
}
inline std::string* TimeCodeRequest::mutable_interfaceaddress() {
  std::string* _s = _internal_mutable_interfaceaddress();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.TimeCodeRequest.interfaceAddress)
  return _s;
}
inline const std::string& TimeCodeRequest::_internal_interfaceaddress() const {
  return _impl_.interfaceaddress_.Get();
}
inline void TimeCodeRequest::_internal_set_interfaceaddress(const std::string& value) {
  ;


  _impl_.interfaceaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* TimeCodeRequest::_internal_mutable_interfaceaddress() {
  ;
  return _impl_.interfaceaddress_.Mutable( GetArenaForAllocation());
}
inline std::string* TimeCodeRequest::release_interfaceaddress() {
  // @@protoc_insertion_point(field_release:handEngine.v1.TimeCodeRequest.interfaceAddress)
  return _impl_.interfaceaddress_.Release();
}
inline void TimeCodeRequest::set_allocated_interfaceaddress(std::string* value) {
  _impl_.interfaceaddress_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interfaceaddress_.IsDefault()) {
          _impl_.interfaceaddress_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.TimeCodeRequest.interfaceAddress)
}

// .handEngine.v1.FrameRate framerate = 4;
inline void TimeCodeRequest::clear_framerate() {
  _impl_.framerate_ = 0;
}
inline ::handEngine::v1::FrameRate TimeCodeRequest::framerate() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeCodeRequest.framerate)
  return _internal_framerate();
}
inline void TimeCodeRequest::set_framerate(::handEngine::v1::FrameRate value) {
   _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeCodeRequest.framerate)
}
inline ::handEngine::v1::FrameRate TimeCodeRequest::_internal_framerate() const {
  return static_cast<::handEngine::v1::FrameRate>(_impl_.framerate_);
}
inline void TimeCodeRequest::_internal_set_framerate(::handEngine::v1::FrameRate value) {
  ;
  _impl_.framerate_ = value;
}

// .handEngine.v1.Cast cast = 5;
inline void TimeCodeRequest::clear_cast() {
  _impl_.cast_ = 0;
}
inline ::handEngine::v1::Cast TimeCodeRequest::cast() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.TimeCodeRequest.cast)
  return _internal_cast();
}
inline void TimeCodeRequest::set_cast(::handEngine::v1::Cast value) {
   _internal_set_cast(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.TimeCodeRequest.cast)
}
inline ::handEngine::v1::Cast TimeCodeRequest::_internal_cast() const {
  return static_cast<::handEngine::v1::Cast>(_impl_.cast_);
}
inline void TimeCodeRequest::_internal_set_cast(::handEngine::v1::Cast value) {
  ;
  _impl_.cast_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_v1_2fstage_2eproto_2epb_2eh

