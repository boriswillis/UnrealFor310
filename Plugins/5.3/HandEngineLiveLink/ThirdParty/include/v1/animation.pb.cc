// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/animation.proto
#include "EnableGrpcIncludes.h"
#include "v1/animation.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
#include "DisableGrpcIncludes.h"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace handEngine {
namespace v1 {
template <typename>
PROTOBUF_CONSTEXPR HandAnimationRequest::HandAnimationRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.profilemeta_)*/nullptr
  , /*decltype(_impl_.settings_)*/nullptr} {}
struct HandAnimationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HandAnimationRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HandAnimationRequestDefaultTypeInternal() {}
  union {
    HandAnimationRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HandAnimationRequestDefaultTypeInternal _HandAnimationRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StageAnimationRequest::StageAnimationRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.profilemeta_)*/{}
  , /*decltype(_impl_.settings_)*/nullptr} {}
struct StageAnimationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StageAnimationRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StageAnimationRequestDefaultTypeInternal() {}
  union {
    StageAnimationRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StageAnimationRequestDefaultTypeInternal _StageAnimationRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamSettings::StreamSettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.includemetacarpal_)*/ false

  , /*decltype(_impl_.coordinatesystem_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamSettingsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamSettingsDefaultTypeInternal() {}
  union {
    StreamSettings _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamSettingsDefaultTypeInternal _StreamSettings_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR HandAnimationResponse::HandAnimationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bones_)*/{}
  , /*decltype(_impl_.performername_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timecode_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.poseinfo_)*/nullptr
  , /*decltype(_impl_.profilemeta_)*/nullptr
  , /*decltype(_impl_.sourceinfo_)*/nullptr
  , /*decltype(_impl_.sliders_)*/nullptr
  , /*decltype(_impl_.performerid_)*/ 0u
} {}
struct HandAnimationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HandAnimationResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HandAnimationResponseDefaultTypeInternal() {}
  union {
    HandAnimationResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HandAnimationResponseDefaultTypeInternal _HandAnimationResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Sliders::Sliders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.thumb_bend_1_)*/ 0

  , /*decltype(_impl_.thumb_bend_2_)*/ 0

  , /*decltype(_impl_.index_bend_1_)*/ 0

  , /*decltype(_impl_.index_bend_2_)*/ 0

  , /*decltype(_impl_.middle_bend_1_)*/ 0

  , /*decltype(_impl_.middle_bend_2_)*/ 0

  , /*decltype(_impl_.thumb_splay_)*/ 0

  , /*decltype(_impl_.ring_bend_1_)*/ 0

  , /*decltype(_impl_.ring_bend_2_)*/ 0

  , /*decltype(_impl_.pinky_bend_1_)*/ 0

  , /*decltype(_impl_.pinky_bend_2_)*/ 0

  , /*decltype(_impl_.global_splay_)*/ 0

  , /*decltype(_impl_.thumb_bend_3_)*/ 0

  , /*decltype(_impl_.index_bend_3_)*/ 0

  , /*decltype(_impl_.middle_bend_3_)*/ 0

  , /*decltype(_impl_.ring_bend_3_)*/ 0

  , /*decltype(_impl_.pinky_bend_3_)*/ 0

  , /*decltype(_impl_.index_splay_)*/ 0

  , /*decltype(_impl_.middle_splay_)*/ 0

  , /*decltype(_impl_.ring_splay_)*/ 0

  , /*decltype(_impl_.pinky_splay_)*/ 0
} {}
struct SlidersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SlidersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SlidersDefaultTypeInternal() {}
  union {
    Sliders _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SlidersDefaultTypeInternal _Sliders_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StageAnimationResponse::StageAnimationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.handanimations_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StageAnimationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StageAnimationResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StageAnimationResponseDefaultTypeInternal() {}
  union {
    StageAnimationResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StageAnimationResponseDefaultTypeInternal _StageAnimationResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR JointResponse::JointResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rotation_)*/ {}

  , /*decltype(_impl_.prerotation_)*/ {}

  , /*decltype(_impl_.postrotation_)*/ {}

  , /*decltype(_impl_.translation_)*/ {}

  , /*decltype(_impl_.scale_)*/ {}

  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.parent_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JointResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JointResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~JointResponseDefaultTypeInternal() {}
  union {
    JointResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JointResponseDefaultTypeInternal _JointResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PoseInformationResponse::PoseInformationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.posename_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.poseid_)*/ 0

  , /*decltype(_impl_.posescore_)*/ 0

  , /*decltype(_impl_.poseactive_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PoseInformationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PoseInformationResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PoseInformationResponseDefaultTypeInternal() {}
  union {
    PoseInformationResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PoseInformationResponseDefaultTypeInternal _PoseInformationResponse_default_instance_;
}  // namespace v1
}  // namespace handEngine
namespace handEngine {
namespace v1 {
bool CoordinateSystem_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    CoordinateSystem_strings[2] = {};

static const char CoordinateSystem_names[] = {
    "GLOBAL"
    "LOCAL"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CoordinateSystem_entries[] =
    {
        {{&CoordinateSystem_names[0], 6}, 1},
        {{&CoordinateSystem_names[6], 5}, 0},
};

static const int CoordinateSystem_entries_by_number[] = {
    1,  // 0 -> LOCAL
    0,  // 1 -> GLOBAL
};

const std::string& CoordinateSystem_Name(CoordinateSystem value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CoordinateSystem_entries, CoordinateSystem_entries_by_number,
          2, CoordinateSystem_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CoordinateSystem_entries, CoordinateSystem_entries_by_number, 2,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : CoordinateSystem_strings[idx].get();
}

bool CoordinateSystem_Parse(absl::string_view name, CoordinateSystem* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CoordinateSystem_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CoordinateSystem>(int_value);
  }
  return success;
}
// ===================================================================

class HandAnimationRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<HandAnimationRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(HandAnimationRequest, _impl_._has_bits_);
  static const ::handEngine::v1::ProfileMeta& profilemeta(const HandAnimationRequest* msg);
  static void set_has_profilemeta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::handEngine::v1::StreamSettings& settings(const HandAnimationRequest* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::handEngine::v1::ProfileMeta&
HandAnimationRequest::_Internal::profilemeta(const HandAnimationRequest* msg) {
  return *msg->_impl_.profilemeta_;
}
const ::handEngine::v1::StreamSettings&
HandAnimationRequest::_Internal::settings(const HandAnimationRequest* msg) {
  return *msg->_impl_.settings_;
}
void HandAnimationRequest::clear_profilemeta() {
  if (_impl_.profilemeta_ != nullptr) _impl_.profilemeta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
HandAnimationRequest::HandAnimationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.HandAnimationRequest)
}
HandAnimationRequest::HandAnimationRequest(const HandAnimationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HandAnimationRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profilemeta_){nullptr}
    , decltype(_impl_.settings_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.profilemeta_ = new ::handEngine::v1::ProfileMeta(*from._impl_.profilemeta_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.settings_ = new ::handEngine::v1::StreamSettings(*from._impl_.settings_);
  }
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.HandAnimationRequest)
}

inline void HandAnimationRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profilemeta_){nullptr}
    , decltype(_impl_.settings_){nullptr}
  };
}

HandAnimationRequest::~HandAnimationRequest() {
  // @@protoc_insertion_point(destructor:handEngine.v1.HandAnimationRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HandAnimationRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.profilemeta_;
  if (this != internal_default_instance()) delete _impl_.settings_;
}

void HandAnimationRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HandAnimationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.HandAnimationRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.profilemeta_ != nullptr);
      _impl_.profilemeta_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.settings_ != nullptr);
      _impl_.settings_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HandAnimationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .handEngine.v1.ProfileMeta profileMeta = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_profilemeta(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.StreamSettings settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HandAnimationRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.HandAnimationRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .handEngine.v1.ProfileMeta profileMeta = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::profilemeta(this),
        _Internal::profilemeta(this).GetCachedSize(), target, stream);
  }

  // .handEngine.v1.StreamSettings settings = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::settings(this),
        _Internal::settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.HandAnimationRequest)
  return target;
}

::size_t HandAnimationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.HandAnimationRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .handEngine.v1.ProfileMeta profileMeta = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.profilemeta_);
    }

    // .handEngine.v1.StreamSettings settings = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.settings_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HandAnimationRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HandAnimationRequest*>(
      &from));
}

void HandAnimationRequest::MergeFrom(const HandAnimationRequest& from) {
  HandAnimationRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.HandAnimationRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_profilemeta()->::handEngine::v1::ProfileMeta::MergeFrom(
          from._internal_profilemeta());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_settings()->::handEngine::v1::StreamSettings::MergeFrom(
          from._internal_settings());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HandAnimationRequest::CopyFrom(const HandAnimationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.HandAnimationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandAnimationRequest::IsInitialized() const {
  return true;
}

void HandAnimationRequest::InternalSwap(HandAnimationRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HandAnimationRequest, _impl_.settings_)
      + sizeof(HandAnimationRequest::_impl_.settings_)
      - PROTOBUF_FIELD_OFFSET(HandAnimationRequest, _impl_.profilemeta_)>(
          reinterpret_cast<char*>(&_impl_.profilemeta_),
          reinterpret_cast<char*>(&other->_impl_.profilemeta_));
}

std::string HandAnimationRequest::GetTypeName() const {
  return "handEngine.v1.HandAnimationRequest";
}

// ===================================================================

class StageAnimationRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<StageAnimationRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StageAnimationRequest, _impl_._has_bits_);
  static const ::handEngine::v1::StreamSettings& settings(const StageAnimationRequest* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::handEngine::v1::StreamSettings&
StageAnimationRequest::_Internal::settings(const StageAnimationRequest* msg) {
  return *msg->_impl_.settings_;
}
void StageAnimationRequest::clear_profilemeta() {
  _internal_mutable_profilemeta()->Clear();
}
StageAnimationRequest::StageAnimationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.StageAnimationRequest)
}
StageAnimationRequest::StageAnimationRequest(const StageAnimationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  StageAnimationRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profilemeta_){from._impl_.profilemeta_}
    , decltype(_impl_.settings_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.settings_ = new ::handEngine::v1::StreamSettings(*from._impl_.settings_);
  }
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.StageAnimationRequest)
}

inline void StageAnimationRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profilemeta_){arena}
    , decltype(_impl_.settings_){nullptr}
  };
}

StageAnimationRequest::~StageAnimationRequest() {
  // @@protoc_insertion_point(destructor:handEngine.v1.StageAnimationRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StageAnimationRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_profilemeta()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.settings_;
}

void StageAnimationRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StageAnimationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.StageAnimationRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_profilemeta()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.settings_ != nullptr);
    _impl_.settings_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StageAnimationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .handEngine.v1.ProfileMeta profileMeta = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_profilemeta(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.StreamSettings settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StageAnimationRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.StageAnimationRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .handEngine.v1.ProfileMeta profileMeta = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_profilemeta_size()); i < n; i++) {
    const auto& repfield = this->_internal_profilemeta(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .handEngine.v1.StreamSettings settings = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::settings(this),
        _Internal::settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.StageAnimationRequest)
  return target;
}

::size_t StageAnimationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.StageAnimationRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .handEngine.v1.ProfileMeta profileMeta = 1;
  total_size += 1UL * this->_internal_profilemeta_size();
  for (const auto& msg : this->_internal_profilemeta()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .handEngine.v1.StreamSettings settings = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.settings_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StageAnimationRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StageAnimationRequest*>(
      &from));
}

void StageAnimationRequest::MergeFrom(const StageAnimationRequest& from) {
  StageAnimationRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.StageAnimationRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_profilemeta()->MergeFrom(from._internal_profilemeta());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_settings()->::handEngine::v1::StreamSettings::MergeFrom(
        from._internal_settings());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StageAnimationRequest::CopyFrom(const StageAnimationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.StageAnimationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StageAnimationRequest::IsInitialized() const {
  return true;
}

void StageAnimationRequest::InternalSwap(StageAnimationRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_profilemeta()->InternalSwap(other->_internal_mutable_profilemeta());
  swap(_impl_.settings_, other->_impl_.settings_);
}

std::string StageAnimationRequest::GetTypeName() const {
  return "handEngine.v1.StageAnimationRequest";
}

// ===================================================================

class StreamSettings::_Internal {
 public:
};

StreamSettings::StreamSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.StreamSettings)
}
StreamSettings::StreamSettings(const StreamSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.StreamSettings)
}

inline void StreamSettings::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.includemetacarpal_) { false }

    , decltype(_impl_.coordinatesystem_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamSettings::~StreamSettings() {
  // @@protoc_insertion_point(destructor:handEngine.v1.StreamSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamSettings::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void StreamSettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.StreamSettings)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.includemetacarpal_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.coordinatesystem_) -
      reinterpret_cast<char*>(&_impl_.includemetacarpal_)) + sizeof(_impl_.coordinatesystem_));
  _internal_metadata_.Clear<std::string>();
}

const char* StreamSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool includeMetaCarpal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.includemetacarpal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.CoordinateSystem coordinateSystem = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_coordinatesystem(static_cast<::handEngine::v1::CoordinateSystem>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamSettings::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.StreamSettings)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool includeMetaCarpal = 1;
  if (this->_internal_includemetacarpal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_includemetacarpal(), target);
  }

  // .handEngine.v1.CoordinateSystem coordinateSystem = 2;
  if (this->_internal_coordinatesystem() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_coordinatesystem(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.StreamSettings)
  return target;
}

::size_t StreamSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.StreamSettings)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool includeMetaCarpal = 1;
  if (this->_internal_includemetacarpal() != 0) {
    total_size += 2;
  }

  // .handEngine.v1.CoordinateSystem coordinateSystem = 2;
  if (this->_internal_coordinatesystem() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_coordinatesystem());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StreamSettings*>(
      &from));
}

void StreamSettings::MergeFrom(const StreamSettings& from) {
  StreamSettings* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.StreamSettings)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_includemetacarpal() != 0) {
    _this->_internal_set_includemetacarpal(from._internal_includemetacarpal());
  }
  if (from._internal_coordinatesystem() != 0) {
    _this->_internal_set_coordinatesystem(from._internal_coordinatesystem());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamSettings::CopyFrom(const StreamSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.StreamSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamSettings::IsInitialized() const {
  return true;
}

void StreamSettings::InternalSwap(StreamSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamSettings, _impl_.coordinatesystem_)
      + sizeof(StreamSettings::_impl_.coordinatesystem_)
      - PROTOBUF_FIELD_OFFSET(StreamSettings, _impl_.includemetacarpal_)>(
          reinterpret_cast<char*>(&_impl_.includemetacarpal_),
          reinterpret_cast<char*>(&other->_impl_.includemetacarpal_));
}

std::string StreamSettings::GetTypeName() const {
  return "handEngine.v1.StreamSettings";
}

// ===================================================================

class HandAnimationResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<HandAnimationResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(HandAnimationResponse, _impl_._has_bits_);
  static const ::handEngine::v1::PoseInformationResponse& poseinfo(const HandAnimationResponse* msg);
  static void set_has_poseinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::handEngine::v1::ProfileMeta& profilemeta(const HandAnimationResponse* msg);
  static void set_has_profilemeta(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::handEngine::v1::GloveInformationResponse& sourceinfo(const HandAnimationResponse* msg);
  static void set_has_sourceinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::handEngine::v1::Sliders& sliders(const HandAnimationResponse* msg);
  static void set_has_sliders(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::handEngine::v1::PoseInformationResponse&
HandAnimationResponse::_Internal::poseinfo(const HandAnimationResponse* msg) {
  return *msg->_impl_.poseinfo_;
}
const ::handEngine::v1::ProfileMeta&
HandAnimationResponse::_Internal::profilemeta(const HandAnimationResponse* msg) {
  return *msg->_impl_.profilemeta_;
}
const ::handEngine::v1::GloveInformationResponse&
HandAnimationResponse::_Internal::sourceinfo(const HandAnimationResponse* msg) {
  return *msg->_impl_.sourceinfo_;
}
const ::handEngine::v1::Sliders&
HandAnimationResponse::_Internal::sliders(const HandAnimationResponse* msg) {
  return *msg->_impl_.sliders_;
}
void HandAnimationResponse::clear_profilemeta() {
  if (_impl_.profilemeta_ != nullptr) _impl_.profilemeta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void HandAnimationResponse::clear_sourceinfo() {
  if (_impl_.sourceinfo_ != nullptr) _impl_.sourceinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
HandAnimationResponse::HandAnimationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.HandAnimationResponse)
}
HandAnimationResponse::HandAnimationResponse(const HandAnimationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HandAnimationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bones_){from._impl_.bones_}
    , decltype(_impl_.performername_) {}

    , decltype(_impl_.timecode_) {}

    , decltype(_impl_.poseinfo_){nullptr}
    , decltype(_impl_.profilemeta_){nullptr}
    , decltype(_impl_.sourceinfo_){nullptr}
    , decltype(_impl_.sliders_){nullptr}
    , decltype(_impl_.performerid_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.performername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.performername_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_performername().empty()) {
    _this->_impl_.performername_.Set(from._internal_performername(), _this->GetArenaForAllocation());
  }
  _impl_.timecode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.timecode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_timecode().empty()) {
    _this->_impl_.timecode_.Set(from._internal_timecode(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.poseinfo_ = new ::handEngine::v1::PoseInformationResponse(*from._impl_.poseinfo_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.profilemeta_ = new ::handEngine::v1::ProfileMeta(*from._impl_.profilemeta_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.sourceinfo_ = new ::handEngine::v1::GloveInformationResponse(*from._impl_.sourceinfo_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.sliders_ = new ::handEngine::v1::Sliders(*from._impl_.sliders_);
  }
  _this->_impl_.performerid_ = from._impl_.performerid_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.HandAnimationResponse)
}

inline void HandAnimationResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bones_){arena}
    , decltype(_impl_.performername_) {}

    , decltype(_impl_.timecode_) {}

    , decltype(_impl_.poseinfo_){nullptr}
    , decltype(_impl_.profilemeta_){nullptr}
    , decltype(_impl_.sourceinfo_){nullptr}
    , decltype(_impl_.sliders_){nullptr}
    , decltype(_impl_.performerid_) { 0u }

  };
  _impl_.performername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.performername_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timecode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.timecode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HandAnimationResponse::~HandAnimationResponse() {
  // @@protoc_insertion_point(destructor:handEngine.v1.HandAnimationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HandAnimationResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_bones()->~RepeatedPtrField();
  _impl_.performername_.Destroy();
  _impl_.timecode_.Destroy();
  if (this != internal_default_instance()) delete _impl_.poseinfo_;
  if (this != internal_default_instance()) delete _impl_.profilemeta_;
  if (this != internal_default_instance()) delete _impl_.sourceinfo_;
  if (this != internal_default_instance()) delete _impl_.sliders_;
}

void HandAnimationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HandAnimationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.HandAnimationResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_bones()->Clear();
  _impl_.performername_.ClearToEmpty();
  _impl_.timecode_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.poseinfo_ != nullptr);
      _impl_.poseinfo_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.profilemeta_ != nullptr);
      _impl_.profilemeta_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.sourceinfo_ != nullptr);
      _impl_.sourceinfo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.sliders_ != nullptr);
      _impl_.sliders_->Clear();
    }
  }
  _impl_.performerid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HandAnimationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string performerName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_performername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 performerId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.performerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .handEngine.v1.JointResponse bones = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bones(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.PoseInformationResponse poseInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_poseinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string timecode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_timecode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.ProfileMeta profileMeta = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_profilemeta(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.GloveInformationResponse sourceInfo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sourceinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .handEngine.v1.Sliders sliders = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sliders(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HandAnimationResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.HandAnimationResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string performerName = 1;
  if (!this->_internal_performername().empty()) {
    const std::string& _s = this->_internal_performername();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.HandAnimationResponse.performerName");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 performerId = 2;
  if (this->_internal_performerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_performerid(), target);
  }

  // repeated .handEngine.v1.JointResponse bones = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bones_size()); i < n; i++) {
    const auto& repfield = this->_internal_bones(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .handEngine.v1.PoseInformationResponse poseInfo = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::poseinfo(this),
        _Internal::poseinfo(this).GetCachedSize(), target, stream);
  }

  // string timecode = 5;
  if (!this->_internal_timecode().empty()) {
    const std::string& _s = this->_internal_timecode();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.HandAnimationResponse.timecode");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // .handEngine.v1.ProfileMeta profileMeta = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::profilemeta(this),
        _Internal::profilemeta(this).GetCachedSize(), target, stream);
  }

  // .handEngine.v1.GloveInformationResponse sourceInfo = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::sourceinfo(this),
        _Internal::sourceinfo(this).GetCachedSize(), target, stream);
  }

  // optional .handEngine.v1.Sliders sliders = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::sliders(this),
        _Internal::sliders(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.HandAnimationResponse)
  return target;
}

::size_t HandAnimationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.HandAnimationResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .handEngine.v1.JointResponse bones = 3;
  total_size += 1UL * this->_internal_bones_size();
  for (const auto& msg : this->_internal_bones()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string performerName = 1;
  if (!this->_internal_performername().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_performername());
  }

  // string timecode = 5;
  if (!this->_internal_timecode().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_timecode());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // .handEngine.v1.PoseInformationResponse poseInfo = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.poseinfo_);
    }

    // .handEngine.v1.ProfileMeta profileMeta = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.profilemeta_);
    }

    // .handEngine.v1.GloveInformationResponse sourceInfo = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sourceinfo_);
    }

    // optional .handEngine.v1.Sliders sliders = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sliders_);
    }

  }
  // uint32 performerId = 2;
  if (this->_internal_performerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_performerid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HandAnimationResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HandAnimationResponse*>(
      &from));
}

void HandAnimationResponse::MergeFrom(const HandAnimationResponse& from) {
  HandAnimationResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.HandAnimationResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_bones()->MergeFrom(from._internal_bones());
  if (!from._internal_performername().empty()) {
    _this->_internal_set_performername(from._internal_performername());
  }
  if (!from._internal_timecode().empty()) {
    _this->_internal_set_timecode(from._internal_timecode());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_poseinfo()->::handEngine::v1::PoseInformationResponse::MergeFrom(
          from._internal_poseinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_profilemeta()->::handEngine::v1::ProfileMeta::MergeFrom(
          from._internal_profilemeta());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_sourceinfo()->::handEngine::v1::GloveInformationResponse::MergeFrom(
          from._internal_sourceinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_sliders()->::handEngine::v1::Sliders::MergeFrom(
          from._internal_sliders());
    }
  }
  if (from._internal_performerid() != 0) {
    _this->_internal_set_performerid(from._internal_performerid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HandAnimationResponse::CopyFrom(const HandAnimationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.HandAnimationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandAnimationResponse::IsInitialized() const {
  return true;
}

void HandAnimationResponse::InternalSwap(HandAnimationResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_bones()->InternalSwap(other->_internal_mutable_bones());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.performername_, lhs_arena,
                                       &other->_impl_.performername_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timecode_, lhs_arena,
                                       &other->_impl_.timecode_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HandAnimationResponse, _impl_.performerid_)
      + sizeof(HandAnimationResponse::_impl_.performerid_)
      - PROTOBUF_FIELD_OFFSET(HandAnimationResponse, _impl_.poseinfo_)>(
          reinterpret_cast<char*>(&_impl_.poseinfo_),
          reinterpret_cast<char*>(&other->_impl_.poseinfo_));
}

std::string HandAnimationResponse::GetTypeName() const {
  return "handEngine.v1.HandAnimationResponse";
}

// ===================================================================

class Sliders::_Internal {
 public:
  using HasBits = decltype(std::declval<Sliders>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Sliders, _impl_._has_bits_);
  static void set_has_thumb_bend_3(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index_bend_3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_middle_bend_3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ring_bend_3(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_pinky_bend_3(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_global_splay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_index_splay(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_middle_splay(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ring_splay(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pinky_splay(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Sliders::Sliders(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.Sliders)
}
Sliders::Sliders(const Sliders& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.Sliders)
}

inline void Sliders::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.thumb_bend_1_) { 0 }

    , decltype(_impl_.thumb_bend_2_) { 0 }

    , decltype(_impl_.index_bend_1_) { 0 }

    , decltype(_impl_.index_bend_2_) { 0 }

    , decltype(_impl_.middle_bend_1_) { 0 }

    , decltype(_impl_.middle_bend_2_) { 0 }

    , decltype(_impl_.thumb_splay_) { 0 }

    , decltype(_impl_.ring_bend_1_) { 0 }

    , decltype(_impl_.ring_bend_2_) { 0 }

    , decltype(_impl_.pinky_bend_1_) { 0 }

    , decltype(_impl_.pinky_bend_2_) { 0 }

    , decltype(_impl_.global_splay_) { 0 }

    , decltype(_impl_.thumb_bend_3_) { 0 }

    , decltype(_impl_.index_bend_3_) { 0 }

    , decltype(_impl_.middle_bend_3_) { 0 }

    , decltype(_impl_.ring_bend_3_) { 0 }

    , decltype(_impl_.pinky_bend_3_) { 0 }

    , decltype(_impl_.index_splay_) { 0 }

    , decltype(_impl_.middle_splay_) { 0 }

    , decltype(_impl_.ring_splay_) { 0 }

    , decltype(_impl_.pinky_splay_) { 0 }

  };
}

Sliders::~Sliders() {
  // @@protoc_insertion_point(destructor:handEngine.v1.Sliders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Sliders::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Sliders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Sliders::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.Sliders)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.thumb_bend_1_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.pinky_bend_2_) -
      reinterpret_cast<char*>(&_impl_.thumb_bend_1_)) + sizeof(_impl_.pinky_bend_2_));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.global_splay_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.middle_splay_) -
        reinterpret_cast<char*>(&_impl_.global_splay_)) + sizeof(_impl_.middle_splay_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.ring_splay_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pinky_splay_) -
        reinterpret_cast<char*>(&_impl_.ring_splay_)) + sizeof(_impl_.pinky_splay_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Sliders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float THUMB_BEND_1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.thumb_bend_1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float THUMB_BEND_2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.thumb_bend_2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float INDEX_BEND_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.index_bend_1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float INDEX_BEND_2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.index_bend_2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float MIDDLE_BEND_1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.middle_bend_1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float MIDDLE_BEND_2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.middle_bend_2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float THUMB_SPLAY = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.thumb_splay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float RING_BEND_1 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.ring_bend_1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float RING_BEND_2 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 77)) {
          _impl_.ring_bend_2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float PINKY_BEND_1 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 85)) {
          _impl_.pinky_bend_1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float PINKY_BEND_2 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 93)) {
          _impl_.pinky_bend_2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float GLOBAL_SPLAY = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 101)) {
          _Internal::set_has_global_splay(&has_bits);
          _impl_.global_splay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float THUMB_BEND_3 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 109)) {
          _Internal::set_has_thumb_bend_3(&has_bits);
          _impl_.thumb_bend_3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float INDEX_BEND_3 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 117)) {
          _Internal::set_has_index_bend_3(&has_bits);
          _impl_.index_bend_3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float MIDDLE_BEND_3 = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 125)) {
          _Internal::set_has_middle_bend_3(&has_bits);
          _impl_.middle_bend_3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float RING_BEND_3 = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 133)) {
          _Internal::set_has_ring_bend_3(&has_bits);
          _impl_.ring_bend_3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float PINKY_BEND_3 = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 141)) {
          _Internal::set_has_pinky_bend_3(&has_bits);
          _impl_.pinky_bend_3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float INDEX_SPLAY = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 149)) {
          _Internal::set_has_index_splay(&has_bits);
          _impl_.index_splay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float MIDDLE_SPLAY = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 157)) {
          _Internal::set_has_middle_splay(&has_bits);
          _impl_.middle_splay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float RING_SPLAY = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 165)) {
          _Internal::set_has_ring_splay(&has_bits);
          _impl_.ring_splay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float PINKY_SPLAY = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 173)) {
          _Internal::set_has_pinky_splay(&has_bits);
          _impl_.pinky_splay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Sliders::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.Sliders)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float THUMB_BEND_1 = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_bend_1 = this->_internal_thumb_bend_1();
  ::uint32_t raw_thumb_bend_1;
  memcpy(&raw_thumb_bend_1, &tmp_thumb_bend_1, sizeof(tmp_thumb_bend_1));
  if (raw_thumb_bend_1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_thumb_bend_1(), target);
  }

  // float THUMB_BEND_2 = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_bend_2 = this->_internal_thumb_bend_2();
  ::uint32_t raw_thumb_bend_2;
  memcpy(&raw_thumb_bend_2, &tmp_thumb_bend_2, sizeof(tmp_thumb_bend_2));
  if (raw_thumb_bend_2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_thumb_bend_2(), target);
  }

  // float INDEX_BEND_1 = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_index_bend_1 = this->_internal_index_bend_1();
  ::uint32_t raw_index_bend_1;
  memcpy(&raw_index_bend_1, &tmp_index_bend_1, sizeof(tmp_index_bend_1));
  if (raw_index_bend_1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_index_bend_1(), target);
  }

  // float INDEX_BEND_2 = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_index_bend_2 = this->_internal_index_bend_2();
  ::uint32_t raw_index_bend_2;
  memcpy(&raw_index_bend_2, &tmp_index_bend_2, sizeof(tmp_index_bend_2));
  if (raw_index_bend_2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_index_bend_2(), target);
  }

  // float MIDDLE_BEND_1 = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_middle_bend_1 = this->_internal_middle_bend_1();
  ::uint32_t raw_middle_bend_1;
  memcpy(&raw_middle_bend_1, &tmp_middle_bend_1, sizeof(tmp_middle_bend_1));
  if (raw_middle_bend_1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_middle_bend_1(), target);
  }

  // float MIDDLE_BEND_2 = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_middle_bend_2 = this->_internal_middle_bend_2();
  ::uint32_t raw_middle_bend_2;
  memcpy(&raw_middle_bend_2, &tmp_middle_bend_2, sizeof(tmp_middle_bend_2));
  if (raw_middle_bend_2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_middle_bend_2(), target);
  }

  // float THUMB_SPLAY = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_splay = this->_internal_thumb_splay();
  ::uint32_t raw_thumb_splay;
  memcpy(&raw_thumb_splay, &tmp_thumb_splay, sizeof(tmp_thumb_splay));
  if (raw_thumb_splay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_thumb_splay(), target);
  }

  // float RING_BEND_1 = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ring_bend_1 = this->_internal_ring_bend_1();
  ::uint32_t raw_ring_bend_1;
  memcpy(&raw_ring_bend_1, &tmp_ring_bend_1, sizeof(tmp_ring_bend_1));
  if (raw_ring_bend_1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_ring_bend_1(), target);
  }

  // float RING_BEND_2 = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ring_bend_2 = this->_internal_ring_bend_2();
  ::uint32_t raw_ring_bend_2;
  memcpy(&raw_ring_bend_2, &tmp_ring_bend_2, sizeof(tmp_ring_bend_2));
  if (raw_ring_bend_2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_ring_bend_2(), target);
  }

  // float PINKY_BEND_1 = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pinky_bend_1 = this->_internal_pinky_bend_1();
  ::uint32_t raw_pinky_bend_1;
  memcpy(&raw_pinky_bend_1, &tmp_pinky_bend_1, sizeof(tmp_pinky_bend_1));
  if (raw_pinky_bend_1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_pinky_bend_1(), target);
  }

  // float PINKY_BEND_2 = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pinky_bend_2 = this->_internal_pinky_bend_2();
  ::uint32_t raw_pinky_bend_2;
  memcpy(&raw_pinky_bend_2, &tmp_pinky_bend_2, sizeof(tmp_pinky_bend_2));
  if (raw_pinky_bend_2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_pinky_bend_2(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional float GLOBAL_SPLAY = 12;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_global_splay(), target);
  }

  // optional float THUMB_BEND_3 = 13;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_thumb_bend_3(), target);
  }

  // optional float INDEX_BEND_3 = 14;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_index_bend_3(), target);
  }

  // optional float MIDDLE_BEND_3 = 15;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_middle_bend_3(), target);
  }

  // optional float RING_BEND_3 = 16;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_ring_bend_3(), target);
  }

  // optional float PINKY_BEND_3 = 17;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        17, this->_internal_pinky_bend_3(), target);
  }

  // optional float INDEX_SPLAY = 18;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        18, this->_internal_index_splay(), target);
  }

  // optional float MIDDLE_SPLAY = 19;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        19, this->_internal_middle_splay(), target);
  }

  // optional float RING_SPLAY = 20;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        20, this->_internal_ring_splay(), target);
  }

  // optional float PINKY_SPLAY = 21;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        21, this->_internal_pinky_splay(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.Sliders)
  return target;
}

::size_t Sliders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.Sliders)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float THUMB_BEND_1 = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_bend_1 = this->_internal_thumb_bend_1();
  ::uint32_t raw_thumb_bend_1;
  memcpy(&raw_thumb_bend_1, &tmp_thumb_bend_1, sizeof(tmp_thumb_bend_1));
  if (raw_thumb_bend_1 != 0) {
    total_size += 5;
  }

  // float THUMB_BEND_2 = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_bend_2 = this->_internal_thumb_bend_2();
  ::uint32_t raw_thumb_bend_2;
  memcpy(&raw_thumb_bend_2, &tmp_thumb_bend_2, sizeof(tmp_thumb_bend_2));
  if (raw_thumb_bend_2 != 0) {
    total_size += 5;
  }

  // float INDEX_BEND_1 = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_index_bend_1 = this->_internal_index_bend_1();
  ::uint32_t raw_index_bend_1;
  memcpy(&raw_index_bend_1, &tmp_index_bend_1, sizeof(tmp_index_bend_1));
  if (raw_index_bend_1 != 0) {
    total_size += 5;
  }

  // float INDEX_BEND_2 = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_index_bend_2 = this->_internal_index_bend_2();
  ::uint32_t raw_index_bend_2;
  memcpy(&raw_index_bend_2, &tmp_index_bend_2, sizeof(tmp_index_bend_2));
  if (raw_index_bend_2 != 0) {
    total_size += 5;
  }

  // float MIDDLE_BEND_1 = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_middle_bend_1 = this->_internal_middle_bend_1();
  ::uint32_t raw_middle_bend_1;
  memcpy(&raw_middle_bend_1, &tmp_middle_bend_1, sizeof(tmp_middle_bend_1));
  if (raw_middle_bend_1 != 0) {
    total_size += 5;
  }

  // float MIDDLE_BEND_2 = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_middle_bend_2 = this->_internal_middle_bend_2();
  ::uint32_t raw_middle_bend_2;
  memcpy(&raw_middle_bend_2, &tmp_middle_bend_2, sizeof(tmp_middle_bend_2));
  if (raw_middle_bend_2 != 0) {
    total_size += 5;
  }

  // float THUMB_SPLAY = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_splay = this->_internal_thumb_splay();
  ::uint32_t raw_thumb_splay;
  memcpy(&raw_thumb_splay, &tmp_thumb_splay, sizeof(tmp_thumb_splay));
  if (raw_thumb_splay != 0) {
    total_size += 5;
  }

  // float RING_BEND_1 = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ring_bend_1 = this->_internal_ring_bend_1();
  ::uint32_t raw_ring_bend_1;
  memcpy(&raw_ring_bend_1, &tmp_ring_bend_1, sizeof(tmp_ring_bend_1));
  if (raw_ring_bend_1 != 0) {
    total_size += 5;
  }

  // float RING_BEND_2 = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ring_bend_2 = this->_internal_ring_bend_2();
  ::uint32_t raw_ring_bend_2;
  memcpy(&raw_ring_bend_2, &tmp_ring_bend_2, sizeof(tmp_ring_bend_2));
  if (raw_ring_bend_2 != 0) {
    total_size += 5;
  }

  // float PINKY_BEND_1 = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pinky_bend_1 = this->_internal_pinky_bend_1();
  ::uint32_t raw_pinky_bend_1;
  memcpy(&raw_pinky_bend_1, &tmp_pinky_bend_1, sizeof(tmp_pinky_bend_1));
  if (raw_pinky_bend_1 != 0) {
    total_size += 5;
  }

  // float PINKY_BEND_2 = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pinky_bend_2 = this->_internal_pinky_bend_2();
  ::uint32_t raw_pinky_bend_2;
  memcpy(&raw_pinky_bend_2, &tmp_pinky_bend_2, sizeof(tmp_pinky_bend_2));
  if (raw_pinky_bend_2 != 0) {
    total_size += 5;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float GLOBAL_SPLAY = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // optional float THUMB_BEND_3 = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // optional float INDEX_BEND_3 = 14;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional float MIDDLE_BEND_3 = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

    // optional float RING_BEND_3 = 16;
    if (cached_has_bits & 0x00000010u) {
      total_size += 6;
    }

    // optional float PINKY_BEND_3 = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 6;
    }

    // optional float INDEX_SPLAY = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 6;
    }

    // optional float MIDDLE_SPLAY = 19;
    if (cached_has_bits & 0x00000080u) {
      total_size += 6;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional float RING_SPLAY = 20;
    if (cached_has_bits & 0x00000100u) {
      total_size += 6;
    }

    // optional float PINKY_SPLAY = 21;
    if (cached_has_bits & 0x00000200u) {
      total_size += 6;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Sliders::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Sliders*>(
      &from));
}

void Sliders::MergeFrom(const Sliders& from) {
  Sliders* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.Sliders)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_bend_1 = from._internal_thumb_bend_1();
  ::uint32_t raw_thumb_bend_1;
  memcpy(&raw_thumb_bend_1, &tmp_thumb_bend_1, sizeof(tmp_thumb_bend_1));
  if (raw_thumb_bend_1 != 0) {
    _this->_internal_set_thumb_bend_1(from._internal_thumb_bend_1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_bend_2 = from._internal_thumb_bend_2();
  ::uint32_t raw_thumb_bend_2;
  memcpy(&raw_thumb_bend_2, &tmp_thumb_bend_2, sizeof(tmp_thumb_bend_2));
  if (raw_thumb_bend_2 != 0) {
    _this->_internal_set_thumb_bend_2(from._internal_thumb_bend_2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_index_bend_1 = from._internal_index_bend_1();
  ::uint32_t raw_index_bend_1;
  memcpy(&raw_index_bend_1, &tmp_index_bend_1, sizeof(tmp_index_bend_1));
  if (raw_index_bend_1 != 0) {
    _this->_internal_set_index_bend_1(from._internal_index_bend_1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_index_bend_2 = from._internal_index_bend_2();
  ::uint32_t raw_index_bend_2;
  memcpy(&raw_index_bend_2, &tmp_index_bend_2, sizeof(tmp_index_bend_2));
  if (raw_index_bend_2 != 0) {
    _this->_internal_set_index_bend_2(from._internal_index_bend_2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_middle_bend_1 = from._internal_middle_bend_1();
  ::uint32_t raw_middle_bend_1;
  memcpy(&raw_middle_bend_1, &tmp_middle_bend_1, sizeof(tmp_middle_bend_1));
  if (raw_middle_bend_1 != 0) {
    _this->_internal_set_middle_bend_1(from._internal_middle_bend_1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_middle_bend_2 = from._internal_middle_bend_2();
  ::uint32_t raw_middle_bend_2;
  memcpy(&raw_middle_bend_2, &tmp_middle_bend_2, sizeof(tmp_middle_bend_2));
  if (raw_middle_bend_2 != 0) {
    _this->_internal_set_middle_bend_2(from._internal_middle_bend_2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_thumb_splay = from._internal_thumb_splay();
  ::uint32_t raw_thumb_splay;
  memcpy(&raw_thumb_splay, &tmp_thumb_splay, sizeof(tmp_thumb_splay));
  if (raw_thumb_splay != 0) {
    _this->_internal_set_thumb_splay(from._internal_thumb_splay());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ring_bend_1 = from._internal_ring_bend_1();
  ::uint32_t raw_ring_bend_1;
  memcpy(&raw_ring_bend_1, &tmp_ring_bend_1, sizeof(tmp_ring_bend_1));
  if (raw_ring_bend_1 != 0) {
    _this->_internal_set_ring_bend_1(from._internal_ring_bend_1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_ring_bend_2 = from._internal_ring_bend_2();
  ::uint32_t raw_ring_bend_2;
  memcpy(&raw_ring_bend_2, &tmp_ring_bend_2, sizeof(tmp_ring_bend_2));
  if (raw_ring_bend_2 != 0) {
    _this->_internal_set_ring_bend_2(from._internal_ring_bend_2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pinky_bend_1 = from._internal_pinky_bend_1();
  ::uint32_t raw_pinky_bend_1;
  memcpy(&raw_pinky_bend_1, &tmp_pinky_bend_1, sizeof(tmp_pinky_bend_1));
  if (raw_pinky_bend_1 != 0) {
    _this->_internal_set_pinky_bend_1(from._internal_pinky_bend_1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pinky_bend_2 = from._internal_pinky_bend_2();
  ::uint32_t raw_pinky_bend_2;
  memcpy(&raw_pinky_bend_2, &tmp_pinky_bend_2, sizeof(tmp_pinky_bend_2));
  if (raw_pinky_bend_2 != 0) {
    _this->_internal_set_pinky_bend_2(from._internal_pinky_bend_2());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.global_splay_ = from._impl_.global_splay_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.thumb_bend_3_ = from._impl_.thumb_bend_3_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_bend_3_ = from._impl_.index_bend_3_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.middle_bend_3_ = from._impl_.middle_bend_3_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ring_bend_3_ = from._impl_.ring_bend_3_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.pinky_bend_3_ = from._impl_.pinky_bend_3_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.index_splay_ = from._impl_.index_splay_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.middle_splay_ = from._impl_.middle_splay_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.ring_splay_ = from._impl_.ring_splay_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pinky_splay_ = from._impl_.pinky_splay_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Sliders::CopyFrom(const Sliders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.Sliders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sliders::IsInitialized() const {
  return true;
}

void Sliders::InternalSwap(Sliders* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sliders, _impl_.pinky_splay_)
      + sizeof(Sliders::_impl_.pinky_splay_)
      - PROTOBUF_FIELD_OFFSET(Sliders, _impl_.thumb_bend_1_)>(
          reinterpret_cast<char*>(&_impl_.thumb_bend_1_),
          reinterpret_cast<char*>(&other->_impl_.thumb_bend_1_));
}

std::string Sliders::GetTypeName() const {
  return "handEngine.v1.Sliders";
}

// ===================================================================

class StageAnimationResponse::_Internal {
 public:
};

StageAnimationResponse::StageAnimationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.StageAnimationResponse)
}
StageAnimationResponse::StageAnimationResponse(const StageAnimationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  StageAnimationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.handanimations_){from._impl_.handanimations_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.StageAnimationResponse)
}

inline void StageAnimationResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.handanimations_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StageAnimationResponse::~StageAnimationResponse() {
  // @@protoc_insertion_point(destructor:handEngine.v1.StageAnimationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StageAnimationResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_handanimations()->~RepeatedPtrField();
}

void StageAnimationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StageAnimationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.StageAnimationResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_handanimations()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StageAnimationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .handEngine.v1.HandAnimationResponse handAnimations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_handanimations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StageAnimationResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.StageAnimationResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .handEngine.v1.HandAnimationResponse handAnimations = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_handanimations_size()); i < n; i++) {
    const auto& repfield = this->_internal_handanimations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.StageAnimationResponse)
  return target;
}

::size_t StageAnimationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.StageAnimationResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .handEngine.v1.HandAnimationResponse handAnimations = 1;
  total_size += 1UL * this->_internal_handanimations_size();
  for (const auto& msg : this->_internal_handanimations()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StageAnimationResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StageAnimationResponse*>(
      &from));
}

void StageAnimationResponse::MergeFrom(const StageAnimationResponse& from) {
  StageAnimationResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.StageAnimationResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_handanimations()->MergeFrom(from._internal_handanimations());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StageAnimationResponse::CopyFrom(const StageAnimationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.StageAnimationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StageAnimationResponse::IsInitialized() const {
  return true;
}

void StageAnimationResponse::InternalSwap(StageAnimationResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_handanimations()->InternalSwap(other->_internal_mutable_handanimations());
}

std::string StageAnimationResponse::GetTypeName() const {
  return "handEngine.v1.StageAnimationResponse";
}

// ===================================================================

class JointResponse::_Internal {
 public:
};

JointResponse::JointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.JointResponse)
}
JointResponse::JointResponse(const JointResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  JointResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rotation_) { from._impl_.rotation_ }

    , decltype(_impl_.prerotation_) { from._impl_.prerotation_ }

    , decltype(_impl_.postrotation_) { from._impl_.postrotation_ }

    , decltype(_impl_.translation_) { from._impl_.translation_ }

    , decltype(_impl_.scale_) { from._impl_.scale_ }

    , decltype(_impl_.name_) {}

    , decltype(_impl_.parent_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.parent_ = from._impl_.parent_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.JointResponse)
}

inline void JointResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.rotation_) { arena }

    , decltype(_impl_.prerotation_) { arena }

    , decltype(_impl_.postrotation_) { arena }

    , decltype(_impl_.translation_) { arena }

    , decltype(_impl_.scale_) { arena }

    , decltype(_impl_.name_) {}

    , decltype(_impl_.parent_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JointResponse::~JointResponse() {
  // @@protoc_insertion_point(destructor:handEngine.v1.JointResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JointResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rotation_.~RepeatedField();
  _impl_.prerotation_.~RepeatedField();
  _impl_.postrotation_.~RepeatedField();
  _impl_.translation_.~RepeatedField();
  _impl_.scale_.~RepeatedField();
  _impl_.name_.Destroy();
}

void JointResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void JointResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.JointResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_rotation()->Clear();
  _internal_mutable_prerotation()->Clear();
  _internal_mutable_postrotation()->Clear();
  _internal_mutable_translation()->Clear();
  _internal_mutable_scale()->Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.parent_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* JointResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated float rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_rotation(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 21) {
          _internal_add_rotation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated float preRotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_prerotation(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 29) {
          _internal_add_prerotation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated float postRotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_postrotation(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 37) {
          _internal_add_postrotation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated float translation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_translation(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 45) {
          _internal_add_translation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated float scale = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_scale(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 53) {
          _internal_add_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 parent = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* JointResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.JointResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.JointResponse.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated float rotation = 2;
  if (this->_internal_rotation_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_rotation(), target);
  }

  // repeated float preRotation = 3;
  if (this->_internal_prerotation_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_prerotation(), target);
  }

  // repeated float postRotation = 4;
  if (this->_internal_postrotation_size() > 0) {
    target = stream->WriteFixedPacked(4, _internal_postrotation(), target);
  }

  // repeated float translation = 5;
  if (this->_internal_translation_size() > 0) {
    target = stream->WriteFixedPacked(5, _internal_translation(), target);
  }

  // repeated float scale = 6;
  if (this->_internal_scale_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_scale(), target);
  }

  // int32 parent = 7;
  if (this->_internal_parent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_parent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.JointResponse)
  return target;
}

::size_t JointResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.JointResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float rotation = 2;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_rotation_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated float preRotation = 3;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_prerotation_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated float postRotation = 4;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_postrotation_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated float translation = 5;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_translation_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated float scale = 6;
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_scale_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // int32 parent = 7;
  if (this->_internal_parent() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_parent());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JointResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const JointResponse*>(
      &from));
}

void JointResponse::MergeFrom(const JointResponse& from) {
  JointResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.JointResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rotation_.MergeFrom(from._impl_.rotation_);
  _this->_impl_.prerotation_.MergeFrom(from._impl_.prerotation_);
  _this->_impl_.postrotation_.MergeFrom(from._impl_.postrotation_);
  _this->_impl_.translation_.MergeFrom(from._impl_.translation_);
  _this->_impl_.scale_.MergeFrom(from._impl_.scale_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_parent() != 0) {
    _this->_internal_set_parent(from._internal_parent());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JointResponse::CopyFrom(const JointResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.JointResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointResponse::IsInitialized() const {
  return true;
}

void JointResponse::InternalSwap(JointResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.rotation_.InternalSwap(&other->_impl_.rotation_);
  _impl_.prerotation_.InternalSwap(&other->_impl_.prerotation_);
  _impl_.postrotation_.InternalSwap(&other->_impl_.postrotation_);
  _impl_.translation_.InternalSwap(&other->_impl_.translation_);
  _impl_.scale_.InternalSwap(&other->_impl_.scale_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);

  swap(_impl_.parent_, other->_impl_.parent_);
}

std::string JointResponse::GetTypeName() const {
  return "handEngine.v1.JointResponse";
}

// ===================================================================

class PoseInformationResponse::_Internal {
 public:
};

PoseInformationResponse::PoseInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.PoseInformationResponse)
}
PoseInformationResponse::PoseInformationResponse(const PoseInformationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PoseInformationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.posename_) {}

    , decltype(_impl_.poseid_) {}

    , decltype(_impl_.posescore_) {}

    , decltype(_impl_.poseactive_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.posename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.posename_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_posename().empty()) {
    _this->_impl_.posename_.Set(from._internal_posename(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.poseid_, &from._impl_.poseid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.poseactive_) -
    reinterpret_cast<char*>(&_impl_.poseid_)) + sizeof(_impl_.poseactive_));
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.PoseInformationResponse)
}

inline void PoseInformationResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.posename_) {}

    , decltype(_impl_.poseid_) { 0 }

    , decltype(_impl_.posescore_) { 0 }

    , decltype(_impl_.poseactive_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.posename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.posename_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PoseInformationResponse::~PoseInformationResponse() {
  // @@protoc_insertion_point(destructor:handEngine.v1.PoseInformationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PoseInformationResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.posename_.Destroy();
}

void PoseInformationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PoseInformationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.PoseInformationResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.posename_.ClearToEmpty();
  ::memset(&_impl_.poseid_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.poseactive_) -
      reinterpret_cast<char*>(&_impl_.poseid_)) + sizeof(_impl_.poseactive_));
  _internal_metadata_.Clear<std::string>();
}

const char* PoseInformationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string poseName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_posename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 poseId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.poseid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float poseScore = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.posescore_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool poseActive = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.poseactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PoseInformationResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.PoseInformationResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string poseName = 1;
  if (!this->_internal_posename().empty()) {
    const std::string& _s = this->_internal_posename();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.PoseInformationResponse.poseName");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int32 poseId = 2;
  if (this->_internal_poseid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_poseid(), target);
  }

  // float poseScore = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_posescore = this->_internal_posescore();
  ::uint32_t raw_posescore;
  memcpy(&raw_posescore, &tmp_posescore, sizeof(tmp_posescore));
  if (raw_posescore != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_posescore(), target);
  }

  // bool poseActive = 4;
  if (this->_internal_poseactive() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_poseactive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.PoseInformationResponse)
  return target;
}

::size_t PoseInformationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.PoseInformationResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string poseName = 1;
  if (!this->_internal_posename().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_posename());
  }

  // int32 poseId = 2;
  if (this->_internal_poseid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_poseid());
  }

  // float poseScore = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_posescore = this->_internal_posescore();
  ::uint32_t raw_posescore;
  memcpy(&raw_posescore, &tmp_posescore, sizeof(tmp_posescore));
  if (raw_posescore != 0) {
    total_size += 5;
  }

  // bool poseActive = 4;
  if (this->_internal_poseactive() != 0) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PoseInformationResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PoseInformationResponse*>(
      &from));
}

void PoseInformationResponse::MergeFrom(const PoseInformationResponse& from) {
  PoseInformationResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.PoseInformationResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_posename().empty()) {
    _this->_internal_set_posename(from._internal_posename());
  }
  if (from._internal_poseid() != 0) {
    _this->_internal_set_poseid(from._internal_poseid());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_posescore = from._internal_posescore();
  ::uint32_t raw_posescore;
  memcpy(&raw_posescore, &tmp_posescore, sizeof(tmp_posescore));
  if (raw_posescore != 0) {
    _this->_internal_set_posescore(from._internal_posescore());
  }
  if (from._internal_poseactive() != 0) {
    _this->_internal_set_poseactive(from._internal_poseactive());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PoseInformationResponse::CopyFrom(const PoseInformationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.PoseInformationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseInformationResponse::IsInitialized() const {
  return true;
}

void PoseInformationResponse::InternalSwap(PoseInformationResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.posename_, lhs_arena,
                                       &other->_impl_.posename_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PoseInformationResponse, _impl_.poseactive_)
      + sizeof(PoseInformationResponse::_impl_.poseactive_)
      - PROTOBUF_FIELD_OFFSET(PoseInformationResponse, _impl_.poseid_)>(
          reinterpret_cast<char*>(&_impl_.poseid_),
          reinterpret_cast<char*>(&other->_impl_.poseid_));
}

std::string PoseInformationResponse::GetTypeName() const {
  return "handEngine.v1.PoseInformationResponse";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::handEngine::v1::HandAnimationRequest*
Arena::CreateMaybeMessage< ::handEngine::v1::HandAnimationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::HandAnimationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::StageAnimationRequest*
Arena::CreateMaybeMessage< ::handEngine::v1::StageAnimationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::StageAnimationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::StreamSettings*
Arena::CreateMaybeMessage< ::handEngine::v1::StreamSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::StreamSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::HandAnimationResponse*
Arena::CreateMaybeMessage< ::handEngine::v1::HandAnimationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::HandAnimationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::Sliders*
Arena::CreateMaybeMessage< ::handEngine::v1::Sliders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::Sliders >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::StageAnimationResponse*
Arena::CreateMaybeMessage< ::handEngine::v1::StageAnimationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::StageAnimationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::JointResponse*
Arena::CreateMaybeMessage< ::handEngine::v1::JointResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::JointResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::PoseInformationResponse*
Arena::CreateMaybeMessage< ::handEngine::v1::PoseInformationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::PoseInformationResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
