// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v1_2f_5fapi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_v1_2f_5fapi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_v1_2f_5fapi_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v1_2f_5fapi_2eproto {
  static const ::uint32_t offsets[];
};
namespace handEngine {
namespace v1 {
class BlankRequest;
struct BlankRequestDefaultTypeInternal;
extern BlankRequestDefaultTypeInternal _BlankRequest_default_instance_;
class BlankResponse;
struct BlankResponseDefaultTypeInternal;
extern BlankResponseDefaultTypeInternal _BlankResponse_default_instance_;
class GloveInformationResponse;
struct GloveInformationResponseDefaultTypeInternal;
extern GloveInformationResponseDefaultTypeInternal _GloveInformationResponse_default_instance_;
class ProfileMeta;
struct ProfileMetaDefaultTypeInternal;
extern ProfileMetaDefaultTypeInternal _ProfileMeta_default_instance_;
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template <>
::handEngine::v1::BlankRequest* Arena::CreateMaybeMessage<::handEngine::v1::BlankRequest>(Arena*);
template <>
::handEngine::v1::BlankResponse* Arena::CreateMaybeMessage<::handEngine::v1::BlankResponse>(Arena*);
template <>
::handEngine::v1::GloveInformationResponse* Arena::CreateMaybeMessage<::handEngine::v1::GloveInformationResponse>(Arena*);
template <>
::handEngine::v1::ProfileMeta* Arena::CreateMaybeMessage<::handEngine::v1::ProfileMeta>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace handEngine {
namespace v1 {
enum Handedness : int {
  LEFT = 0,
  RIGHT = 1,
  Handedness_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Handedness_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Handedness_IsValid(int value);
constexpr Handedness Handedness_MIN = static_cast<Handedness>(0);
constexpr Handedness Handedness_MAX = static_cast<Handedness>(1);
constexpr int Handedness_ARRAYSIZE = 1 + 1;
const std::string& Handedness_Name(Handedness value);
template <typename T>
const std::string& Handedness_Name(T value) {
  static_assert(std::is_same<T, Handedness>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Handedness_Name().");
  return Handedness_Name(static_cast<Handedness>(value));
}
const std::string& Handedness_Name(Handedness value);
bool Handedness_Parse(absl::string_view name, Handedness* value);
enum TimecodeSource : int {
  SYSTEM_CLOCK = 0,
  VICON = 1,
  OPTITRACK = 2,
  TimecodeSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TimecodeSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TimecodeSource_IsValid(int value);
constexpr TimecodeSource TimecodeSource_MIN = static_cast<TimecodeSource>(0);
constexpr TimecodeSource TimecodeSource_MAX = static_cast<TimecodeSource>(2);
constexpr int TimecodeSource_ARRAYSIZE = 2 + 1;
const std::string& TimecodeSource_Name(TimecodeSource value);
template <typename T>
const std::string& TimecodeSource_Name(T value) {
  static_assert(std::is_same<T, TimecodeSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimecodeSource_Name().");
  return TimecodeSource_Name(static_cast<TimecodeSource>(value));
}
const std::string& TimecodeSource_Name(TimecodeSource value);
bool TimecodeSource_Parse(absl::string_view name, TimecodeSource* value);
enum FrameRate : int {
  FPS_24 = 0,
  FPS_25 = 1,
  FPS_30 = 2,
  FPS_50 = 3,
  FPS_120 = 4,
  FrameRate_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FrameRate_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FrameRate_IsValid(int value);
constexpr FrameRate FrameRate_MIN = static_cast<FrameRate>(0);
constexpr FrameRate FrameRate_MAX = static_cast<FrameRate>(4);
constexpr int FrameRate_ARRAYSIZE = 4 + 1;
const std::string& FrameRate_Name(FrameRate value);
template <typename T>
const std::string& FrameRate_Name(T value) {
  static_assert(std::is_same<T, FrameRate>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FrameRate_Name().");
  return FrameRate_Name(static_cast<FrameRate>(value));
}
const std::string& FrameRate_Name(FrameRate value);
bool FrameRate_Parse(absl::string_view name, FrameRate* value);
enum Cast : int {
  UNICAST = 0,
  MULTICAST = 1,
  Cast_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Cast_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Cast_IsValid(int value);
constexpr Cast Cast_MIN = static_cast<Cast>(0);
constexpr Cast Cast_MAX = static_cast<Cast>(1);
constexpr int Cast_ARRAYSIZE = 1 + 1;
const std::string& Cast_Name(Cast value);
template <typename T>
const std::string& Cast_Name(T value) {
  static_assert(std::is_same<T, Cast>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Cast_Name().");
  return Cast_Name(static_cast<Cast>(value));
}
const std::string& Cast_Name(Cast value);
bool Cast_Parse(absl::string_view name, Cast* value);
enum SmartPose : int {
  FIST = 0,
  PADDLE = 1,
  PEACE = 2,
  REACH = 3,
  THUMB_UP = 4,
  THUMB_OUT = 5,
  TUNNEL = 6,
  SmartPose_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SmartPose_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SmartPose_IsValid(int value);
constexpr SmartPose SmartPose_MIN = static_cast<SmartPose>(0);
constexpr SmartPose SmartPose_MAX = static_cast<SmartPose>(6);
constexpr int SmartPose_ARRAYSIZE = 6 + 1;
const std::string& SmartPose_Name(SmartPose value);
template <typename T>
const std::string& SmartPose_Name(T value) {
  static_assert(std::is_same<T, SmartPose>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SmartPose_Name().");
  return SmartPose_Name(static_cast<SmartPose>(value));
}
const std::string& SmartPose_Name(SmartPose value);
bool SmartPose_Parse(absl::string_view name, SmartPose* value);
enum HapticPattern : int {
  UNKNOWN = 0,
  STRONG_CLICK_100 = 1,
  STRONG_CLICK_60 = 2,
  STRONG_CLICK_30 = 3,
  SHARP_CLICK_100 = 4,
  SHARP_CLICK_60 = 5,
  SHARP_CLICK_30 = 6,
  SOFT_BUMP_100 = 7,
  SOFT_BUMP_60 = 8,
  SOFT_BUMP_30 = 9,
  DOUBLE_CLICK_100 = 10,
  DOUBLE_CLICK_60 = 11,
  TRIPLE_CLICK_100 = 12,
  SOFT_FUZZ_60 = 13,
  STRONG_BUZZ_100 = 14,
  ALERT_750_MS_100 = 15,
  ALERT_1000_MS_100 = 16,
  STRONG_CLICK_1_100 = 17,
  STRONG_CLICK_2_80 = 18,
  STRONG_CLICK_3_60 = 19,
  STRONG_CLICK_4_30 = 20,
  MEDIUM_CLICK_1_100 = 21,
  MEDIUM_CLICK_2_80 = 22,
  MEDIUM_CLICK_3_60 = 23,
  SHARP_TICK_1_100 = 24,
  SHARP_TICK_2_80 = 25,
  SHARP_TICK_3_60 = 26,
  SHORT_DOUBLE_CLICK_STRONG_1_100 = 27,
  SHORT_DOUBLE_CLICK_STRONG_2_80 = 28,
  SHORT_DOUBLE_CLICK_STRONG_3_60 = 29,
  SHORT_DOUBLE_CLICK_STRONG_4_30 = 30,
  SHORT_DOUBLE_CLICK_MEDIUM_1_100 = 31,
  SHORT_DOUBLE_CLICK_MEDIUM_2_80 = 32,
  SHORT_DOUBLE_CLICK_MEDIUM_3_60 = 33,
  SHORT_DOUBLE_SHARP_TICK_1_100 = 34,
  SHORT_DOUBLE_SHARP_TICK_2_80 = 35,
  SHORT_DOUBLE_SHARP_TICK_3_60 = 36,
  LONG_DOUBLE_SHARP_CLICK_STRONG_1_100 = 37,
  LONG_DOUBLE_SHARP_CLICK_STRONG_2_80 = 38,
  LONG_DOUBLE_SHARP_CLICK_STRONG_3_60 = 39,
  LONG_DOUBLE_SHARP_CLICK_STRONG_4_30 = 40,
  LONG_DOUBLE_SHARP_CLICK_MEDIUM_1_100 = 41,
  LONG_DOUBLE_SHARP_CLICK_MEDIUM_2_80 = 42,
  LONG_DOUBLE_SHARP_CLICK_MEDIUM_3_60 = 43,
  LONG_DOUBLE_SHARP_TICK_1_100 = 44,
  LONG_DOUBLE_SHARP_TICK_2_80 = 45,
  LONG_DOUBLE_SHARP_TICK_3_60 = 46,
  BUZZ_1_100 = 47,
  BUZZ_2_80 = 48,
  BUZZ_3_60 = 49,
  BUZZ_4_40 = 50,
  BUZZ_5_20 = 51,
  PULSING_STRONG_1_100 = 52,
  PULSING_STRONG_2_60 = 53,
  PULSING_MEDIUM_1_100 = 54,
  PULSING_MEDIUM_2_60 = 55,
  PULSING_SHARP_1_100 = 56,
  PULSING_SHARP_2_60 = 57,
  TRANSITION_CLICK_1_100 = 58,
  TRANSITION_CLICK_2_80 = 59,
  TRANSITION_CLICK_3_60 = 60,
  TRANSITION_CLICK_4_40 = 61,
  TRANSITION_CLICK_5_20 = 62,
  TRANSITION_CLICK_6_10 = 63,
  TRANSITION_HUM_1_100 = 64,
  TRANSITION_HUM_2_80 = 65,
  TRANSITION_HUM_3_60 = 66,
  TRANSITION_HUM_4_40 = 67,
  TRANSITION_HUM_5_20 = 68,
  TRANSITION_HUM_6_10 = 69,
  TRANSITION_RAMP_DOWN_LONG_SMOOTH_1_100_TO_0 = 70,
  TRANSITION_RAMP_DOWN_LONG_SMOOTH_2_100_TO_0 = 71,
  TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_1_100_TO_0 = 72,
  TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_2_100_TO_0 = 73,
  TRANSITION_RAMP_DOWN_SHORT_SMOOTH_1_100_TO_0 = 74,
  TRANSITION_RAMP_DOWN_SHORT_SMOOTH_2_100_TO_0 = 75,
  TRANSITION_RAMP_DOWN_LONG_SHARP_1_100_TO_0 = 76,
  TRANSITION_RAMP_DOWN_LONG_SHARP_2_100_TO_0 = 77,
  TRANSITION_RAMP_DOWN_MEDIUM_SHARP_1_100_TO_0 = 78,
  TRANSITION_RAMP_DOWN_MEDIUM_SHARP_2_100_TO_0 = 79,
  TRANSITION_RAMP_DOWN_SHORT_SHARP_1_100_TO_0 = 80,
  TRANSITION_RAMP_DOWN_SHORT_SHARP_2_100_TO_0 = 81,
  TRANSITION_RAMP_UP_LONG_SMOOTH_1_0_TO_100 = 82,
  TRANSITION_RAMP_UP_LONG_SMOOTH_2_0_TO_100 = 83,
  TRANSITION_RAMP_UP_MEDIUM_SMOOTH_1_0_TO_100 = 84,
  TRANSITION_RAMP_UP_MEDIUM_SMOOTH_2_0_TO_100 = 85,
  TRANSITION_RAMP_UP_SHORT_SMOOTH_1_0_TO_100 = 86,
  TRANSITION_RAMP_UP_SHORT_SMOOTH_2_0_TO_100 = 87,
  TRANSITION_RAMP_UP_LONG_SHARP_1_0_TO_100 = 88,
  TRANSITION_RAMP_UP_LONG_SHARP_2_0_TO_100 = 89,
  TRANSITION_RAMP_UP_MEDIUM_SHARP_1_0_TO_100 = 90,
  TRANSITION_RAMP_UP_MEDIUM_SHARP_2_0_TO_100 = 91,
  TRANSITION_RAMP_UP_SHORT_SHARP_1_0_TO_100 = 92,
  TRANSITION_RAMP_UP_SHORT_SHARP_2_0_TO_100 = 93,
  TRANSITION_RAMP_DOWN_LONG_SMOOTH_1_50_TO_0 = 94,
  TRANSITION_RAMP_DOWN_LONG_SMOOTH_2_50_TO_0 = 95,
  TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_1_50_TO_0 = 96,
  TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_2_50_TO_0 = 97,
  TRANSITION_RAMP_DOWN_SHORT_SMOOTH_1_50_TO_0 = 98,
  TRANSITION_RAMP_DOWN_SHORT_SMOOTH_2_50_TO_0 = 99,
  TRANSITION_RAMP_DOWN_LONG_SHARP_1_50_TO_0 = 100,
  TRANSITION_RAMP_DOWN_LONG_SHARP_2_50_TO_0 = 101,
  TRANSITION_RAMP_DOWN_MEDIUM_SHARP_1_50_TO_0 = 102,
  TRANSITION_RAMP_DOWN_MEDIUM_SHARP_2_50_TO_0 = 103,
  TRANSITION_RAMP_DOWN_SHORT_SHARP_1_50_TO_0 = 104,
  TRANSITION_RAMP_DOWN_SHORT_SHARP_2_50_TO_0 = 105,
  TRANSITION_RAMP_UP_LONG_SMOOTH_1_0_TO_50 = 106,
  TRANSITION_RAMP_UP_LONG_SMOOTH_2_0_TO_50 = 107,
  TRANSITION_RAMP_UP_MEDIUM_SMOOTH_1_0_TO_50 = 108,
  TRANSITION_RAMP_UP_MEDIUM_SMOOTH_2_0_TO_50 = 109,
  TRANSITION_RAMP_UP_SHORT_SMOOTH_1_0_TO_50 = 110,
  TRANSITION_RAMP_UP_SHORT_SMOOTH_2_0_TO_50 = 111,
  TRANSITION_RAMP_UP_LONG_SHARP_1_0_TO_50 = 112,
  TRANSITION_RAMP_UP_LONG_SHARP_2_0_TO_50 = 113,
  TRANSITION_RAMP_UP_MEDIUM_SHARP_1_0_TO_50 = 114,
  TRANSITION_RAMP_UP_MEDIUM_SHARP_2_0_TO_50 = 115,
  TRANSITION_RAMP_UP_SHORT_SHARP_1_0_TO_50 = 116,
  TRANSITION_RAMP_UP_SHORT_SHARP_2_0_TO_50 = 117,
  LONG_BUZZ_FOR_PROGRAMMATIC_STOPPING_100 = 118,
  SMOOTH_HUM_1_50 = 119,
  SMOOTH_HUM_2_40 = 120,
  SMOOTH_HUM_3_30 = 121,
  SMOOTH_HUM_4_20 = 122,
  SMOOTH_HUM_5_10 = 123,
  HapticPattern_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HapticPattern_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HapticPattern_IsValid(int value);
constexpr HapticPattern HapticPattern_MIN = static_cast<HapticPattern>(0);
constexpr HapticPattern HapticPattern_MAX = static_cast<HapticPattern>(123);
constexpr int HapticPattern_ARRAYSIZE = 123 + 1;
const std::string& HapticPattern_Name(HapticPattern value);
template <typename T>
const std::string& HapticPattern_Name(T value) {
  static_assert(std::is_same<T, HapticPattern>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HapticPattern_Name().");
  return HapticPattern_Name(static_cast<HapticPattern>(value));
}
const std::string& HapticPattern_Name(HapticPattern value);
bool HapticPattern_Parse(absl::string_view name, HapticPattern* value);

// ===================================================================


// -------------------------------------------------------------------

class BlankRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.BlankRequest) */ {
 public:
  inline BlankRequest() : BlankRequest(nullptr) {}
  ~BlankRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlankRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlankRequest(const BlankRequest& from);
  BlankRequest(BlankRequest&& from) noexcept
    : BlankRequest() {
    *this = ::std::move(from);
  }

  inline BlankRequest& operator=(const BlankRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlankRequest& operator=(BlankRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BlankRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlankRequest* internal_default_instance() {
    return reinterpret_cast<const BlankRequest*>(
               &_BlankRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BlankRequest& a, BlankRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlankRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlankRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlankRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlankRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BlankRequest& from);
  void MergeFrom(const BlankRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlankRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.BlankRequest";
  }
  protected:
  explicit BlankRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:handEngine.v1.BlankRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2f_5fapi_2eproto;
};// -------------------------------------------------------------------

class ProfileMeta final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.ProfileMeta) */ {
 public:
  inline ProfileMeta() : ProfileMeta(nullptr) {}
  ~ProfileMeta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProfileMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileMeta(const ProfileMeta& from);
  ProfileMeta(ProfileMeta&& from) noexcept
    : ProfileMeta() {
    *this = ::std::move(from);
  }

  inline ProfileMeta& operator=(const ProfileMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileMeta& operator=(ProfileMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProfileMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileMeta* internal_default_instance() {
    return reinterpret_cast<const ProfileMeta*>(
               &_ProfileMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProfileMeta& a, ProfileMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileMeta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProfileMeta& from);
  void MergeFrom(const ProfileMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.ProfileMeta";
  }
  protected:
  explicit ProfileMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerformerIdFieldNumber = 1,
    kHandednessFieldNumber = 2,
  };
  // int32 performerId = 1;
  void clear_performerid() ;
  ::int32_t performerid() const;
  void set_performerid(::int32_t value);

  private:
  ::int32_t _internal_performerid() const;
  void _internal_set_performerid(::int32_t value);

  public:
  // .handEngine.v1.Handedness handedness = 2;
  void clear_handedness() ;
  ::handEngine::v1::Handedness handedness() const;
  void set_handedness(::handEngine::v1::Handedness value);

  private:
  ::handEngine::v1::Handedness _internal_handedness() const;
  void _internal_set_handedness(::handEngine::v1::Handedness value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.ProfileMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t performerid_;
    int handedness_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2f_5fapi_2eproto;
};// -------------------------------------------------------------------

class GloveInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.GloveInformationResponse) */ {
 public:
  inline GloveInformationResponse() : GloveInformationResponse(nullptr) {}
  ~GloveInformationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GloveInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GloveInformationResponse(const GloveInformationResponse& from);
  GloveInformationResponse(GloveInformationResponse&& from) noexcept
    : GloveInformationResponse() {
    *this = ::std::move(from);
  }

  inline GloveInformationResponse& operator=(const GloveInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GloveInformationResponse& operator=(GloveInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GloveInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GloveInformationResponse* internal_default_instance() {
    return reinterpret_cast<const GloveInformationResponse*>(
               &_GloveInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GloveInformationResponse& a, GloveInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GloveInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GloveInformationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GloveInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GloveInformationResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GloveInformationResponse& from);
  void MergeFrom(const GloveInformationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GloveInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.GloveInformationResponse";
  }
  protected:
  explicit GloveInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialNumberFieldNumber = 1,
    kGloveIdFieldNumber = 2,
    kGloveFirmwareFieldNumber = 3,
    kDongleFirmwareFieldNumber = 4,
    kGloveRevisionFieldNumber = 5,
    kBatteryLevelFieldNumber = 6,
  };
  // string serialNumber = 1;
  void clear_serialnumber() ;
  const std::string& serialnumber() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serialnumber(Arg_&& arg, Args_... args);
  std::string* mutable_serialnumber();
  PROTOBUF_NODISCARD std::string* release_serialnumber();
  void set_allocated_serialnumber(std::string* ptr);

  private:
  const std::string& _internal_serialnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialnumber(
      const std::string& value);
  std::string* _internal_mutable_serialnumber();

  public:
  // string gloveId = 2;
  void clear_gloveid() ;
  const std::string& gloveid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gloveid(Arg_&& arg, Args_... args);
  std::string* mutable_gloveid();
  PROTOBUF_NODISCARD std::string* release_gloveid();
  void set_allocated_gloveid(std::string* ptr);

  private:
  const std::string& _internal_gloveid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gloveid(
      const std::string& value);
  std::string* _internal_mutable_gloveid();

  public:
  // string gloveFirmware = 3;
  void clear_glovefirmware() ;
  const std::string& glovefirmware() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_glovefirmware(Arg_&& arg, Args_... args);
  std::string* mutable_glovefirmware();
  PROTOBUF_NODISCARD std::string* release_glovefirmware();
  void set_allocated_glovefirmware(std::string* ptr);

  private:
  const std::string& _internal_glovefirmware() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_glovefirmware(
      const std::string& value);
  std::string* _internal_mutable_glovefirmware();

  public:
  // string dongleFirmware = 4;
  void clear_donglefirmware() ;
  const std::string& donglefirmware() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_donglefirmware(Arg_&& arg, Args_... args);
  std::string* mutable_donglefirmware();
  PROTOBUF_NODISCARD std::string* release_donglefirmware();
  void set_allocated_donglefirmware(std::string* ptr);

  private:
  const std::string& _internal_donglefirmware() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_donglefirmware(
      const std::string& value);
  std::string* _internal_mutable_donglefirmware();

  public:
  // string gloveRevision = 5;
  void clear_gloverevision() ;
  const std::string& gloverevision() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gloverevision(Arg_&& arg, Args_... args);
  std::string* mutable_gloverevision();
  PROTOBUF_NODISCARD std::string* release_gloverevision();
  void set_allocated_gloverevision(std::string* ptr);

  private:
  const std::string& _internal_gloverevision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gloverevision(
      const std::string& value);
  std::string* _internal_mutable_gloverevision();

  public:
  // float batteryLevel = 6;
  void clear_batterylevel() ;
  float batterylevel() const;
  void set_batterylevel(float value);

  private:
  float _internal_batterylevel() const;
  void _internal_set_batterylevel(float value);

  public:
  // @@protoc_insertion_point(class_scope:handEngine.v1.GloveInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialnumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gloveid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr glovefirmware_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr donglefirmware_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gloverevision_;
    float batterylevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2f_5fapi_2eproto;
};// -------------------------------------------------------------------

class BlankResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:handEngine.v1.BlankResponse) */ {
 public:
  inline BlankResponse() : BlankResponse(nullptr) {}
  ~BlankResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlankResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlankResponse(const BlankResponse& from);
  BlankResponse(BlankResponse&& from) noexcept
    : BlankResponse() {
    *this = ::std::move(from);
  }

  inline BlankResponse& operator=(const BlankResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlankResponse& operator=(BlankResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BlankResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlankResponse* internal_default_instance() {
    return reinterpret_cast<const BlankResponse*>(
               &_BlankResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BlankResponse& a, BlankResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlankResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlankResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlankResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlankResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BlankResponse& from);
  void MergeFrom(const BlankResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlankResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "handEngine.v1.BlankResponse";
  }
  protected:
  explicit BlankResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:handEngine.v1.BlankResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v1_2f_5fapi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// BlankRequest

// -------------------------------------------------------------------

// ProfileMeta

// int32 performerId = 1;
inline void ProfileMeta::clear_performerid() {
  _impl_.performerid_ = 0;
}
inline ::int32_t ProfileMeta::performerid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ProfileMeta.performerId)
  return _internal_performerid();
}
inline void ProfileMeta::set_performerid(::int32_t value) {
  _internal_set_performerid(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ProfileMeta.performerId)
}
inline ::int32_t ProfileMeta::_internal_performerid() const {
  return _impl_.performerid_;
}
inline void ProfileMeta::_internal_set_performerid(::int32_t value) {
  ;
  _impl_.performerid_ = value;
}

// .handEngine.v1.Handedness handedness = 2;
inline void ProfileMeta::clear_handedness() {
  _impl_.handedness_ = 0;
}
inline ::handEngine::v1::Handedness ProfileMeta::handedness() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.ProfileMeta.handedness)
  return _internal_handedness();
}
inline void ProfileMeta::set_handedness(::handEngine::v1::Handedness value) {
   _internal_set_handedness(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.ProfileMeta.handedness)
}
inline ::handEngine::v1::Handedness ProfileMeta::_internal_handedness() const {
  return static_cast<::handEngine::v1::Handedness>(_impl_.handedness_);
}
inline void ProfileMeta::_internal_set_handedness(::handEngine::v1::Handedness value) {
  ;
  _impl_.handedness_ = value;
}

// -------------------------------------------------------------------

// GloveInformationResponse

// string serialNumber = 1;
inline void GloveInformationResponse::clear_serialnumber() {
  _impl_.serialnumber_.ClearToEmpty();
}
inline const std::string& GloveInformationResponse::serialnumber() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.GloveInformationResponse.serialNumber)
  return _internal_serialnumber();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GloveInformationResponse::set_serialnumber(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.serialnumber_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.GloveInformationResponse.serialNumber)
}
inline std::string* GloveInformationResponse::mutable_serialnumber() {
  std::string* _s = _internal_mutable_serialnumber();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.GloveInformationResponse.serialNumber)
  return _s;
}
inline const std::string& GloveInformationResponse::_internal_serialnumber() const {
  return _impl_.serialnumber_.Get();
}
inline void GloveInformationResponse::_internal_set_serialnumber(const std::string& value) {
  ;


  _impl_.serialnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::_internal_mutable_serialnumber() {
  ;
  return _impl_.serialnumber_.Mutable( GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::release_serialnumber() {
  // @@protoc_insertion_point(field_release:handEngine.v1.GloveInformationResponse.serialNumber)
  return _impl_.serialnumber_.Release();
}
inline void GloveInformationResponse::set_allocated_serialnumber(std::string* value) {
  _impl_.serialnumber_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serialnumber_.IsDefault()) {
          _impl_.serialnumber_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.GloveInformationResponse.serialNumber)
}

// string gloveId = 2;
inline void GloveInformationResponse::clear_gloveid() {
  _impl_.gloveid_.ClearToEmpty();
}
inline const std::string& GloveInformationResponse::gloveid() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.GloveInformationResponse.gloveId)
  return _internal_gloveid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GloveInformationResponse::set_gloveid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.gloveid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.GloveInformationResponse.gloveId)
}
inline std::string* GloveInformationResponse::mutable_gloveid() {
  std::string* _s = _internal_mutable_gloveid();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.GloveInformationResponse.gloveId)
  return _s;
}
inline const std::string& GloveInformationResponse::_internal_gloveid() const {
  return _impl_.gloveid_.Get();
}
inline void GloveInformationResponse::_internal_set_gloveid(const std::string& value) {
  ;


  _impl_.gloveid_.Set(value, GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::_internal_mutable_gloveid() {
  ;
  return _impl_.gloveid_.Mutable( GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::release_gloveid() {
  // @@protoc_insertion_point(field_release:handEngine.v1.GloveInformationResponse.gloveId)
  return _impl_.gloveid_.Release();
}
inline void GloveInformationResponse::set_allocated_gloveid(std::string* value) {
  _impl_.gloveid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gloveid_.IsDefault()) {
          _impl_.gloveid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.GloveInformationResponse.gloveId)
}

// string gloveFirmware = 3;
inline void GloveInformationResponse::clear_glovefirmware() {
  _impl_.glovefirmware_.ClearToEmpty();
}
inline const std::string& GloveInformationResponse::glovefirmware() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.GloveInformationResponse.gloveFirmware)
  return _internal_glovefirmware();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GloveInformationResponse::set_glovefirmware(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.glovefirmware_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.GloveInformationResponse.gloveFirmware)
}
inline std::string* GloveInformationResponse::mutable_glovefirmware() {
  std::string* _s = _internal_mutable_glovefirmware();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.GloveInformationResponse.gloveFirmware)
  return _s;
}
inline const std::string& GloveInformationResponse::_internal_glovefirmware() const {
  return _impl_.glovefirmware_.Get();
}
inline void GloveInformationResponse::_internal_set_glovefirmware(const std::string& value) {
  ;


  _impl_.glovefirmware_.Set(value, GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::_internal_mutable_glovefirmware() {
  ;
  return _impl_.glovefirmware_.Mutable( GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::release_glovefirmware() {
  // @@protoc_insertion_point(field_release:handEngine.v1.GloveInformationResponse.gloveFirmware)
  return _impl_.glovefirmware_.Release();
}
inline void GloveInformationResponse::set_allocated_glovefirmware(std::string* value) {
  _impl_.glovefirmware_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.glovefirmware_.IsDefault()) {
          _impl_.glovefirmware_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.GloveInformationResponse.gloveFirmware)
}

// string dongleFirmware = 4;
inline void GloveInformationResponse::clear_donglefirmware() {
  _impl_.donglefirmware_.ClearToEmpty();
}
inline const std::string& GloveInformationResponse::donglefirmware() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.GloveInformationResponse.dongleFirmware)
  return _internal_donglefirmware();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GloveInformationResponse::set_donglefirmware(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.donglefirmware_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.GloveInformationResponse.dongleFirmware)
}
inline std::string* GloveInformationResponse::mutable_donglefirmware() {
  std::string* _s = _internal_mutable_donglefirmware();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.GloveInformationResponse.dongleFirmware)
  return _s;
}
inline const std::string& GloveInformationResponse::_internal_donglefirmware() const {
  return _impl_.donglefirmware_.Get();
}
inline void GloveInformationResponse::_internal_set_donglefirmware(const std::string& value) {
  ;


  _impl_.donglefirmware_.Set(value, GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::_internal_mutable_donglefirmware() {
  ;
  return _impl_.donglefirmware_.Mutable( GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::release_donglefirmware() {
  // @@protoc_insertion_point(field_release:handEngine.v1.GloveInformationResponse.dongleFirmware)
  return _impl_.donglefirmware_.Release();
}
inline void GloveInformationResponse::set_allocated_donglefirmware(std::string* value) {
  _impl_.donglefirmware_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.donglefirmware_.IsDefault()) {
          _impl_.donglefirmware_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.GloveInformationResponse.dongleFirmware)
}

// string gloveRevision = 5;
inline void GloveInformationResponse::clear_gloverevision() {
  _impl_.gloverevision_.ClearToEmpty();
}
inline const std::string& GloveInformationResponse::gloverevision() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.GloveInformationResponse.gloveRevision)
  return _internal_gloverevision();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GloveInformationResponse::set_gloverevision(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.gloverevision_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:handEngine.v1.GloveInformationResponse.gloveRevision)
}
inline std::string* GloveInformationResponse::mutable_gloverevision() {
  std::string* _s = _internal_mutable_gloverevision();
  // @@protoc_insertion_point(field_mutable:handEngine.v1.GloveInformationResponse.gloveRevision)
  return _s;
}
inline const std::string& GloveInformationResponse::_internal_gloverevision() const {
  return _impl_.gloverevision_.Get();
}
inline void GloveInformationResponse::_internal_set_gloverevision(const std::string& value) {
  ;


  _impl_.gloverevision_.Set(value, GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::_internal_mutable_gloverevision() {
  ;
  return _impl_.gloverevision_.Mutable( GetArenaForAllocation());
}
inline std::string* GloveInformationResponse::release_gloverevision() {
  // @@protoc_insertion_point(field_release:handEngine.v1.GloveInformationResponse.gloveRevision)
  return _impl_.gloverevision_.Release();
}
inline void GloveInformationResponse::set_allocated_gloverevision(std::string* value) {
  _impl_.gloverevision_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gloverevision_.IsDefault()) {
          _impl_.gloverevision_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:handEngine.v1.GloveInformationResponse.gloveRevision)
}

// float batteryLevel = 6;
inline void GloveInformationResponse::clear_batterylevel() {
  _impl_.batterylevel_ = 0;
}
inline float GloveInformationResponse::batterylevel() const {
  // @@protoc_insertion_point(field_get:handEngine.v1.GloveInformationResponse.batteryLevel)
  return _internal_batterylevel();
}
inline void GloveInformationResponse::set_batterylevel(float value) {
  _internal_set_batterylevel(value);
  // @@protoc_insertion_point(field_set:handEngine.v1.GloveInformationResponse.batteryLevel)
}
inline float GloveInformationResponse::_internal_batterylevel() const {
  return _impl_.batterylevel_;
}
inline void GloveInformationResponse::_internal_set_batterylevel(float value) {
  ;
  _impl_.batterylevel_ = value;
}

// -------------------------------------------------------------------

// BlankResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::handEngine::v1::Handedness> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::TimecodeSource> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::FrameRate> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::Cast> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::SmartPose> : std::true_type {};
template <>
struct is_proto_enum<::handEngine::v1::HapticPattern> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_v1_2f_5fapi_2eproto_2epb_2eh

