
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: v1/stage.proto
// Original file comments:
// *
// Stage RPCs
//
// Trigger stage recording and access stage state in Hand Engine.
#ifndef GRPC_v1_2fstage_2eproto__INCLUDED
#define GRPC_v1_2fstage_2eproto__INCLUDED

#include "v1/stage.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace handEngine {
namespace v1 {

class StageService final {
 public:
  static constexpr char const* service_full_name() {
    return "handEngine.v1.StageService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // *
    // Gets a stream of the stage state to aid in syncronisation with other
    // applications. Not implemented yet.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::StageStateResponse>> GetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::handEngine::v1::StageStateResponse>>(GetStageStateStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::StageStateResponse>> AsyncGetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::StageStateResponse>>(AsyncGetStageStateStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::StageStateResponse>> PrepareAsyncGetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::StageStateResponse>>(PrepareAsyncGetStageStateStreamRaw(context, request, cq));
    }
    // *
    // Set the current recording state and take name for the staged performers. This
    // will record data for all performers, regardless of their glove devices being
    // connected or not.
    //
    // Data is saved to a datestamped folder with a child folder labelled with the
    // take name. The take folder location is defined by a request to
    // `SetRecordingDirectory()`.
    //
    // The following files will be saved:
    //
    // (`PERFORMER_NAME` is the name of the performer and where XXXX is the
    // `performerId` incremented by 1 and `L` or `R` to indicate handedness. E.g `P1L`)
    //
    // * `Cal_PXXXX_PERFORMER_NAME.json` - The performer's calibration file.
    // * `PXXXXFullBody_PERFORMER_NAME.fbx`- An output of the captured hands on a full
    //    skeleton to be compatible with various animation software.
    // * `PXXXX_PERFORMER_NAME.csv`- A raw comma seperated output of the captured
    //    hand as just the hand skeleton joints, with the wrist being the root bone.
    //    Useful when writing custom tooling to process animation data in your pipeline.
    // * `PXXXX_PERFORMER_NAME.fbx`- An FBX output of the captured hand as just the
    //    hand skeleton joints, with the wrist being the root bone. Compatible with
    //    various animation software.
    // * `PXXXX_PERFORMER_NAMEMeta.json` - Metadata associated with the take in the
    //    following example JSON format:
    //
    // #### PXXXX_PERFORMER_NAMEMeta.json Example
    //
    // ```
    // {
    //    "source": "HE",
    //    "hash": "z0GhHN0uur5lXQeIjpVx7mOV5eeME9C872E72DC4",
    //    "takeName": "Take_0001",
    //    "startDate": "2022-08-09",
    //    "startTime": "01-31-34-230-pm",
    //    "performerName": "PERFORMER_NAME",
    //    "performerNumber": 0,
    //    "profileName": "default-left",
    //    "calibrationId": 0,
    //    "side": "Left",
    //    "gloveType": "RevF",
    //    "gloveSN": "00000139",
    //    "gloveFW": "01.00.00",
    //    "dongleFW": "01.01.04",
    //    "fileName": "PXXXX_PERFORMER_NAME.csv",
    //    "outputType": "express",
    //    "masterTimeCodeSource": "System",
    //    "fpsRate": 60
    // }
    // ```
    virtual ::grpc::Status SetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncSetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncSetRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncSetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetRecordingStateRaw(context, request, cq));
    }
    // *
    // Sets the recording directory where animation takes will be saved to disk. The
    // currently logged in Windows user will need write permissions to this folder,
    // so you may need to double check this if setting it to a network drive or if
    // the user has any kind of device management profile applied to it which
    // could prevent writing to certain folders on the computer. On Windows, the user's
    // `Documents` folder is a safe recommended location.
    virtual ::grpc::Status SetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncSetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncSetRecordingDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncSetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetRecordingDirectoryRaw(context, request, cq));
    }
    // *
    // Sets the source for timecode syncing, so Hand Engine's timecode can remain in sync
    // with an external system.
    //
    // The `framerate` value defined here will affect the rate at which the call to
    // [GetAllHandAnimationStream](#getallhandanimationstream) will send back data
    // on the current pose of each tracked glove device. Larger values will consume more
    // resources when sent to your application via the SDK.
    virtual ::grpc::Status SetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::handEngine::v1::BlankResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> AsyncSetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(AsyncSetTimecodeSourceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>> PrepareAsyncSetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetTimecodeSourceRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // *
      // Gets a stream of the stage state to aid in syncronisation with other
      // applications. Not implemented yet.
      virtual void GetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ClientReadReactor< ::handEngine::v1::StageStateResponse>* reactor) = 0;
      // *
      // Set the current recording state and take name for the staged performers. This
      // will record data for all performers, regardless of their glove devices being
      // connected or not.
      //
      // Data is saved to a datestamped folder with a child folder labelled with the
      // take name. The take folder location is defined by a request to
      // `SetRecordingDirectory()`.
      //
      // The following files will be saved:
      //
      // (`PERFORMER_NAME` is the name of the performer and where XXXX is the
      // `performerId` incremented by 1 and `L` or `R` to indicate handedness. E.g `P1L`)
      //
      // * `Cal_PXXXX_PERFORMER_NAME.json` - The performer's calibration file.
      // * `PXXXXFullBody_PERFORMER_NAME.fbx`- An output of the captured hands on a full
      //    skeleton to be compatible with various animation software.
      // * `PXXXX_PERFORMER_NAME.csv`- A raw comma seperated output of the captured
      //    hand as just the hand skeleton joints, with the wrist being the root bone.
      //    Useful when writing custom tooling to process animation data in your pipeline.
      // * `PXXXX_PERFORMER_NAME.fbx`- An FBX output of the captured hand as just the
      //    hand skeleton joints, with the wrist being the root bone. Compatible with
      //    various animation software.
      // * `PXXXX_PERFORMER_NAMEMeta.json` - Metadata associated with the take in the
      //    following example JSON format:
      //
      // #### PXXXX_PERFORMER_NAMEMeta.json Example
      //
      // ```
      // {
      //    "source": "HE",
      //    "hash": "z0GhHN0uur5lXQeIjpVx7mOV5eeME9C872E72DC4",
      //    "takeName": "Take_0001",
      //    "startDate": "2022-08-09",
      //    "startTime": "01-31-34-230-pm",
      //    "performerName": "PERFORMER_NAME",
      //    "performerNumber": 0,
      //    "profileName": "default-left",
      //    "calibrationId": 0,
      //    "side": "Left",
      //    "gloveType": "RevF",
      //    "gloveSN": "00000139",
      //    "gloveFW": "01.00.00",
      //    "dongleFW": "01.01.04",
      //    "fileName": "PXXXX_PERFORMER_NAME.csv",
      //    "outputType": "express",
      //    "masterTimeCodeSource": "System",
      //    "fpsRate": 60
      // }
      // ```
      virtual void SetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // *
      // Sets the recording directory where animation takes will be saved to disk. The
      // currently logged in Windows user will need write permissions to this folder,
      // so you may need to double check this if setting it to a network drive or if
      // the user has any kind of device management profile applied to it which
      // could prevent writing to certain folders on the computer. On Windows, the user's
      // `Documents` folder is a safe recommended location.
      virtual void SetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // *
      // Sets the source for timecode syncing, so Hand Engine's timecode can remain in sync
      // with an external system.
      //
      // The `framerate` value defined here will affect the rate at which the call to
      // [GetAllHandAnimationStream](#getallhandanimationstream) will send back data
      // on the current pose of each tracked glove device. Larger values will consume more
      // resources when sent to your application via the SDK.
      virtual void SetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::handEngine::v1::StageStateResponse>* GetStageStateStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::StageStateResponse>* AsyncGetStageStateStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::handEngine::v1::StageStateResponse>* PrepareAsyncGetStageStateStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncSetRecordingStateRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncSetRecordingStateRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncSetRecordingDirectoryRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncSetRecordingDirectoryRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* AsyncSetTimecodeSourceRaw(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handEngine::v1::BlankResponse>* PrepareAsyncSetTimecodeSourceRaw(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::StageStateResponse>> GetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::handEngine::v1::StageStateResponse>>(GetStageStateStreamRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::StageStateResponse>> AsyncGetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::StageStateResponse>>(AsyncGetStageStateStreamRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::StageStateResponse>> PrepareAsyncGetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::handEngine::v1::StageStateResponse>>(PrepareAsyncGetStageStateStreamRaw(context, request, cq));
    }
    ::grpc::Status SetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncSetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncSetRecordingStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncSetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetRecordingStateRaw(context, request, cq));
    }
    ::grpc::Status SetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncSetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncSetRecordingDirectoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncSetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetRecordingDirectoryRaw(context, request, cq));
    }
    ::grpc::Status SetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::handEngine::v1::BlankResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> AsyncSetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(AsyncSetTimecodeSourceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>> PrepareAsyncSetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>>(PrepareAsyncSetTimecodeSourceRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetStageStateStream(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ClientReadReactor< ::handEngine::v1::StageStateResponse>* reactor) override;
      void SetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void SetRecordingState(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void SetRecordingDirectory(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest* request, ::handEngine::v1::BlankResponse* response, std::function<void(::grpc::Status)>) override;
      void SetTimecodeSource(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest* request, ::handEngine::v1::BlankResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::handEngine::v1::StageStateResponse>* GetStageStateStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::StageStateResponse>* AsyncGetStageStateStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::handEngine::v1::StageStateResponse>* PrepareAsyncGetStageStateStreamRaw(::grpc::ClientContext* context, const ::handEngine::v1::BlankRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncSetRecordingStateRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncSetRecordingStateRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncSetRecordingDirectoryRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncSetRecordingDirectoryRaw(::grpc::ClientContext* context, const ::handEngine::v1::RecordingDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* AsyncSetTimecodeSourceRaw(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handEngine::v1::BlankResponse>* PrepareAsyncSetTimecodeSourceRaw(::grpc::ClientContext* context, const ::handEngine::v1::TimeCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetStageStateStream_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRecordingState_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRecordingDirectory_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTimecodeSource_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // *
    // Gets a stream of the stage state to aid in syncronisation with other
    // applications. Not implemented yet.
    virtual ::grpc::Status GetStageStateStream(::grpc::ServerContext* context, const ::handEngine::v1::BlankRequest* request, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* writer);
    // *
    // Set the current recording state and take name for the staged performers. This
    // will record data for all performers, regardless of their glove devices being
    // connected or not.
    //
    // Data is saved to a datestamped folder with a child folder labelled with the
    // take name. The take folder location is defined by a request to
    // `SetRecordingDirectory()`.
    //
    // The following files will be saved:
    //
    // (`PERFORMER_NAME` is the name of the performer and where XXXX is the
    // `performerId` incremented by 1 and `L` or `R` to indicate handedness. E.g `P1L`)
    //
    // * `Cal_PXXXX_PERFORMER_NAME.json` - The performer's calibration file.
    // * `PXXXXFullBody_PERFORMER_NAME.fbx`- An output of the captured hands on a full
    //    skeleton to be compatible with various animation software.
    // * `PXXXX_PERFORMER_NAME.csv`- A raw comma seperated output of the captured
    //    hand as just the hand skeleton joints, with the wrist being the root bone.
    //    Useful when writing custom tooling to process animation data in your pipeline.
    // * `PXXXX_PERFORMER_NAME.fbx`- An FBX output of the captured hand as just the
    //    hand skeleton joints, with the wrist being the root bone. Compatible with
    //    various animation software.
    // * `PXXXX_PERFORMER_NAMEMeta.json` - Metadata associated with the take in the
    //    following example JSON format:
    //
    // #### PXXXX_PERFORMER_NAMEMeta.json Example
    //
    // ```
    // {
    //    "source": "HE",
    //    "hash": "z0GhHN0uur5lXQeIjpVx7mOV5eeME9C872E72DC4",
    //    "takeName": "Take_0001",
    //    "startDate": "2022-08-09",
    //    "startTime": "01-31-34-230-pm",
    //    "performerName": "PERFORMER_NAME",
    //    "performerNumber": 0,
    //    "profileName": "default-left",
    //    "calibrationId": 0,
    //    "side": "Left",
    //    "gloveType": "RevF",
    //    "gloveSN": "00000139",
    //    "gloveFW": "01.00.00",
    //    "dongleFW": "01.01.04",
    //    "fileName": "PXXXX_PERFORMER_NAME.csv",
    //    "outputType": "express",
    //    "masterTimeCodeSource": "System",
    //    "fpsRate": 60
    // }
    // ```
    virtual ::grpc::Status SetRecordingState(::grpc::ServerContext* context, const ::handEngine::v1::RecordingStateRequest* request, ::handEngine::v1::BlankResponse* response);
    // *
    // Sets the recording directory where animation takes will be saved to disk. The
    // currently logged in Windows user will need write permissions to this folder,
    // so you may need to double check this if setting it to a network drive or if
    // the user has any kind of device management profile applied to it which
    // could prevent writing to certain folders on the computer. On Windows, the user's
    // `Documents` folder is a safe recommended location.
    virtual ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* context, const ::handEngine::v1::RecordingDirectoryRequest* request, ::handEngine::v1::BlankResponse* response);
    // *
    // Sets the source for timecode syncing, so Hand Engine's timecode can remain in sync
    // with an external system.
    //
    // The `framerate` value defined here will affect the rate at which the call to
    // [GetAllHandAnimationStream](#getallhandanimationstream) will send back data
    // on the current pose of each tracked glove device. Larger values will consume more
    // resources when sent to your application via the SDK.
    virtual ::grpc::Status SetTimecodeSource(::grpc::ServerContext* context, const ::handEngine::v1::TimeCodeRequest* request, ::handEngine::v1::BlankResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStageStateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStageStateStream() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetStageStateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStageStateStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStageStateStream(::grpc::ServerContext* context, ::handEngine::v1::BlankRequest* request, ::grpc::ServerAsyncWriter< ::handEngine::v1::StageStateResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRecordingState() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingState(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRecordingState(::grpc::ServerContext* context, ::handEngine::v1::RecordingStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRecordingDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRecordingDirectory() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetRecordingDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRecordingDirectory(::grpc::ServerContext* context, ::handEngine::v1::RecordingDirectoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTimecodeSource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTimecodeSource() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetTimecodeSource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTimecodeSource(::grpc::ServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTimecodeSource(::grpc::ServerContext* context, ::handEngine::v1::TimeCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::handEngine::v1::BlankResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetStageStateStream<WithAsyncMethod_SetRecordingState<WithAsyncMethod_SetRecordingDirectory<WithAsyncMethod_SetTimecodeSource<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetStageStateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStageStateStream() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::handEngine::v1::BlankRequest, ::handEngine::v1::StageStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::BlankRequest* request) { return this->GetStageStateStream(context, request); }));
    }
    ~WithCallbackMethod_GetStageStateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStageStateStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::handEngine::v1::StageStateResponse>* GetStageStateStream(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRecordingState() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::RecordingStateRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::RecordingStateRequest* request, ::handEngine::v1::BlankResponse* response) { return this->SetRecordingState(context, request, response); }));}
    void SetMessageAllocatorFor_SetRecordingState(
        ::grpc::MessageAllocator< ::handEngine::v1::RecordingStateRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::RecordingStateRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingState(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRecordingState(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRecordingDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRecordingDirectory() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::RecordingDirectoryRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::RecordingDirectoryRequest* request, ::handEngine::v1::BlankResponse* response) { return this->SetRecordingDirectory(context, request, response); }));}
    void SetMessageAllocatorFor_SetRecordingDirectory(
        ::grpc::MessageAllocator< ::handEngine::v1::RecordingDirectoryRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::RecordingDirectoryRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRecordingDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRecordingDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTimecodeSource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTimecodeSource() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::TimeCodeRequest, ::handEngine::v1::BlankResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::handEngine::v1::TimeCodeRequest* request, ::handEngine::v1::BlankResponse* response) { return this->SetTimecodeSource(context, request, response); }));}
    void SetMessageAllocatorFor_SetTimecodeSource(
        ::grpc::MessageAllocator< ::handEngine::v1::TimeCodeRequest, ::handEngine::v1::BlankResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handEngine::v1::TimeCodeRequest, ::handEngine::v1::BlankResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTimecodeSource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTimecodeSource(::grpc::ServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTimecodeSource(
      ::grpc::CallbackServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetStageStateStream<WithCallbackMethod_SetRecordingState<WithCallbackMethod_SetRecordingDirectory<WithCallbackMethod_SetTimecodeSource<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetStageStateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStageStateStream() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetStageStateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStageStateStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRecordingState() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingState(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRecordingDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRecordingDirectory() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetRecordingDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTimecodeSource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTimecodeSource() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetTimecodeSource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTimecodeSource(::grpc::ServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStageStateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStageStateStream() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetStageStateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStageStateStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStageStateStream(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRecordingState() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SetRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingState(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRecordingState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRecordingDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRecordingDirectory() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetRecordingDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRecordingDirectory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTimecodeSource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTimecodeSource() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SetTimecodeSource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTimecodeSource(::grpc::ServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTimecodeSource(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStageStateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStageStateStream() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetStageStateStream(context, request); }));
    }
    ~WithRawCallbackMethod_GetStageStateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStageStateStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetStageStateStream(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRecordingState() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRecordingState(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingState(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRecordingState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRecordingDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRecordingDirectory() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRecordingDirectory(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRecordingDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRecordingDirectory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTimecodeSource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTimecodeSource() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTimecodeSource(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTimecodeSource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTimecodeSource(::grpc::ServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTimecodeSource(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRecordingState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRecordingState() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::RecordingStateRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::RecordingStateRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedSetRecordingState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRecordingState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRecordingState(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingStateRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRecordingState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::RecordingStateRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRecordingDirectory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRecordingDirectory() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::RecordingDirectoryRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::RecordingDirectoryRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedSetRecordingDirectory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRecordingDirectory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRecordingDirectory(::grpc::ServerContext* /*context*/, const ::handEngine::v1::RecordingDirectoryRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRecordingDirectory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::RecordingDirectoryRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTimecodeSource : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTimecodeSource() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::handEngine::v1::TimeCodeRequest, ::handEngine::v1::BlankResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::handEngine::v1::TimeCodeRequest, ::handEngine::v1::BlankResponse>* streamer) {
                       return this->StreamedSetTimecodeSource(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTimecodeSource() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTimecodeSource(::grpc::ServerContext* /*context*/, const ::handEngine::v1::TimeCodeRequest* /*request*/, ::handEngine::v1::BlankResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTimecodeSource(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handEngine::v1::TimeCodeRequest,::handEngine::v1::BlankResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetRecordingState<WithStreamedUnaryMethod_SetRecordingDirectory<WithStreamedUnaryMethod_SetTimecodeSource<Service > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetStageStateStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetStageStateStream() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::handEngine::v1::BlankRequest, ::handEngine::v1::StageStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::handEngine::v1::BlankRequest, ::handEngine::v1::StageStateResponse>* streamer) {
                       return this->StreamedGetStageStateStream(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetStageStateStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStageStateStream(::grpc::ServerContext* /*context*/, const ::handEngine::v1::BlankRequest* /*request*/, ::grpc::ServerWriter< ::handEngine::v1::StageStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetStageStateStream(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::handEngine::v1::BlankRequest,::handEngine::v1::StageStateResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetStageStateStream<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_GetStageStateStream<WithStreamedUnaryMethod_SetRecordingState<WithStreamedUnaryMethod_SetRecordingDirectory<WithStreamedUnaryMethod_SetTimecodeSource<Service > > > > StreamedService;
};

}  // namespace v1
}  // namespace handEngine


#endif  // GRPC_v1_2fstage_2eproto__INCLUDED


