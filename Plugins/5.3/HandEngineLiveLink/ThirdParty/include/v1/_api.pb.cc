// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/_api.proto
#include "EnableGrpcIncludes.h"
#include "v1/_api.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
#include "DisableGrpcIncludes.h"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace handEngine {
namespace v1 {
template <typename>
PROTOBUF_CONSTEXPR BlankRequest::BlankRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct BlankRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlankRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlankRequestDefaultTypeInternal() {}
  union {
    BlankRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlankRequestDefaultTypeInternal _BlankRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ProfileMeta::ProfileMeta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.performerid_)*/ 0

  , /*decltype(_impl_.handedness_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProfileMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProfileMetaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProfileMetaDefaultTypeInternal() {}
  union {
    ProfileMeta _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileMetaDefaultTypeInternal _ProfileMeta_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GloveInformationResponse::GloveInformationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.serialnumber_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.gloveid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.glovefirmware_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.donglefirmware_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.gloverevision_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.batterylevel_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GloveInformationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GloveInformationResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GloveInformationResponseDefaultTypeInternal() {}
  union {
    GloveInformationResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GloveInformationResponseDefaultTypeInternal _GloveInformationResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BlankResponse::BlankResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct BlankResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlankResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlankResponseDefaultTypeInternal() {}
  union {
    BlankResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlankResponseDefaultTypeInternal _BlankResponse_default_instance_;
}  // namespace v1
}  // namespace handEngine
namespace handEngine {
namespace v1 {
bool Handedness_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    Handedness_strings[2] = {};

static const char Handedness_names[] = {
    "LEFT"
    "RIGHT"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Handedness_entries[] =
    {
        {{&Handedness_names[0], 4}, 0},
        {{&Handedness_names[4], 5}, 1},
};

static const int Handedness_entries_by_number[] = {
    0,  // 0 -> LEFT
    1,  // 1 -> RIGHT
};

const std::string& Handedness_Name(Handedness value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Handedness_entries, Handedness_entries_by_number,
          2, Handedness_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Handedness_entries, Handedness_entries_by_number, 2,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : Handedness_strings[idx].get();
}

bool Handedness_Parse(absl::string_view name, Handedness* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Handedness_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Handedness>(int_value);
  }
  return success;
}
bool TimecodeSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    TimecodeSource_strings[3] = {};

static const char TimecodeSource_names[] = {
    "OPTITRACK"
    "SYSTEM_CLOCK"
    "VICON"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TimecodeSource_entries[] =
    {
        {{&TimecodeSource_names[0], 9}, 2},
        {{&TimecodeSource_names[9], 12}, 0},
        {{&TimecodeSource_names[21], 5}, 1},
};

static const int TimecodeSource_entries_by_number[] = {
    1,  // 0 -> SYSTEM_CLOCK
    2,  // 1 -> VICON
    0,  // 2 -> OPTITRACK
};

const std::string& TimecodeSource_Name(TimecodeSource value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TimecodeSource_entries, TimecodeSource_entries_by_number,
          3, TimecodeSource_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TimecodeSource_entries, TimecodeSource_entries_by_number, 3,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : TimecodeSource_strings[idx].get();
}

bool TimecodeSource_Parse(absl::string_view name, TimecodeSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TimecodeSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TimecodeSource>(int_value);
  }
  return success;
}
bool FrameRate_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    FrameRate_strings[5] = {};

static const char FrameRate_names[] = {
    "FPS_120"
    "FPS_24"
    "FPS_25"
    "FPS_30"
    "FPS_50"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FrameRate_entries[] =
    {
        {{&FrameRate_names[0], 7}, 4},
        {{&FrameRate_names[7], 6}, 0},
        {{&FrameRate_names[13], 6}, 1},
        {{&FrameRate_names[19], 6}, 2},
        {{&FrameRate_names[25], 6}, 3},
};

static const int FrameRate_entries_by_number[] = {
    1,  // 0 -> FPS_24
    2,  // 1 -> FPS_25
    3,  // 2 -> FPS_30
    4,  // 3 -> FPS_50
    0,  // 4 -> FPS_120
};

const std::string& FrameRate_Name(FrameRate value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FrameRate_entries, FrameRate_entries_by_number,
          5, FrameRate_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FrameRate_entries, FrameRate_entries_by_number, 5,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : FrameRate_strings[idx].get();
}

bool FrameRate_Parse(absl::string_view name, FrameRate* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FrameRate_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<FrameRate>(int_value);
  }
  return success;
}
bool Cast_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    Cast_strings[2] = {};

static const char Cast_names[] = {
    "MULTICAST"
    "UNICAST"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Cast_entries[] =
    {
        {{&Cast_names[0], 9}, 1},
        {{&Cast_names[9], 7}, 0},
};

static const int Cast_entries_by_number[] = {
    1,  // 0 -> UNICAST
    0,  // 1 -> MULTICAST
};

const std::string& Cast_Name(Cast value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Cast_entries, Cast_entries_by_number,
          2, Cast_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Cast_entries, Cast_entries_by_number, 2,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : Cast_strings[idx].get();
}

bool Cast_Parse(absl::string_view name, Cast* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Cast_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Cast>(int_value);
  }
  return success;
}
bool SmartPose_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    SmartPose_strings[7] = {};

static const char SmartPose_names[] = {
    "FIST"
    "PADDLE"
    "PEACE"
    "REACH"
    "THUMB_OUT"
    "THUMB_UP"
    "TUNNEL"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SmartPose_entries[] =
    {
        {{&SmartPose_names[0], 4}, 0},
        {{&SmartPose_names[4], 6}, 1},
        {{&SmartPose_names[10], 5}, 2},
        {{&SmartPose_names[15], 5}, 3},
        {{&SmartPose_names[20], 9}, 5},
        {{&SmartPose_names[29], 8}, 4},
        {{&SmartPose_names[37], 6}, 6},
};

static const int SmartPose_entries_by_number[] = {
    0,  // 0 -> FIST
    1,  // 1 -> PADDLE
    2,  // 2 -> PEACE
    3,  // 3 -> REACH
    5,  // 4 -> THUMB_UP
    4,  // 5 -> THUMB_OUT
    6,  // 6 -> TUNNEL
};

const std::string& SmartPose_Name(SmartPose value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SmartPose_entries, SmartPose_entries_by_number,
          7, SmartPose_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SmartPose_entries, SmartPose_entries_by_number, 7,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : SmartPose_strings[idx].get();
}

bool SmartPose_Parse(absl::string_view name, SmartPose* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SmartPose_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<SmartPose>(int_value);
  }
  return success;
}
bool HapticPattern_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    HapticPattern_strings[124] = {};

static const char HapticPattern_names[] = {
    "ALERT_1000_MS_100"
    "ALERT_750_MS_100"
    "BUZZ_1_100"
    "BUZZ_2_80"
    "BUZZ_3_60"
    "BUZZ_4_40"
    "BUZZ_5_20"
    "DOUBLE_CLICK_100"
    "DOUBLE_CLICK_60"
    "LONG_BUZZ_FOR_PROGRAMMATIC_STOPPING_100"
    "LONG_DOUBLE_SHARP_CLICK_MEDIUM_1_100"
    "LONG_DOUBLE_SHARP_CLICK_MEDIUM_2_80"
    "LONG_DOUBLE_SHARP_CLICK_MEDIUM_3_60"
    "LONG_DOUBLE_SHARP_CLICK_STRONG_1_100"
    "LONG_DOUBLE_SHARP_CLICK_STRONG_2_80"
    "LONG_DOUBLE_SHARP_CLICK_STRONG_3_60"
    "LONG_DOUBLE_SHARP_CLICK_STRONG_4_30"
    "LONG_DOUBLE_SHARP_TICK_1_100"
    "LONG_DOUBLE_SHARP_TICK_2_80"
    "LONG_DOUBLE_SHARP_TICK_3_60"
    "MEDIUM_CLICK_1_100"
    "MEDIUM_CLICK_2_80"
    "MEDIUM_CLICK_3_60"
    "PULSING_MEDIUM_1_100"
    "PULSING_MEDIUM_2_60"
    "PULSING_SHARP_1_100"
    "PULSING_SHARP_2_60"
    "PULSING_STRONG_1_100"
    "PULSING_STRONG_2_60"
    "SHARP_CLICK_100"
    "SHARP_CLICK_30"
    "SHARP_CLICK_60"
    "SHARP_TICK_1_100"
    "SHARP_TICK_2_80"
    "SHARP_TICK_3_60"
    "SHORT_DOUBLE_CLICK_MEDIUM_1_100"
    "SHORT_DOUBLE_CLICK_MEDIUM_2_80"
    "SHORT_DOUBLE_CLICK_MEDIUM_3_60"
    "SHORT_DOUBLE_CLICK_STRONG_1_100"
    "SHORT_DOUBLE_CLICK_STRONG_2_80"
    "SHORT_DOUBLE_CLICK_STRONG_3_60"
    "SHORT_DOUBLE_CLICK_STRONG_4_30"
    "SHORT_DOUBLE_SHARP_TICK_1_100"
    "SHORT_DOUBLE_SHARP_TICK_2_80"
    "SHORT_DOUBLE_SHARP_TICK_3_60"
    "SMOOTH_HUM_1_50"
    "SMOOTH_HUM_2_40"
    "SMOOTH_HUM_3_30"
    "SMOOTH_HUM_4_20"
    "SMOOTH_HUM_5_10"
    "SOFT_BUMP_100"
    "SOFT_BUMP_30"
    "SOFT_BUMP_60"
    "SOFT_FUZZ_60"
    "STRONG_BUZZ_100"
    "STRONG_CLICK_100"
    "STRONG_CLICK_1_100"
    "STRONG_CLICK_2_80"
    "STRONG_CLICK_30"
    "STRONG_CLICK_3_60"
    "STRONG_CLICK_4_30"
    "STRONG_CLICK_60"
    "TRANSITION_CLICK_1_100"
    "TRANSITION_CLICK_2_80"
    "TRANSITION_CLICK_3_60"
    "TRANSITION_CLICK_4_40"
    "TRANSITION_CLICK_5_20"
    "TRANSITION_CLICK_6_10"
    "TRANSITION_HUM_1_100"
    "TRANSITION_HUM_2_80"
    "TRANSITION_HUM_3_60"
    "TRANSITION_HUM_4_40"
    "TRANSITION_HUM_5_20"
    "TRANSITION_HUM_6_10"
    "TRANSITION_RAMP_DOWN_LONG_SHARP_1_100_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SHARP_1_50_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SHARP_2_100_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SHARP_2_50_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SMOOTH_1_100_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SMOOTH_1_50_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SMOOTH_2_100_TO_0"
    "TRANSITION_RAMP_DOWN_LONG_SMOOTH_2_50_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SHARP_1_100_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SHARP_1_50_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SHARP_2_100_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SHARP_2_50_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_1_100_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_1_50_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_2_100_TO_0"
    "TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_2_50_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SHARP_1_100_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SHARP_1_50_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SHARP_2_100_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SHARP_2_50_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SMOOTH_1_100_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SMOOTH_1_50_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SMOOTH_2_100_TO_0"
    "TRANSITION_RAMP_DOWN_SHORT_SMOOTH_2_50_TO_0"
    "TRANSITION_RAMP_UP_LONG_SHARP_1_0_TO_100"
    "TRANSITION_RAMP_UP_LONG_SHARP_1_0_TO_50"
    "TRANSITION_RAMP_UP_LONG_SHARP_2_0_TO_100"
    "TRANSITION_RAMP_UP_LONG_SHARP_2_0_TO_50"
    "TRANSITION_RAMP_UP_LONG_SMOOTH_1_0_TO_100"
    "TRANSITION_RAMP_UP_LONG_SMOOTH_1_0_TO_50"
    "TRANSITION_RAMP_UP_LONG_SMOOTH_2_0_TO_100"
    "TRANSITION_RAMP_UP_LONG_SMOOTH_2_0_TO_50"
    "TRANSITION_RAMP_UP_MEDIUM_SHARP_1_0_TO_100"
    "TRANSITION_RAMP_UP_MEDIUM_SHARP_1_0_TO_50"
    "TRANSITION_RAMP_UP_MEDIUM_SHARP_2_0_TO_100"
    "TRANSITION_RAMP_UP_MEDIUM_SHARP_2_0_TO_50"
    "TRANSITION_RAMP_UP_MEDIUM_SMOOTH_1_0_TO_100"
    "TRANSITION_RAMP_UP_MEDIUM_SMOOTH_1_0_TO_50"
    "TRANSITION_RAMP_UP_MEDIUM_SMOOTH_2_0_TO_100"
    "TRANSITION_RAMP_UP_MEDIUM_SMOOTH_2_0_TO_50"
    "TRANSITION_RAMP_UP_SHORT_SHARP_1_0_TO_100"
    "TRANSITION_RAMP_UP_SHORT_SHARP_1_0_TO_50"
    "TRANSITION_RAMP_UP_SHORT_SHARP_2_0_TO_100"
    "TRANSITION_RAMP_UP_SHORT_SHARP_2_0_TO_50"
    "TRANSITION_RAMP_UP_SHORT_SMOOTH_1_0_TO_100"
    "TRANSITION_RAMP_UP_SHORT_SMOOTH_1_0_TO_50"
    "TRANSITION_RAMP_UP_SHORT_SMOOTH_2_0_TO_100"
    "TRANSITION_RAMP_UP_SHORT_SMOOTH_2_0_TO_50"
    "TRIPLE_CLICK_100"
    "UNKNOWN"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HapticPattern_entries[] =
    {
        {{&HapticPattern_names[0], 17}, 16},
        {{&HapticPattern_names[17], 16}, 15},
        {{&HapticPattern_names[33], 10}, 47},
        {{&HapticPattern_names[43], 9}, 48},
        {{&HapticPattern_names[52], 9}, 49},
        {{&HapticPattern_names[61], 9}, 50},
        {{&HapticPattern_names[70], 9}, 51},
        {{&HapticPattern_names[79], 16}, 10},
        {{&HapticPattern_names[95], 15}, 11},
        {{&HapticPattern_names[110], 39}, 118},
        {{&HapticPattern_names[149], 36}, 41},
        {{&HapticPattern_names[185], 35}, 42},
        {{&HapticPattern_names[220], 35}, 43},
        {{&HapticPattern_names[255], 36}, 37},
        {{&HapticPattern_names[291], 35}, 38},
        {{&HapticPattern_names[326], 35}, 39},
        {{&HapticPattern_names[361], 35}, 40},
        {{&HapticPattern_names[396], 28}, 44},
        {{&HapticPattern_names[424], 27}, 45},
        {{&HapticPattern_names[451], 27}, 46},
        {{&HapticPattern_names[478], 18}, 21},
        {{&HapticPattern_names[496], 17}, 22},
        {{&HapticPattern_names[513], 17}, 23},
        {{&HapticPattern_names[530], 20}, 54},
        {{&HapticPattern_names[550], 19}, 55},
        {{&HapticPattern_names[569], 19}, 56},
        {{&HapticPattern_names[588], 18}, 57},
        {{&HapticPattern_names[606], 20}, 52},
        {{&HapticPattern_names[626], 19}, 53},
        {{&HapticPattern_names[645], 15}, 4},
        {{&HapticPattern_names[660], 14}, 6},
        {{&HapticPattern_names[674], 14}, 5},
        {{&HapticPattern_names[688], 16}, 24},
        {{&HapticPattern_names[704], 15}, 25},
        {{&HapticPattern_names[719], 15}, 26},
        {{&HapticPattern_names[734], 31}, 31},
        {{&HapticPattern_names[765], 30}, 32},
        {{&HapticPattern_names[795], 30}, 33},
        {{&HapticPattern_names[825], 31}, 27},
        {{&HapticPattern_names[856], 30}, 28},
        {{&HapticPattern_names[886], 30}, 29},
        {{&HapticPattern_names[916], 30}, 30},
        {{&HapticPattern_names[946], 29}, 34},
        {{&HapticPattern_names[975], 28}, 35},
        {{&HapticPattern_names[1003], 28}, 36},
        {{&HapticPattern_names[1031], 15}, 119},
        {{&HapticPattern_names[1046], 15}, 120},
        {{&HapticPattern_names[1061], 15}, 121},
        {{&HapticPattern_names[1076], 15}, 122},
        {{&HapticPattern_names[1091], 15}, 123},
        {{&HapticPattern_names[1106], 13}, 7},
        {{&HapticPattern_names[1119], 12}, 9},
        {{&HapticPattern_names[1131], 12}, 8},
        {{&HapticPattern_names[1143], 12}, 13},
        {{&HapticPattern_names[1155], 15}, 14},
        {{&HapticPattern_names[1170], 16}, 1},
        {{&HapticPattern_names[1186], 18}, 17},
        {{&HapticPattern_names[1204], 17}, 18},
        {{&HapticPattern_names[1221], 15}, 3},
        {{&HapticPattern_names[1236], 17}, 19},
        {{&HapticPattern_names[1253], 17}, 20},
        {{&HapticPattern_names[1270], 15}, 2},
        {{&HapticPattern_names[1285], 22}, 58},
        {{&HapticPattern_names[1307], 21}, 59},
        {{&HapticPattern_names[1328], 21}, 60},
        {{&HapticPattern_names[1349], 21}, 61},
        {{&HapticPattern_names[1370], 21}, 62},
        {{&HapticPattern_names[1391], 21}, 63},
        {{&HapticPattern_names[1412], 20}, 64},
        {{&HapticPattern_names[1432], 19}, 65},
        {{&HapticPattern_names[1451], 19}, 66},
        {{&HapticPattern_names[1470], 19}, 67},
        {{&HapticPattern_names[1489], 19}, 68},
        {{&HapticPattern_names[1508], 19}, 69},
        {{&HapticPattern_names[1527], 42}, 76},
        {{&HapticPattern_names[1569], 41}, 100},
        {{&HapticPattern_names[1610], 42}, 77},
        {{&HapticPattern_names[1652], 41}, 101},
        {{&HapticPattern_names[1693], 43}, 70},
        {{&HapticPattern_names[1736], 42}, 94},
        {{&HapticPattern_names[1778], 43}, 71},
        {{&HapticPattern_names[1821], 42}, 95},
        {{&HapticPattern_names[1863], 44}, 78},
        {{&HapticPattern_names[1907], 43}, 102},
        {{&HapticPattern_names[1950], 44}, 79},
        {{&HapticPattern_names[1994], 43}, 103},
        {{&HapticPattern_names[2037], 45}, 72},
        {{&HapticPattern_names[2082], 44}, 96},
        {{&HapticPattern_names[2126], 45}, 73},
        {{&HapticPattern_names[2171], 44}, 97},
        {{&HapticPattern_names[2215], 43}, 80},
        {{&HapticPattern_names[2258], 42}, 104},
        {{&HapticPattern_names[2300], 43}, 81},
        {{&HapticPattern_names[2343], 42}, 105},
        {{&HapticPattern_names[2385], 44}, 74},
        {{&HapticPattern_names[2429], 43}, 98},
        {{&HapticPattern_names[2472], 44}, 75},
        {{&HapticPattern_names[2516], 43}, 99},
        {{&HapticPattern_names[2559], 40}, 88},
        {{&HapticPattern_names[2599], 39}, 112},
        {{&HapticPattern_names[2638], 40}, 89},
        {{&HapticPattern_names[2678], 39}, 113},
        {{&HapticPattern_names[2717], 41}, 82},
        {{&HapticPattern_names[2758], 40}, 106},
        {{&HapticPattern_names[2798], 41}, 83},
        {{&HapticPattern_names[2839], 40}, 107},
        {{&HapticPattern_names[2879], 42}, 90},
        {{&HapticPattern_names[2921], 41}, 114},
        {{&HapticPattern_names[2962], 42}, 91},
        {{&HapticPattern_names[3004], 41}, 115},
        {{&HapticPattern_names[3045], 43}, 84},
        {{&HapticPattern_names[3088], 42}, 108},
        {{&HapticPattern_names[3130], 43}, 85},
        {{&HapticPattern_names[3173], 42}, 109},
        {{&HapticPattern_names[3215], 41}, 92},
        {{&HapticPattern_names[3256], 40}, 116},
        {{&HapticPattern_names[3296], 41}, 93},
        {{&HapticPattern_names[3337], 40}, 117},
        {{&HapticPattern_names[3377], 42}, 86},
        {{&HapticPattern_names[3419], 41}, 110},
        {{&HapticPattern_names[3460], 42}, 87},
        {{&HapticPattern_names[3502], 41}, 111},
        {{&HapticPattern_names[3543], 16}, 12},
        {{&HapticPattern_names[3559], 7}, 0},
};

static const int HapticPattern_entries_by_number[] = {
    123,  // 0 -> UNKNOWN
    55,  // 1 -> STRONG_CLICK_100
    61,  // 2 -> STRONG_CLICK_60
    58,  // 3 -> STRONG_CLICK_30
    29,  // 4 -> SHARP_CLICK_100
    31,  // 5 -> SHARP_CLICK_60
    30,  // 6 -> SHARP_CLICK_30
    50,  // 7 -> SOFT_BUMP_100
    52,  // 8 -> SOFT_BUMP_60
    51,  // 9 -> SOFT_BUMP_30
    7,  // 10 -> DOUBLE_CLICK_100
    8,  // 11 -> DOUBLE_CLICK_60
    122,  // 12 -> TRIPLE_CLICK_100
    53,  // 13 -> SOFT_FUZZ_60
    54,  // 14 -> STRONG_BUZZ_100
    1,  // 15 -> ALERT_750_MS_100
    0,  // 16 -> ALERT_1000_MS_100
    56,  // 17 -> STRONG_CLICK_1_100
    57,  // 18 -> STRONG_CLICK_2_80
    59,  // 19 -> STRONG_CLICK_3_60
    60,  // 20 -> STRONG_CLICK_4_30
    20,  // 21 -> MEDIUM_CLICK_1_100
    21,  // 22 -> MEDIUM_CLICK_2_80
    22,  // 23 -> MEDIUM_CLICK_3_60
    32,  // 24 -> SHARP_TICK_1_100
    33,  // 25 -> SHARP_TICK_2_80
    34,  // 26 -> SHARP_TICK_3_60
    38,  // 27 -> SHORT_DOUBLE_CLICK_STRONG_1_100
    39,  // 28 -> SHORT_DOUBLE_CLICK_STRONG_2_80
    40,  // 29 -> SHORT_DOUBLE_CLICK_STRONG_3_60
    41,  // 30 -> SHORT_DOUBLE_CLICK_STRONG_4_30
    35,  // 31 -> SHORT_DOUBLE_CLICK_MEDIUM_1_100
    36,  // 32 -> SHORT_DOUBLE_CLICK_MEDIUM_2_80
    37,  // 33 -> SHORT_DOUBLE_CLICK_MEDIUM_3_60
    42,  // 34 -> SHORT_DOUBLE_SHARP_TICK_1_100
    43,  // 35 -> SHORT_DOUBLE_SHARP_TICK_2_80
    44,  // 36 -> SHORT_DOUBLE_SHARP_TICK_3_60
    13,  // 37 -> LONG_DOUBLE_SHARP_CLICK_STRONG_1_100
    14,  // 38 -> LONG_DOUBLE_SHARP_CLICK_STRONG_2_80
    15,  // 39 -> LONG_DOUBLE_SHARP_CLICK_STRONG_3_60
    16,  // 40 -> LONG_DOUBLE_SHARP_CLICK_STRONG_4_30
    10,  // 41 -> LONG_DOUBLE_SHARP_CLICK_MEDIUM_1_100
    11,  // 42 -> LONG_DOUBLE_SHARP_CLICK_MEDIUM_2_80
    12,  // 43 -> LONG_DOUBLE_SHARP_CLICK_MEDIUM_3_60
    17,  // 44 -> LONG_DOUBLE_SHARP_TICK_1_100
    18,  // 45 -> LONG_DOUBLE_SHARP_TICK_2_80
    19,  // 46 -> LONG_DOUBLE_SHARP_TICK_3_60
    2,  // 47 -> BUZZ_1_100
    3,  // 48 -> BUZZ_2_80
    4,  // 49 -> BUZZ_3_60
    5,  // 50 -> BUZZ_4_40
    6,  // 51 -> BUZZ_5_20
    27,  // 52 -> PULSING_STRONG_1_100
    28,  // 53 -> PULSING_STRONG_2_60
    23,  // 54 -> PULSING_MEDIUM_1_100
    24,  // 55 -> PULSING_MEDIUM_2_60
    25,  // 56 -> PULSING_SHARP_1_100
    26,  // 57 -> PULSING_SHARP_2_60
    62,  // 58 -> TRANSITION_CLICK_1_100
    63,  // 59 -> TRANSITION_CLICK_2_80
    64,  // 60 -> TRANSITION_CLICK_3_60
    65,  // 61 -> TRANSITION_CLICK_4_40
    66,  // 62 -> TRANSITION_CLICK_5_20
    67,  // 63 -> TRANSITION_CLICK_6_10
    68,  // 64 -> TRANSITION_HUM_1_100
    69,  // 65 -> TRANSITION_HUM_2_80
    70,  // 66 -> TRANSITION_HUM_3_60
    71,  // 67 -> TRANSITION_HUM_4_40
    72,  // 68 -> TRANSITION_HUM_5_20
    73,  // 69 -> TRANSITION_HUM_6_10
    78,  // 70 -> TRANSITION_RAMP_DOWN_LONG_SMOOTH_1_100_TO_0
    80,  // 71 -> TRANSITION_RAMP_DOWN_LONG_SMOOTH_2_100_TO_0
    86,  // 72 -> TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_1_100_TO_0
    88,  // 73 -> TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_2_100_TO_0
    94,  // 74 -> TRANSITION_RAMP_DOWN_SHORT_SMOOTH_1_100_TO_0
    96,  // 75 -> TRANSITION_RAMP_DOWN_SHORT_SMOOTH_2_100_TO_0
    74,  // 76 -> TRANSITION_RAMP_DOWN_LONG_SHARP_1_100_TO_0
    76,  // 77 -> TRANSITION_RAMP_DOWN_LONG_SHARP_2_100_TO_0
    82,  // 78 -> TRANSITION_RAMP_DOWN_MEDIUM_SHARP_1_100_TO_0
    84,  // 79 -> TRANSITION_RAMP_DOWN_MEDIUM_SHARP_2_100_TO_0
    90,  // 80 -> TRANSITION_RAMP_DOWN_SHORT_SHARP_1_100_TO_0
    92,  // 81 -> TRANSITION_RAMP_DOWN_SHORT_SHARP_2_100_TO_0
    102,  // 82 -> TRANSITION_RAMP_UP_LONG_SMOOTH_1_0_TO_100
    104,  // 83 -> TRANSITION_RAMP_UP_LONG_SMOOTH_2_0_TO_100
    110,  // 84 -> TRANSITION_RAMP_UP_MEDIUM_SMOOTH_1_0_TO_100
    112,  // 85 -> TRANSITION_RAMP_UP_MEDIUM_SMOOTH_2_0_TO_100
    118,  // 86 -> TRANSITION_RAMP_UP_SHORT_SMOOTH_1_0_TO_100
    120,  // 87 -> TRANSITION_RAMP_UP_SHORT_SMOOTH_2_0_TO_100
    98,  // 88 -> TRANSITION_RAMP_UP_LONG_SHARP_1_0_TO_100
    100,  // 89 -> TRANSITION_RAMP_UP_LONG_SHARP_2_0_TO_100
    106,  // 90 -> TRANSITION_RAMP_UP_MEDIUM_SHARP_1_0_TO_100
    108,  // 91 -> TRANSITION_RAMP_UP_MEDIUM_SHARP_2_0_TO_100
    114,  // 92 -> TRANSITION_RAMP_UP_SHORT_SHARP_1_0_TO_100
    116,  // 93 -> TRANSITION_RAMP_UP_SHORT_SHARP_2_0_TO_100
    79,  // 94 -> TRANSITION_RAMP_DOWN_LONG_SMOOTH_1_50_TO_0
    81,  // 95 -> TRANSITION_RAMP_DOWN_LONG_SMOOTH_2_50_TO_0
    87,  // 96 -> TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_1_50_TO_0
    89,  // 97 -> TRANSITION_RAMP_DOWN_MEDIUM_SMOOTH_2_50_TO_0
    95,  // 98 -> TRANSITION_RAMP_DOWN_SHORT_SMOOTH_1_50_TO_0
    97,  // 99 -> TRANSITION_RAMP_DOWN_SHORT_SMOOTH_2_50_TO_0
    75,  // 100 -> TRANSITION_RAMP_DOWN_LONG_SHARP_1_50_TO_0
    77,  // 101 -> TRANSITION_RAMP_DOWN_LONG_SHARP_2_50_TO_0
    83,  // 102 -> TRANSITION_RAMP_DOWN_MEDIUM_SHARP_1_50_TO_0
    85,  // 103 -> TRANSITION_RAMP_DOWN_MEDIUM_SHARP_2_50_TO_0
    91,  // 104 -> TRANSITION_RAMP_DOWN_SHORT_SHARP_1_50_TO_0
    93,  // 105 -> TRANSITION_RAMP_DOWN_SHORT_SHARP_2_50_TO_0
    103,  // 106 -> TRANSITION_RAMP_UP_LONG_SMOOTH_1_0_TO_50
    105,  // 107 -> TRANSITION_RAMP_UP_LONG_SMOOTH_2_0_TO_50
    111,  // 108 -> TRANSITION_RAMP_UP_MEDIUM_SMOOTH_1_0_TO_50
    113,  // 109 -> TRANSITION_RAMP_UP_MEDIUM_SMOOTH_2_0_TO_50
    119,  // 110 -> TRANSITION_RAMP_UP_SHORT_SMOOTH_1_0_TO_50
    121,  // 111 -> TRANSITION_RAMP_UP_SHORT_SMOOTH_2_0_TO_50
    99,  // 112 -> TRANSITION_RAMP_UP_LONG_SHARP_1_0_TO_50
    101,  // 113 -> TRANSITION_RAMP_UP_LONG_SHARP_2_0_TO_50
    107,  // 114 -> TRANSITION_RAMP_UP_MEDIUM_SHARP_1_0_TO_50
    109,  // 115 -> TRANSITION_RAMP_UP_MEDIUM_SHARP_2_0_TO_50
    115,  // 116 -> TRANSITION_RAMP_UP_SHORT_SHARP_1_0_TO_50
    117,  // 117 -> TRANSITION_RAMP_UP_SHORT_SHARP_2_0_TO_50
    9,  // 118 -> LONG_BUZZ_FOR_PROGRAMMATIC_STOPPING_100
    45,  // 119 -> SMOOTH_HUM_1_50
    46,  // 120 -> SMOOTH_HUM_2_40
    47,  // 121 -> SMOOTH_HUM_3_30
    48,  // 122 -> SMOOTH_HUM_4_20
    49,  // 123 -> SMOOTH_HUM_5_10
};

const std::string& HapticPattern_Name(HapticPattern value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HapticPattern_entries, HapticPattern_entries_by_number,
          124, HapticPattern_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HapticPattern_entries, HapticPattern_entries_by_number, 124,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : HapticPattern_strings[idx].get();
}

bool HapticPattern_Parse(absl::string_view name, HapticPattern* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HapticPattern_entries, 124, name, &int_value);
  if (success) {
    *value = static_cast<HapticPattern>(int_value);
  }
  return success;
}
// ===================================================================

class BlankRequest::_Internal {
 public:
};

BlankRequest::BlankRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.BlankRequest)
}
BlankRequest::BlankRequest(const BlankRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.BlankRequest)
}

inline void BlankRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

BlankRequest::~BlankRequest() {
  // @@protoc_insertion_point(destructor:handEngine.v1.BlankRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlankRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void BlankRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlankRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.BlankRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BlankRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BlankRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.BlankRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.BlankRequest)
  return target;
}

::size_t BlankRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.BlankRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlankRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BlankRequest*>(
      &from));
}

void BlankRequest::MergeFrom(const BlankRequest& from) {
  BlankRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.BlankRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BlankRequest::CopyFrom(const BlankRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.BlankRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlankRequest::IsInitialized() const {
  return true;
}

void BlankRequest::InternalSwap(BlankRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BlankRequest::GetTypeName() const {
  return "handEngine.v1.BlankRequest";
}

// ===================================================================

class ProfileMeta::_Internal {
 public:
};

ProfileMeta::ProfileMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.ProfileMeta)
}
ProfileMeta::ProfileMeta(const ProfileMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.ProfileMeta)
}

inline void ProfileMeta::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.performerid_) { 0 }

    , decltype(_impl_.handedness_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProfileMeta::~ProfileMeta() {
  // @@protoc_insertion_point(destructor:handEngine.v1.ProfileMeta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProfileMeta::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProfileMeta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProfileMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.ProfileMeta)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.performerid_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.handedness_) -
      reinterpret_cast<char*>(&_impl_.performerid_)) + sizeof(_impl_.handedness_));
  _internal_metadata_.Clear<std::string>();
}

const char* ProfileMeta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 performerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.performerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .handEngine.v1.Handedness handedness = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_handedness(static_cast<::handEngine::v1::Handedness>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProfileMeta::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.ProfileMeta)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 performerId = 1;
  if (this->_internal_performerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_performerid(), target);
  }

  // .handEngine.v1.Handedness handedness = 2;
  if (this->_internal_handedness() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_handedness(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.ProfileMeta)
  return target;
}

::size_t ProfileMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.ProfileMeta)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 performerId = 1;
  if (this->_internal_performerid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_performerid());
  }

  // .handEngine.v1.Handedness handedness = 2;
  if (this->_internal_handedness() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_handedness());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProfileMeta::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProfileMeta*>(
      &from));
}

void ProfileMeta::MergeFrom(const ProfileMeta& from) {
  ProfileMeta* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.ProfileMeta)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_performerid() != 0) {
    _this->_internal_set_performerid(from._internal_performerid());
  }
  if (from._internal_handedness() != 0) {
    _this->_internal_set_handedness(from._internal_handedness());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProfileMeta::CopyFrom(const ProfileMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.ProfileMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileMeta::IsInitialized() const {
  return true;
}

void ProfileMeta::InternalSwap(ProfileMeta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProfileMeta, _impl_.handedness_)
      + sizeof(ProfileMeta::_impl_.handedness_)
      - PROTOBUF_FIELD_OFFSET(ProfileMeta, _impl_.performerid_)>(
          reinterpret_cast<char*>(&_impl_.performerid_),
          reinterpret_cast<char*>(&other->_impl_.performerid_));
}

std::string ProfileMeta::GetTypeName() const {
  return "handEngine.v1.ProfileMeta";
}

// ===================================================================

class GloveInformationResponse::_Internal {
 public:
};

GloveInformationResponse::GloveInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.GloveInformationResponse)
}
GloveInformationResponse::GloveInformationResponse(const GloveInformationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GloveInformationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.serialnumber_) {}

    , decltype(_impl_.gloveid_) {}

    , decltype(_impl_.glovefirmware_) {}

    , decltype(_impl_.donglefirmware_) {}

    , decltype(_impl_.gloverevision_) {}

    , decltype(_impl_.batterylevel_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.serialnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.serialnumber_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serialnumber().empty()) {
    _this->_impl_.serialnumber_.Set(from._internal_serialnumber(), _this->GetArenaForAllocation());
  }
  _impl_.gloveid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.gloveid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gloveid().empty()) {
    _this->_impl_.gloveid_.Set(from._internal_gloveid(), _this->GetArenaForAllocation());
  }
  _impl_.glovefirmware_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.glovefirmware_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_glovefirmware().empty()) {
    _this->_impl_.glovefirmware_.Set(from._internal_glovefirmware(), _this->GetArenaForAllocation());
  }
  _impl_.donglefirmware_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.donglefirmware_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_donglefirmware().empty()) {
    _this->_impl_.donglefirmware_.Set(from._internal_donglefirmware(), _this->GetArenaForAllocation());
  }
  _impl_.gloverevision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.gloverevision_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gloverevision().empty()) {
    _this->_impl_.gloverevision_.Set(from._internal_gloverevision(), _this->GetArenaForAllocation());
  }
  _this->_impl_.batterylevel_ = from._impl_.batterylevel_;
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.GloveInformationResponse)
}

inline void GloveInformationResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.serialnumber_) {}

    , decltype(_impl_.gloveid_) {}

    , decltype(_impl_.glovefirmware_) {}

    , decltype(_impl_.donglefirmware_) {}

    , decltype(_impl_.gloverevision_) {}

    , decltype(_impl_.batterylevel_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.serialnumber_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.serialnumber_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gloveid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.gloveid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.glovefirmware_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.glovefirmware_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.donglefirmware_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.donglefirmware_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gloverevision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.gloverevision_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GloveInformationResponse::~GloveInformationResponse() {
  // @@protoc_insertion_point(destructor:handEngine.v1.GloveInformationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GloveInformationResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serialnumber_.Destroy();
  _impl_.gloveid_.Destroy();
  _impl_.glovefirmware_.Destroy();
  _impl_.donglefirmware_.Destroy();
  _impl_.gloverevision_.Destroy();
}

void GloveInformationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GloveInformationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.GloveInformationResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serialnumber_.ClearToEmpty();
  _impl_.gloveid_.ClearToEmpty();
  _impl_.glovefirmware_.ClearToEmpty();
  _impl_.donglefirmware_.ClearToEmpty();
  _impl_.gloverevision_.ClearToEmpty();
  _impl_.batterylevel_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* GloveInformationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string serialNumber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serialnumber();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string gloveId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_gloveid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string gloveFirmware = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_glovefirmware();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string dongleFirmware = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_donglefirmware();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string gloveRevision = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gloverevision();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // float batteryLevel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.batterylevel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GloveInformationResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.GloveInformationResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string serialNumber = 1;
  if (!this->_internal_serialnumber().empty()) {
    const std::string& _s = this->_internal_serialnumber();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.GloveInformationResponse.serialNumber");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string gloveId = 2;
  if (!this->_internal_gloveid().empty()) {
    const std::string& _s = this->_internal_gloveid();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.GloveInformationResponse.gloveId");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string gloveFirmware = 3;
  if (!this->_internal_glovefirmware().empty()) {
    const std::string& _s = this->_internal_glovefirmware();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.GloveInformationResponse.gloveFirmware");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string dongleFirmware = 4;
  if (!this->_internal_donglefirmware().empty()) {
    const std::string& _s = this->_internal_donglefirmware();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.GloveInformationResponse.dongleFirmware");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string gloveRevision = 5;
  if (!this->_internal_gloverevision().empty()) {
    const std::string& _s = this->_internal_gloverevision();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "handEngine.v1.GloveInformationResponse.gloveRevision");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // float batteryLevel = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_batterylevel = this->_internal_batterylevel();
  ::uint32_t raw_batterylevel;
  memcpy(&raw_batterylevel, &tmp_batterylevel, sizeof(tmp_batterylevel));
  if (raw_batterylevel != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_batterylevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.GloveInformationResponse)
  return target;
}

::size_t GloveInformationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.GloveInformationResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string serialNumber = 1;
  if (!this->_internal_serialnumber().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_serialnumber());
  }

  // string gloveId = 2;
  if (!this->_internal_gloveid().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_gloveid());
  }

  // string gloveFirmware = 3;
  if (!this->_internal_glovefirmware().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_glovefirmware());
  }

  // string dongleFirmware = 4;
  if (!this->_internal_donglefirmware().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_donglefirmware());
  }

  // string gloveRevision = 5;
  if (!this->_internal_gloverevision().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_gloverevision());
  }

  // float batteryLevel = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_batterylevel = this->_internal_batterylevel();
  ::uint32_t raw_batterylevel;
  memcpy(&raw_batterylevel, &tmp_batterylevel, sizeof(tmp_batterylevel));
  if (raw_batterylevel != 0) {
    total_size += 5;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GloveInformationResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GloveInformationResponse*>(
      &from));
}

void GloveInformationResponse::MergeFrom(const GloveInformationResponse& from) {
  GloveInformationResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.GloveInformationResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_serialnumber().empty()) {
    _this->_internal_set_serialnumber(from._internal_serialnumber());
  }
  if (!from._internal_gloveid().empty()) {
    _this->_internal_set_gloveid(from._internal_gloveid());
  }
  if (!from._internal_glovefirmware().empty()) {
    _this->_internal_set_glovefirmware(from._internal_glovefirmware());
  }
  if (!from._internal_donglefirmware().empty()) {
    _this->_internal_set_donglefirmware(from._internal_donglefirmware());
  }
  if (!from._internal_gloverevision().empty()) {
    _this->_internal_set_gloverevision(from._internal_gloverevision());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_batterylevel = from._internal_batterylevel();
  ::uint32_t raw_batterylevel;
  memcpy(&raw_batterylevel, &tmp_batterylevel, sizeof(tmp_batterylevel));
  if (raw_batterylevel != 0) {
    _this->_internal_set_batterylevel(from._internal_batterylevel());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GloveInformationResponse::CopyFrom(const GloveInformationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.GloveInformationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GloveInformationResponse::IsInitialized() const {
  return true;
}

void GloveInformationResponse::InternalSwap(GloveInformationResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.serialnumber_, lhs_arena,
                                       &other->_impl_.serialnumber_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.gloveid_, lhs_arena,
                                       &other->_impl_.gloveid_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.glovefirmware_, lhs_arena,
                                       &other->_impl_.glovefirmware_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.donglefirmware_, lhs_arena,
                                       &other->_impl_.donglefirmware_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.gloverevision_, lhs_arena,
                                       &other->_impl_.gloverevision_, rhs_arena);

  swap(_impl_.batterylevel_, other->_impl_.batterylevel_);
}

std::string GloveInformationResponse::GetTypeName() const {
  return "handEngine.v1.GloveInformationResponse";
}

// ===================================================================

class BlankResponse::_Internal {
 public:
};

BlankResponse::BlankResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:handEngine.v1.BlankResponse)
}
BlankResponse::BlankResponse(const BlankResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:handEngine.v1.BlankResponse)
}

inline void BlankResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

BlankResponse::~BlankResponse() {
  // @@protoc_insertion_point(destructor:handEngine.v1.BlankResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlankResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void BlankResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlankResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:handEngine.v1.BlankResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* BlankResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BlankResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:handEngine.v1.BlankResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:handEngine.v1.BlankResponse)
  return target;
}

::size_t BlankResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:handEngine.v1.BlankResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlankResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BlankResponse*>(
      &from));
}

void BlankResponse::MergeFrom(const BlankResponse& from) {
  BlankResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:handEngine.v1.BlankResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BlankResponse::CopyFrom(const BlankResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:handEngine.v1.BlankResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlankResponse::IsInitialized() const {
  return true;
}

void BlankResponse::InternalSwap(BlankResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string BlankResponse::GetTypeName() const {
  return "handEngine.v1.BlankResponse";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace handEngine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::handEngine::v1::BlankRequest*
Arena::CreateMaybeMessage< ::handEngine::v1::BlankRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::BlankRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::ProfileMeta*
Arena::CreateMaybeMessage< ::handEngine::v1::ProfileMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::ProfileMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::GloveInformationResponse*
Arena::CreateMaybeMessage< ::handEngine::v1::GloveInformationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::GloveInformationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::handEngine::v1::BlankResponse*
Arena::CreateMaybeMessage< ::handEngine::v1::BlankResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::handEngine::v1::BlankResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
